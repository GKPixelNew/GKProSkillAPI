var cp=Object.defineProperty;var pp=(s,e,t)=>e in s?cp(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var c=(s,e,t)=>pp(s,typeof e!="symbol"?e+"":e,t);import{w as hp,b as ft,g as St,d as zt}from"../chunks/entry.Cit_zBAV.js";import{B as dp,D as k,a as ut,b as ie,F as L,M as Vt,d as $u,c as Fu,e as mp,m as fp,o as Ou}from"../chunks/modal-service.BP0WE5t0.js";import{s as $e,D as Re,Y as He,q as de,b as W,k as U,l as P,d as v,X as ht,e as S,t as pe,f as A,i as Z,j as he,w as f,m as D,p as Le,n as fe,a7 as it,x as R,z as be,B as Ce,a1 as bt,a2 as Ke,ab as jt,L as zc,_ as Ie,o as Su,$ as Au,a4 as gp,a5 as wp,E as Gt,ac as Ru,J as De,r as re,y as Xe,v as ne,ad as Nu,c as Wc,a6 as pt,u as Uc,g as jc,a as Gc,A as Yc,Z as yp,a3 as Tp,a9 as Wr,a8 as qt}from"../chunks/scheduler.BhI5XxMk.js";import{S as Fe,i as Oe,f as Be,b as J,d as ae,m as Q,t as E,a as F,e as ee,g as Te,c as ve,n as vp,l as bp,o as Et,p as Ct,h as ye}from"../chunks/index.CIi2B72K.js";import{S as Pt,e as Pe,u as Rt,f as kp,a as _p,b as Ip,d as Dp,g as Sp,o as Sr,c as Ap,T as Vu}from"../chunks/Toggle.DRzNC6Zc.js";import{v as Xc,M as Vp,L as qp,S as Ep,g as Cp,a as qu,b as Kc,c as Ar,d as Zc,f as Pp,h as Mc,i as Ge,j as $p,k as Fp,l as Op,m as Me,n as Rp,o as Je,p as Jc,q as Np,r as Lp,s as xp,t as Hp,u as Bp,w as Lu,x as xu,V as Hu}from"../chunks/StringSelectOption.D-msO8Da.js";import{P as je,b as rt,J as zp,x as at,H as yt,s as xe,G as ot,K as Qc,L as Ur,M as Wp,N as Up,w as jp,h as ce,y as Tt,O as b,f as me,c as Gp,p as Bu,Y as jr,Q as ep,I as Yp,S as tp,B as Xp,U as ap,a as Yt,V as mt,W as Xt,X as At,Z as wt,g as Ut,T as vt,_ as Gr,z as Kp,$ as zu,a0 as Wt,r as Kt,e as Ot,a1 as Zp,u as Wu,q as Uu,a2 as ju,a3 as Gu,a4 as sp,a5 as Mp,a6 as Jp,a7 as Br,a8 as Qp,a9 as eh,aa as th,ab as Dt}from"../chunks/class-store.WPxaZl8y.js";import{t as Yr,i as ah,r as sh,u as oh,l as op,a as rp,g as rh,b as nh,c as Yu,d as Xu,e as Ku,f as Zu,h as Mu}from"../chunks/cdn.yXNCj4dN.js";function Ju(s,e){const t={},a={},r={$$scope:1};let i=s.length;for(;i--;){const o=s[i],l=e[i];if(l){for(const n in o)n in l||(a[n]=1);for(const n in l)r[n]||(t[n]=l[n],r[n]=1);s[i]=l}else for(const n in o)r[n]=1}for(const o in a)o in t||(t[o]=void 0);return t}function Qu(s){return typeof s=="object"&&s!==null?s:{}}const Xr="https://paste.travja.dev",ih=s=>{if(typeof s!="string")return Promise.reject(new Error('You cannot send that. Please include a "content" argument that is a valid string.'));if(s==="")return Promise.reject(new Error("You cannot send nothing."));const e={method:"POST",body:s,headers:{"Content-Type":"text/plain"}};return fetch(`${Xr}/documents`,e).then(t=>t.json()).then(t=>{if(!t.key)throw new Error("Did not receive hastebin key.");return`${Xr}/${t.key}`})},np=async s=>(s.url&&(s.url.includes("astebin.com")||s.url.includes("paste.travja.dev"))&&!s.url.includes("raw")&&(s.url=s.url.replace(/(astebin\.com|paste\.travja\.dev)/,"$1/raw")),!s.url&&s.id&&(s.url=`${Xr}/raw/${s.id}`),s.url?await(await fetch(s.url)).text():"");function lh(s){let e,t,a;function r(o){s[6](o)}let i={id:s[1],placeholder:s[2],multiple:s[3],data:s[4]?["Any",...s[5].BLOCKS]:s[5].BLOCKS};return s[0]!==void 0&&(i.selected=s[0]),e=new Pt({props:i}),Re.push(()=>Be(e,"selected",r)),{c(){J(e.$$.fragment)},l(o){ae(e.$$.fragment,o)},m(o,l){Q(e,o,l),a=!0},p(o,[l]){const n={};l&2&&(n.id=o[1]),l&4&&(n.placeholder=o[2]),l&8&&(n.multiple=o[3]),l&48&&(n.data=o[4]?["Any",...o[5].BLOCKS]:o[5].BLOCKS),!t&&l&1&&(t=!0,n.selected=o[0],He(()=>t=!1)),e.$set(n)},i(o){a||(E(e.$$.fragment,o),a=!0)},o(o){F(e.$$.fragment,o),a=!1},d(o){ee(e,o)}}}function uh(s,e,t){let a;de(s,Xc,p=>t(5,a=p));let{id:r=void 0}=e,{placeholder:i=""}=e,{multiple:o=!1}=e,{any:l=!1}=e,{selected:n=void 0}=e;function u(p){n=p,t(0,n)}return s.$$set=p=>{"id"in p&&t(1,r=p.id),"placeholder"in p&&t(2,i=p.placeholder),"multiple"in p&&t(3,o=p.multiple),"any"in p&&t(4,l=p.any),"selected"in p&&t(0,n=p.selected)},[n,r,i,o,l,a,u]}let ch=class extends Fe{constructor(e){super(),Oe(this,e,uh,lh,$e,{id:1,placeholder:2,multiple:3,any:4,selected:0})}};function ph(s){let e,t,a;function r(o){s[1](o)}let i={any:!0,multiple:!0};return s[0].material!==void 0&&(i.selected=s[0].material),e=new ch({props:i}),Re.push(()=>Be(e,"selected",r)),{c(){J(e.$$.fragment)},l(o){ae(e.$$.fragment,o)},m(o,l){Q(e,o,l),a=!0},p(o,l){const n={};!t&&l&1&&(t=!0,n.selected=o[0].material,He(()=>t=!1)),e.$set(n)},i(o){a||(E(e.$$.fragment,o),a=!0)},o(o){F(e.$$.fragment,o),a=!1},d(o){ee(e,o)}}}function hh(s){let e,t,a,r,i;e=new je({props:{label:"Material",tooltip:"[material] "+s[0].materialTooltip,$$slots:{default:[ph]},$$scope:{ctx:s}}});function o(n){s[2](n)}let l={type:"number",intMode:!0,label:"Data",tooltip:"[data] "+s[0].dataTooltip};return s[0].data!==void 0&&(l.value=s[0].data),a=new je({props:l}),Re.push(()=>Be(a,"value",o)),{c(){J(e.$$.fragment),t=W(),J(a.$$.fragment)},l(n){ae(e.$$.fragment,n),t=U(n),ae(a.$$.fragment,n)},m(n,u){Q(e,n,u),P(n,t,u),Q(a,n,u),i=!0},p(n,[u]){const p={};u&1&&(p.tooltip="[material] "+n[0].materialTooltip),u&17&&(p.$$scope={dirty:u,ctx:n}),e.$set(p);const w={};u&1&&(w.tooltip="[data] "+n[0].dataTooltip),!r&&u&1&&(r=!0,w.value=n[0].data,He(()=>r=!1)),a.$set(w)},i(n){i||(E(e.$$.fragment,n),E(a.$$.fragment,n),i=!0)},o(n){F(e.$$.fragment,n),F(a.$$.fragment,n),i=!1},d(n){n&&v(t),ee(e,n),ee(a,n)}}}function dh(s,e,t){let{data:a}=e;const r=ht();function i(l){s.$$.not_equal(a.material,l)&&(a.material=l,t(0,a))}function o(l){s.$$.not_equal(a.data,l)&&(a.data=l,t(0,a))}return s.$$set=l=>{"data"in l&&t(0,a=l.data)},s.$$.update=()=>{s.$$.dirty&1&&a&&r("save")},[a,i,o]}class mh extends Fe{constructor(e){super(),Oe(this,e,dh,hh,$e,{data:0})}}class Vr extends rt{constructor(t,a){super();c(this,"key","block");c(this,"component",mh);c(this,"data",{material:["Any"],data:-1,materialTooltip:"",dataTooltip:""});c(this,"setTooltip",()=>{throw new Error("Block Select requires tooltips be set in the constructor")});c(this,"clone",()=>{const t=new Vr;return t.data=JSON.parse(JSON.stringify(this.data)),t});c(this,"getData",()=>{const t={};return t.material=this.data.material,t.data=this.data.data??-1,t});c(this,"getSummary",()=>this.data.material+(this.data.data!=-1?":"+this.data.data:""));c(this,"deserialize",t=>{this.data.material=t.material||["Any"],this.data.data=t.data||-1});this.data.materialTooltip=t||"",this.data.dataTooltip=a||""}}function fh(s){let e,t,a,r;function i(n){s[2](n)}function o(n){s[3](n)}let l={};return s[0].material!==void 0&&(l.selected=s[0].material),s[0].any!==void 0&&(l.any=s[0].any),e=new Vp({props:l}),Re.push(()=>Be(e,"selected",i)),Re.push(()=>Be(e,"any",o)),{c(){J(e.$$.fragment)},l(n){ae(e.$$.fragment,n)},m(n,u){Q(e,n,u),r=!0},p(n,u){const p={};!t&&u&1&&(t=!0,p.selected=n[0].material,He(()=>t=!1)),!a&&u&1&&(a=!0,p.any=n[0].any,He(()=>a=!1)),e.$set(p)},i(n){r||(E(e.$$.fragment,n),r=!0)},o(n){F(e.$$.fragment,n),r=!1},d(n){ee(e,n)}}}function gh(s){let e,t;return e=new je({props:{label:"Material",tooltip:"[material] "+s[1],$$slots:{default:[fh]},$$scope:{ctx:s}}}),{c(){J(e.$$.fragment)},l(a){ae(e.$$.fragment,a)},m(a,r){Q(e,a,r),t=!0},p(a,[r]){const i={};r&2&&(i.tooltip="[material] "+a[1]),r&33&&(i.$$scope={dirty:r,ctx:a}),e.$set(i)},i(a){t||(E(e.$$.fragment,a),t=!0)},o(a){F(e.$$.fragment,a),t=!1},d(a){ee(e,a)}}}function wh(s,e,t){let{data:a}=e,{tooltip:r=void 0}=e;const i=ht();function o(n){s.$$.not_equal(a.material,n)&&(a.material=n,t(0,a))}function l(n){s.$$.not_equal(a.any,n)&&(a.any=n,t(0,a))}return s.$$set=n=>{"data"in n&&t(0,a=n.data),"tooltip"in n&&t(1,r=n.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&a&&i("save")},[a,r,o,l]}class yh extends Fe{constructor(e){super(),Oe(this,e,wh,gh,$e,{data:0,tooltip:1})}}class Nt extends rt{constructor(t=!0,a){super();c(this,"component",yh);c(this,"key","material");c(this,"data",{material:"Dirt",any:!1});c(this,"tooltip");c(this,"setTooltip",t=>(this.tooltip=t,this));c(this,"clone",()=>{const t=new Nt;return t.data.material=this.data.material,t.data.any=this.data.any,t});c(this,"getData",()=>{const t={};return t.material=this.data.material,t});c(this,"getSummary",()=>this.data.material);c(this,"deserialize",t=>this.data.material=t[this.key]||"Dirt");this.data.any=t,a&&(this.data.material=a)}}class _ extends rt{constructor(t,a,r=!1){super();c(this,"component",dp);c(this,"name");c(this,"key");c(this,"data");c(this,"tooltip");c(this,"setTooltip",t=>(this.tooltip=t,this));c(this,"clone",()=>new _(this.name,this.key,this.data));c(this,"getData",()=>{const t={};return t[this.key]=this.data,t});c(this,"getSummary",()=>this.data?"true":"");c(this,"deserialize",t=>this.data=zp(t[this.key]));this.name=t,this.key=a,this.data=r}}function Th(s){let e,t,a;function r(o){s[3](o)}let i={label:s[1],tooltip:s[2],type:"number",placeholder:"0"};return s[0]!==void 0&&(i.value=s[0]),e=new je({props:i}),Re.push(()=>Be(e,"value",r)),{c(){J(e.$$.fragment)},l(o){ae(e.$$.fragment,o)},m(o,l){Q(e,o,l),a=!0},p(o,[l]){const n={};l&2&&(n.label=o[1]),l&4&&(n.tooltip=o[2]),!t&&l&1&&(t=!0,n.value=o[0],He(()=>t=!1)),e.$set(n)},i(o){a||(E(e.$$.fragment,o),a=!0)},o(o){F(e.$$.fragment,o),a=!1},d(o){ee(e,o)}}}function vh(s,e,t){let{data:a}=e,{name:r=""}=e,{tooltip:i=void 0}=e;const o=ht();function l(n){a=n,t(0,a)}return s.$$set=n=>{"data"in n&&t(0,a=n.data),"name"in n&&t(1,r=n.name),"tooltip"in n&&t(2,i=n.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&(a||!a)&&o("save")},[a,r,i,l]}class bh extends Fe{constructor(e){super(),Oe(this,e,vh,Th,$e,{data:0,name:1,tooltip:2})}}class V extends rt{constructor(t,a,r=0){super();c(this,"component",bh);c(this,"name");c(this,"key");c(this,"data");c(this,"tooltip");c(this,"setTooltip",t=>(this.tooltip=t,this));c(this,"clone",()=>new V(this.name,this.key,this.data));c(this,"getData",()=>{const t={};return t[this.key]=this.data||0,t});c(this,"getSummary",()=>this.data.toString());c(this,"deserialize",t=>this.data=t[this.key]||0);this.name=t,this.key=a,this.data=r}}function kh(s){let e,t,a;function r(o){s[3](o)}let i={};return s[0].value!==void 0&&(i.value=s[0].value),e=new qp({props:i}),Re.push(()=>Be(e,"value",r)),{c(){J(e.$$.fragment)},l(o){ae(e.$$.fragment,o)},m(o,l){Q(e,o,l),a=!0},p(o,l){const n={};!t&&l&1&&(t=!0,n.value=o[0].value,He(()=>t=!1)),e.$set(n)},i(o){a||(E(e.$$.fragment,o),a=!0)},o(o){F(e.$$.fragment,o),a=!1},d(o){ee(e,o)}}}function _h(s){let e,t;return e=new je({props:{label:s[1],tooltip:s[2],$$slots:{default:[kh]},$$scope:{ctx:s}}}),{c(){J(e.$$.fragment)},l(a){ae(e.$$.fragment,a)},m(a,r){Q(e,a,r),t=!0},p(a,[r]){const i={};r&2&&(i.label=a[1]),r&4&&(i.tooltip=a[2]),r&33&&(i.$$scope={dirty:r,ctx:a}),e.$set(i)},i(a){t||(E(e.$$.fragment,a),t=!0)},o(a){F(e.$$.fragment,a),t=!1},d(a){ee(e,a)}}}function Ih(s,e,t){let{data:a}=e,{name:r=""}=e,{tooltip:i=void 0}=e;const o=ht();function l(n){s.$$.not_equal(a.value,n)&&(a.value=n,t(0,a))}return s.$$set=n=>{"data"in n&&t(0,a=n.data),"name"in n&&t(1,r=n.name),"tooltip"in n&&t(2,i=n.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&a&&o("save")},[a,r,i,l]}class Dh extends Fe{constructor(e){super(),Oe(this,e,Ih,_h,$e,{data:0,name:1,tooltip:2})}}class Qe extends rt{constructor(t,a,r){super();c(this,"component",Dh);c(this,"data",{value:[]});c(this,"name","");c(this,"key","");c(this,"tooltip");c(this,"setTooltip",t=>(this.tooltip=t,this));c(this,"clone",()=>new Qe(this.name,this.key,[...this.data.value]));c(this,"getData",()=>{const t={};return t[this.key]=this.data.value,t});c(this,"getSummary",()=>{var t;return(t=this.data)!=null&&t.value?this.data.value.join(", "):""});c(this,"deserialize",t=>this.data.value=t[this.key]||[]);this.name=t,this.key=a,this.data.value=r||[]}}function Sh(s){let e,t,a,r;return{c(){e=S("div"),t=pe(s[0]),a=W(),r=S("hr"),this.h()},l(i){e=A(i,"DIV",{class:!0});var o=Z(e);t=he(o,s[0]),a=U(o),r=A(o,"HR",{class:!0}),o.forEach(v),this.h()},h(){f(r,"class","svelte-x2dop6"),f(e,"class","svelte-x2dop6")},m(i,o){P(i,e,o),D(e,t),D(e,a),D(e,r)},p(i,[o]){o&1&&Le(t,i[0])},i:fe,o:fe,d(i){i&&v(e)}}}function Ah(s,e,t){let{data:a}=e;return s.$$set=r=>{"data"in r&&t(0,a=r.data)},[a]}class Vh extends Fe{constructor(e){super(),Oe(this,e,Ah,Sh,$e,{data:0})}}class ue extends rt{constructor(t){super();c(this,"key","section-marker");c(this,"component",Vh);c(this,"data");c(this,"setTooltip",()=>this);c(this,"clone",()=>new ue(this.data));c(this,"getData",()=>({}));c(this,"getSummary",()=>this.data);c(this,"deserialize",()=>{});this.data=t}}class B extends rt{constructor(t,a,r=""){super();c(this,"component",Ep);c(this,"name");c(this,"key");c(this,"data");c(this,"tooltip");c(this,"setTooltip",t=>(this.tooltip=t,this));c(this,"clone",()=>new B(this.name,this.key,this.data));c(this,"getData",()=>{const t={};return t[this.key]=this.data||"",t});c(this,"getSummary",()=>this.data);c(this,"deserialize",t=>this.data=t[this.key]||"");this.name=t,this.key=a,this.data=r}}function qh(s){let e,t,a,r;function i(n){s[6](n)}function o(n){s[7](n)}let l={multiple:s[3]};return s[4]!==void 0&&(l.data=s[4]),s[0]!==void 0&&(l.selected=s[0]),e=new Pt({props:l}),Re.push(()=>Be(e,"data",i)),Re.push(()=>Be(e,"selected",o)),{c(){J(e.$$.fragment)},l(n){ae(e.$$.fragment,n)},m(n,u){Q(e,n,u),r=!0},p(n,u){const p={};u&8&&(p.multiple=n[3]),!t&&u&16&&(t=!0,p.data=n[4],He(()=>t=!1)),!a&&u&1&&(a=!0,p.selected=n[0],He(()=>a=!1)),e.$set(p)},i(n){r||(E(e.$$.fragment,n),r=!0)},o(n){F(e.$$.fragment,n),r=!1},d(n){ee(e,n)}}}function Eh(s){let e,t;return e=new je({props:{label:s[1],tooltip:s[2],$$slots:{default:[qh]},$$scope:{ctx:s}}}),{c(){J(e.$$.fragment)},l(a){ae(e.$$.fragment,a)},m(a,r){Q(e,a,r),t=!0},p(a,[r]){const i={};r&2&&(i.label=a[1]),r&4&&(i.tooltip=a[2]),r&537&&(i.$$scope={dirty:r,ctx:a}),e.$set(i)},i(a){t||(E(e.$$.fragment,a),t=!0)},o(a){F(e.$$.fragment,a),t=!1},d(a){ee(e,a)}}}function Ch(s,e,t){let a,{data:r=[]}=e,{name:i=""}=e,{tooltip:o=void 0}=e,{multiple:l=!0}=e;const n=at.classes;de(s,n,h=>t(4,a=h));const u=ht();function p(h){a=h,n.set(a)}function w(h){r=h,t(0,r),t(3,l)}return s.$$set=h=>{"data"in h&&t(0,r=h.data),"name"in h&&t(1,i=h.name),"tooltip"in h&&t(2,o=h.tooltip),"multiple"in h&&t(3,l=h.multiple)},s.$$.update=()=>{if(s.$$.dirty&9&&!l&&r.length===0&&t(0,r=""),s.$$.dirty&1)if(r instanceof Array)t(0,r=r.map(h=>{if(h instanceof yt)return h;const m=at.getClass(h);if(m)return m})),u("save");else{if(r&&!(r instanceof yt)){const h=at.getClass(r);h&&t(0,r=h)}u("save")}},[r,i,o,l,a,n,p,w]}class Ph extends Fe{constructor(e){super(),Oe(this,e,Ch,Eh,$e,{data:0,name:1,tooltip:2,multiple:3})}}class Eu extends rt{constructor(t,a,r=!0){super();c(this,"component",Ph);c(this,"name");c(this,"key");c(this,"data",[]);c(this,"tooltip");c(this,"multiple",!0);c(this,"setTooltip",t=>(this.tooltip=t,this));c(this,"clone",()=>{const t=new Eu(this.name,this.key);return t.data=this.data,t});c(this,"getData",()=>{const t={};return this.data instanceof Array?t[this.key]=this.data.map(a=>a instanceof yt?a.name:a):t[this.key]=this.data instanceof yt?this.data.name:this.data,t});c(this,"getSummary",()=>this.data instanceof Array?this.data.map(t=>t instanceof yt?t.name:t).join(", "):this.data instanceof yt?this.data.name:this.data);c(this,"deserialize",t=>this.data=t[this.key]||(this.multiple?[]:""));this.name=t,this.key=a,this.multiple=r}}function $h(s){let e,t,a,r;function i(n){s[6](n)}function o(n){s[7](n)}let l={multiple:s[3]};return s[4]!==void 0&&(l.data=s[4]),s[0]!==void 0&&(l.selected=s[0]),e=new Pt({props:l}),Re.push(()=>Be(e,"data",i)),Re.push(()=>Be(e,"selected",o)),{c(){J(e.$$.fragment)},l(n){ae(e.$$.fragment,n)},m(n,u){Q(e,n,u),r=!0},p(n,u){const p={};u&8&&(p.multiple=n[3]),!t&&u&16&&(t=!0,p.data=n[4],He(()=>t=!1)),!a&&u&1&&(a=!0,p.selected=n[0],He(()=>a=!1)),e.$set(p)},i(n){r||(E(e.$$.fragment,n),r=!0)},o(n){F(e.$$.fragment,n),r=!1},d(n){ee(e,n)}}}function Fh(s){let e,t;return e=new je({props:{label:s[1],tooltip:s[2],$$slots:{default:[$h]},$$scope:{ctx:s}}}),{c(){J(e.$$.fragment)},l(a){ae(e.$$.fragment,a)},m(a,r){Q(e,a,r),t=!0},p(a,[r]){const i={};r&2&&(i.label=a[1]),r&4&&(i.tooltip=a[2]),r&537&&(i.$$scope={dirty:r,ctx:a}),e.$set(i)},i(a){t||(E(e.$$.fragment,a),t=!0)},o(a){F(e.$$.fragment,a),t=!1},d(a){ee(e,a)}}}function Oh(s,e,t){let a,{data:r=[]}=e,{name:i=""}=e,{tooltip:o=void 0}=e,{multiple:l=!0}=e;const n=xe.skills;de(s,n,h=>t(4,a=h));const u=ht();function p(h){a=h,n.set(a)}function w(h){r=h,t(0,r),t(3,l)}return s.$$set=h=>{"data"in h&&t(0,r=h.data),"name"in h&&t(1,i=h.name),"tooltip"in h&&t(2,o=h.tooltip),"multiple"in h&&t(3,l=h.multiple)},s.$$.update=()=>{if(s.$$.dirty&9&&!l&&(!r||r.length===0)&&t(0,r=""),s.$$.dirty&1)if(r instanceof Array)t(0,r=r.map(h=>{if(h instanceof ot)return h;const m=xe.getSkill(h);if(m)return m})),u("save");else{if(r&&!(r instanceof ot)){const h=xe.getSkill(r);h&&t(0,r=h)}u("save")}},[r,i,o,l,a,n,p,w]}class Rh extends Fe{constructor(e){super(),Oe(this,e,Oh,Fh,$e,{data:0,name:1,tooltip:2,multiple:3})}}class qr extends rt{constructor(t,a,r=!0){super();c(this,"component",Rh);c(this,"name");c(this,"key");c(this,"data",[]);c(this,"tooltip");c(this,"multiple",!0);c(this,"setTooltip",t=>(this.tooltip=t,this));c(this,"clone",()=>{const t=new qr(this.name,this.key);return t.data=this.data,t});c(this,"getData",()=>{const t={};return this.data instanceof Array?t[this.key]=this.data.map(a=>a instanceof ot?a.name:a):t[this.key]=this.data instanceof ot?this.data.name:this.data,t});c(this,"getSummary",()=>this.data instanceof Array?this.data.map(t=>t instanceof ot?t.name:t).join(", "):this.data instanceof ot?this.data.name:this.data);c(this,"deserialize",t=>{const a=t[this.key];a instanceof Array?this.data=a.map(r=>xe.getSkill(r)||new ot({name:r})):a?this.data=xe.getSkill(a)||new ot({name:a}):this.data=this.multiple?[]:""});this.name=t,this.key=a,this.multiple=r}}function Nh(s){let e,t,a;function r(o){s[3](o)}let i={label:s[1],tooltip:s[2],type:"number",intMode:!0,placeholder:"0"};return s[0]!==void 0&&(i.value=s[0]),e=new je({props:i}),Re.push(()=>Be(e,"value",r)),{c(){J(e.$$.fragment)},l(o){ae(e.$$.fragment,o)},m(o,l){Q(e,o,l),a=!0},p(o,[l]){const n={};l&2&&(n.label=o[1]),l&4&&(n.tooltip=o[2]),!t&&l&1&&(t=!0,n.value=o[0],He(()=>t=!1)),e.$set(n)},i(o){a||(E(e.$$.fragment,o),a=!0)},o(o){F(e.$$.fragment,o),a=!1},d(o){ee(e,o)}}}function Lh(s,e,t){let{data:a}=e,{name:r=""}=e,{tooltip:i=void 0}=e;const o=ht();function l(n){a=n,t(0,a)}return s.$$set=n=>{"data"in n&&t(0,a=n.data),"name"in n&&t(1,r=n.name),"tooltip"in n&&t(2,i=n.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&(a||!a)&&o("save")},[a,r,i,l]}class xh extends Fe{constructor(e){super(),Oe(this,e,Lh,Nh,$e,{data:0,name:1,tooltip:2})}}class G extends rt{constructor(t,a,r=0){super();c(this,"component",xh);c(this,"name");c(this,"key");c(this,"data");c(this,"tooltip");c(this,"setTooltip",t=>(this.tooltip=t,this));c(this,"clone",()=>new G(this.name,this.key,this.data));c(this,"getData",()=>{const t={};return t[this.key]=this.data||0,t});c(this,"getSummary",()=>this.data.toString());c(this,"deserialize",t=>this.data=t[this.key]||0);this.name=t,this.key=a,this.data=r}}function Hh(s){let e,t,a,r,i,o;return{c(){e=S("div"),t=S("input"),a=W(),r=S("input"),this.h()},l(l){e=A(l,"DIV",{class:!0});var n=Z(e);t=A(n,"INPUT",{class:!0}),a=U(n),r=A(n,"INPUT",{type:!0,class:!0}),n.forEach(v),this.h()},h(){f(t,"class","text svelte-1ncbyp2"),f(r,"type","color"),f(r,"class","svelte-1ncbyp2"),f(e,"class","wrap svelte-1ncbyp2")},m(l,n){P(l,e,n),D(e,t),it(t,s[0]),D(e,a),D(e,r),it(r,s[0]),i||(o=[R(t,"input",s[3]),R(r,"input",s[4])],i=!0)},p(l,n){n&1&&t.value!==l[0]&&it(t,l[0]),n&1&&it(r,l[0])},d(l){l&&v(e),i=!1,be(o)}}}function Bh(s){let e,t;return e=new je({props:{label:s[1],tooltip:s[2],$$slots:{default:[Hh]},$$scope:{ctx:s}}}),{c(){J(e.$$.fragment)},l(a){ae(e.$$.fragment,a)},m(a,r){Q(e,a,r),t=!0},p(a,[r]){const i={};r&2&&(i.label=a[1]),r&4&&(i.tooltip=a[2]),r&65&&(i.$$scope={dirty:r,ctx:a}),e.$set(i)},i(a){t||(E(e.$$.fragment,a),t=!0)},o(a){F(e.$$.fragment,a),t=!1},d(a){ee(e,a)}}}function zh(s,e,t){let{data:a}=e,{name:r=""}=e,{tooltip:i=void 0}=e;const o=ht();function l(){a=this.value,t(0,a)}function n(){a=this.value,t(0,a)}return s.$$set=u=>{"data"in u&&t(0,a=u.data),"name"in u&&t(1,r=u.name),"tooltip"in u&&t(2,i=u.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&(a||!a)&&o("save")},[a,r,i,l,n]}class Wh extends Fe{constructor(e){super(),Oe(this,e,zh,Bh,$e,{data:0,name:1,tooltip:2})}}class we extends rt{constructor(t,a,r="#12cfab"){super();c(this,"component",Wh);c(this,"name");c(this,"key");c(this,"data");c(this,"tooltip");c(this,"setTooltip",t=>(this.tooltip=t,this));c(this,"clone",()=>new we(this.name,this.key,this.data));c(this,"getData",()=>{const t={};return t[this.key]=this.data||"#000000",t});c(this,"getSummary",()=>this.data);c(this,"deserialize",t=>this.data=t[this.key]||"#12cfab");this.name=t,this.key=a,this.data=r}}function ec(s,e,t){const a=s.slice();return a[14]=e[t],a[15]=e,a[16]=t,a}function Uh(s){let e,t,a;function r(o){s[13](o)}let i={id:s[1],placeholder:s[2],data:s[4]?["Any",...s[6].ENCHANTS]:s[6].ENCHANTS};return s[0]!==void 0&&(i.selected=s[0]),e=new Pt({props:i}),Re.push(()=>Be(e,"selected",r)),{c(){J(e.$$.fragment)},l(o){ae(e.$$.fragment,o)},m(o,l){Q(e,o,l),a=!0},p(o,l){const n={};l&2&&(n.id=o[1]),l&4&&(n.placeholder=o[2]),l&80&&(n.data=o[4]?["Any",...o[6].ENCHANTS]:o[6].ENCHANTS),!t&&l&1&&(t=!0,n.selected=o[0],He(()=>t=!1)),e.$set(n)},i(o){a||(E(e.$$.fragment,o),a=!0)},o(o){F(e.$$.fragment,o),a=!1},d(o){ee(e,o)}}}function jh(s){let e,t,a,r=s[0]&&s[0]instanceof Array&&tc(s),i={id:s[1],placeholder:s[2],data:s[4]?["Any",...s[6].ENCHANTS]:s[6].ENCHANTS};return t=new Pt({props:i}),s[12](t),t.$on("select",s[7]),{c(){r&&r.c(),e=W(),J(t.$$.fragment)},l(o){r&&r.l(o),e=U(o),ae(t.$$.fragment,o)},m(o,l){r&&r.m(o,l),P(o,e,l),Q(t,o,l),a=!0},p(o,l){o[0]&&o[0]instanceof Array?r?(r.p(o,l),l&1&&E(r,1)):(r=tc(o),r.c(),E(r,1),r.m(e.parentNode,e)):r&&(Te(),F(r,1,1,()=>{r=null}),ve());const n={};l&2&&(n.id=o[1]),l&4&&(n.placeholder=o[2]),l&80&&(n.data=o[4]?["Any",...o[6].ENCHANTS]:o[6].ENCHANTS),t.$set(n)},i(o){a||(E(r),E(t.$$.fragment,o),a=!0)},o(o){F(r),F(t.$$.fragment,o),a=!1},d(o){o&&v(e),r&&r.d(o),s[12](null),ee(t,o)}}}function tc(s){let e,t,a=Pe(s[0]),r=[];for(let o=0;o<a.length;o+=1)r[o]=ac(ec(s,a,o));const i=o=>F(r[o],1,1,()=>{r[o]=null});return{c(){for(let o=0;o<r.length;o+=1)r[o].c();e=Ce()},l(o){for(let l=0;l<r.length;l+=1)r[l].l(o);e=Ce()},m(o,l){for(let n=0;n<r.length;n+=1)r[n]&&r[n].m(o,l);P(o,e,l),t=!0},p(o,l){if(l&471){a=Pe(o[0]);let n;for(n=0;n<a.length;n+=1){const u=ec(o,a,n);r[n]?(r[n].p(u,l),E(r[n],1)):(r[n]=ac(u),r[n].c(),E(r[n],1),r[n].m(e.parentNode,e))}for(Te(),n=a.length;n<r.length;n+=1)i(n);ve()}},i(o){if(!t){for(let l=0;l<a.length;l+=1)E(r[l]);t=!0}},o(o){r=r.filter(Boolean);for(let l=0;l<r.length;l+=1)F(r[l]);t=!1},d(o){o&&v(e),bt(r,o)}}}function ac(s){let e,t,a,r,i,o,l;function n(...h){return s[9](s[16],...h)}function u(){return s[10](s[16])}e=new Pt({props:{id:s[1],placeholder:s[2],selected:s[14].name,data:s[4]?["Any",...s[6].ENCHANTS]:s[6].ENCHANTS}}),e.$on("select",n),e.$on("remove",u);function p(h){s[11](h,s[14])}let w={label:"Level",type:"number"};return s[14].level!==void 0&&(w.value=s[14].level),r=new je({props:w}),Re.push(()=>Be(r,"value",p)),{c(){J(e.$$.fragment),t=W(),a=S("div"),J(r.$$.fragment),o=W(),this.h()},l(h){ae(e.$$.fragment,h),t=U(h),a=A(h,"DIV",{class:!0});var m=Z(a);ae(r.$$.fragment,m),o=U(m),m.forEach(v),this.h()},h(){f(a,"class","enchant svelte-11u8x1j")},m(h,m){Q(e,h,m),P(h,t,m),P(h,a,m),Q(r,a,null),D(a,o),l=!0},p(h,m){s=h;const y={};m&2&&(y.id=s[1]),m&4&&(y.placeholder=s[2]),m&1&&(y.selected=s[14].name),m&80&&(y.data=s[4]?["Any",...s[6].ENCHANTS]:s[6].ENCHANTS),e.$set(y);const T={};!i&&m&1&&(i=!0,T.value=s[14].level,He(()=>i=!1)),r.$set(T)},i(h){l||(E(e.$$.fragment,h),E(r.$$.fragment,h),l=!0)},o(h){F(e.$$.fragment,h),F(r.$$.fragment,h),l=!1},d(h){h&&(v(t),v(a)),ee(e,h),ee(r)}}}function Gh(s){let e,t,a,r;const i=[jh,Uh],o=[];function l(n,u){return n[3]?0:1}return e=l(s),t=o[e]=i[e](s),{c(){t.c(),a=Ce()},l(n){t.l(n),a=Ce()},m(n,u){o[e].m(n,u),P(n,a,u),r=!0},p(n,[u]){let p=e;e=l(n),e===p?o[e].p(n,u):(Te(),F(o[p],1,1,()=>{o[p]=null}),ve(),t=o[e],t?t.p(n,u):(t=o[e]=i[e](n),t.c()),E(t,1),t.m(a.parentNode,a))},i(n){r||(E(t),r=!0)},o(n){F(t),r=!1},d(n){n&&v(a),o[e].d(n)}}}function Yh(s,e,t){let a;de(s,Xc,d=>t(6,a=d));let{id:r=void 0}=e,{placeholder:i=""}=e,{multiple:o=!1}=e,{any:l=!1}=e,{selected:n=void 0}=e,u;const p=(d,g=-1)=>{o?(t(0,n=n||[]),g!==-1?t(0,n[g]={name:d.detail,level:1},n):n.push({name:d.detail,level:1}),u.focus(),d.preventDefault()):t(0,n={name:d.detail,level:1})},w=d=>(console.log("remove",d),n&&n instanceof Array?(n.splice(d,1),t(0,n=[...n])):t(0,n=void 0),!0),h=(d,g)=>p(g,d),m=d=>w(d);function y(d,g){s.$$.not_equal(g.level,d)&&(g.level=d,t(0,n))}function T(d){Re[d?"unshift":"push"](()=>{u=d,t(5,u)})}function C(d){n=d,t(0,n)}return s.$$set=d=>{"id"in d&&t(1,r=d.id),"placeholder"in d&&t(2,i=d.placeholder),"multiple"in d&&t(3,o=d.multiple),"any"in d&&t(4,l=d.any),"selected"in d&&t(0,n=d.selected)},[n,r,i,o,l,u,a,p,w,h,m,y,T,C]}let Xh=class extends Fe{constructor(e){super(),Oe(this,e,Yh,Gh,$e,{id:1,placeholder:2,multiple:3,any:4,selected:0})}};function Kh(s){let e,t,a;function r(o){s[2](o)}let i={multiple:!0};return s[0].enchants!==void 0&&(i.selected=s[0].enchants),e=new Xh({props:i}),Re.push(()=>Be(e,"selected",r)),{c(){J(e.$$.fragment)},l(o){ae(e.$$.fragment,o)},m(o,l){Q(e,o,l),a=!0},p(o,l){const n={};!t&&l&1&&(t=!0,n.selected=o[0].enchants,He(()=>t=!1)),e.$set(n)},i(o){a||(E(e.$$.fragment,o),a=!0)},o(o){F(e.$$.fragment,o),a=!1},d(o){ee(e,o)}}}function Zh(s){let e,t;return e=new je({props:{label:"Enchant",tooltip:"[enchant] "+s[1],$$slots:{default:[Kh]},$$scope:{ctx:s}}}),{c(){J(e.$$.fragment)},l(a){ae(e.$$.fragment,a)},m(a,r){Q(e,a,r),t=!0},p(a,[r]){const i={};r&2&&(i.tooltip="[enchant] "+a[1]),r&17&&(i.$$scope={dirty:r,ctx:a}),e.$set(i)},i(a){t||(E(e.$$.fragment,a),t=!0)},o(a){F(e.$$.fragment,a),t=!1},d(a){ee(e,a)}}}function Mh(s,e,t){let{data:a}=e,{tooltip:r=void 0}=e;const i=ht();function o(l){s.$$.not_equal(a.enchants,l)&&(a.enchants=l,t(0,a))}return s.$$set=l=>{"data"in l&&t(0,a=l.data),"tooltip"in l&&t(1,r=l.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&a&&i("save")},[a,r,o]}class Jh extends Fe{constructor(e){super(),Oe(this,e,Mh,Zh,$e,{data:0,tooltip:1})}}class Cu extends rt{constructor(t){super();c(this,"component",Jh);c(this,"key","enchant");c(this,"data",{enchants:[]});c(this,"tooltip");c(this,"setTooltip",t=>(this.tooltip=t,this));c(this,"clone",()=>{const t=new Cu;return t.data.enchants=[...this.data.enchants],t});c(this,"getData",()=>{const t={};return t.enchants=this.data.enchants.map(({name:a,level:r})=>`${a}:${r}`),t});c(this,"getSummary",()=>this.data.enchants.map(({name:t,level:a})=>`${t} ${a}`).join(", "));c(this,"deserialize",t=>{const a=t[this.key]||[];this.data.enchants=a.map(r=>{const[i,o]=r.split(":");return{name:i,level:parseInt(o)}})});t&&(this.data.enchants=[t])}}const Zt=class Zt extends ce{constructor(){super({name:"Armor Equip",description:"Applies skill effects when a player equips a new item in an armor or hand slot",data:[new k("Slots","slots",["Any","Helmet","Chestplate","Leggings","Boots","Main hand","Offhand"],["Any"],!0).setTooltip("The armor slots to check for")],summaryItems:["slots"]})}};c(Zt,"new",()=>new Zt);let Kr=Zt;const Mt=class Mt extends ce{constructor(){super({name:"Attribute Change",description:"Applies skill effects when a player's attribute changes. <code>api-attribute</code> is the attribute name, <code>api-change</code> is the change, and <code>api-value</code> is the new value",data:[new k("Attribute","attr",()=>["Any",...Tt.getAttributeNames()],["Any"],!0).setTooltip("The attribute to check for")],summaryItems:["attr"]})}};c(Mt,"new",()=>new Mt);let Zr=Mt;const Jt=class Jt extends ce{constructor(){super({name:"Block Break",description:"Applies skill effects when a player breaks a block matching the given details",data:[new Vr("The type of block expected to be broken","The expected data value of the block (-1 for any data value)")],summaryItems:["block"]})}};c(Jt,"new",()=>new Jt);let Mr=Jt;const Qt=class Qt extends ce{constructor(){super({name:"Block Place",description:"Applies skill effects when a player places a block matching the given details",data:[new Vr("The type of block expected to be placed","The expected data value of the block (-1 for any data value)")],summaryItems:["block"]})}};c(Qt,"new",()=>new Qt);let Jr=Qt;const ea=class ea extends ce{constructor(){super({name:"Cast",description:"Applies skill effects when a player casts the skill using either the cast command, the skill bar, or click combos"})}};c(ea,"new",()=>new ea);let Qr=ea;const ta=class ta extends ce{constructor(){super({name:"Chat",description:"Applies skill effects when a player sends a chat message in the specified format",data:[new _("Cancel","cancel",!1).setTooltip("Whether to cancel message or not"),new _("Regex","regex",!1).setTooltip("Whether to use format value as regex or check if message contains format value"),new B("Format","format","").setTooltip("Format of message (if message contains format or regex)")],summaryItems:["format","cancel"]})}};c(ta,"new",()=>new ta);let en=ta;const aa=class aa extends ce{constructor(){super({name:"Cleanup",description:"Applies skill effects when the player disconnects or unlearns the skill. This is always applied with a skill level of 1 just for the sake of math"})}};c(aa,"new",()=>new aa);let tn=aa;const sa=class sa extends ce{constructor(){super({name:"Consume",description:"Applies skill effects when a player consumes an item",data:[...kt(new k("Material","material",Cp,"Any").setTooltip("The type of item that the player has consumed.").requireValue("check-mat",[!0]))],summaryItems:["material","potion"]})}};c(sa,"new",()=>new sa);let an=sa;const oa=class oa extends ce{constructor(){super({name:"Crouch",description:"Applies skill effects when a player starts or stops crouching using the shift key",data:[new k("Crouching","type",["Start Crouching","Stop Crouching","Both"])],summaryItems:["type"]})}};c(oa,"new",()=>new oa);let sn=oa;const ra=class ra extends ce{constructor(){super({name:"Death",description:"Applies skill effects when a player dies"})}};c(ra,"new",()=>new ra);let on=ra;const na=class na extends ce{constructor(){super({name:"Drop Item",description:"Applies skill effects upon dropping an item",data:[new k("Drop multiple","drop multiple",["True","False","Ignore"],"Ignore").setTooltip("Whether the player has to drop multiple items or a single item")],summaryItems:["drop multiple"]})}};c(na,"new",()=>new na);let rn=na;const ia=class ia extends ce{constructor(){super({name:"Entity Target",description:"Applies skill effects when an entity targets the caster",data:[new _("Target Caster","target",!0).setTooltip("True makes children target the caster. False makes children target the attacking entity"),new k("Types","types",["Any",...qu()],["Any"],!0).setTooltip("The entity types to target"),new _("Blacklist","blacklist",!1).setTooltip("Whether to consider the listed types as a blacklist, meaning only entities that do NOT match one of them will trigger.")],summaryItems:["target","types","blacklist"]})}};c(ia,"new",()=>new ia);let nn=ia;const la=class la extends ce{constructor(){super({name:"Environment Damage",description:"Applies skill effects when a player takes environmental damage",data:[new k("Type","type",Kc,["Fall"],!0).setTooltip("The source of damage to apply for")],summaryItems:["type"]})}};c(la,"new",()=>new la);let ln=la;const ua=class ua extends ce{constructor(){super({name:"Fishing",description:"Applies skill effects upon right-clicking with a fishing rod"})}};c(ua,"new",()=>new ua);let un=ua;const ca=class ca extends ce{constructor(){super({name:"Fishing Bite",description:"Applies skill effects when a fish bites the fishing rod of a player"})}};c(ca,"new",()=>new ca);let cn=ca;const pa=class pa extends ce{constructor(){super({name:"Fishing Fail",description:"Applies skill effects when a player fails to catch a fish due to poor timing"})}};c(pa,"new",()=>new pa);let pn=pa;const ha=class ha extends ce{constructor(){super({name:"Fishing Grab",description:"Applies skill effects when a player catches a fish"})}};c(ha,"new",()=>new ha);let hn=ha;const da=class da extends ce{constructor(){super({name:"Fishing Ground",description:"Applies skill effects when the bobber of a fishing rod hits the ground"})}};c(da,"new",()=>new da);let dn=da;const ma=class ma extends ce{constructor(){super({name:"Fishing Reel",description:"Applies skill effects when a player reels in a fishing rod out of water or air with no fish on the rod"})}};c(ma,"new",()=>new ma);let mn=ma;const fa=class fa extends ce{constructor(){super({name:"Heal",description:"Applies skill effects when the player receives heal from any source. Use {api-heal} to get heal value",data:[new V("Min Heal","heal-min",0).setTooltip("The minimum health that needs to be received"),new V("Max Heal","heal-max",999).setTooltip("The maximum health that needs to be received")],summaryItems:["heal-min","heal-max"]})}};c(fa,"new",()=>new fa);let fn=fa;const ga=class ga extends ce{constructor(){super({name:"Initialize",description:"Applies skill effects immediately. This can be used for passive abilities"})}};c(ga,"new",()=>new ga);let gn=ga;const wa=class wa extends ce{constructor(){super({name:"Item Swap",description:"Applies skill effects upon pressing the swap-key on your keyboard",data:[new _("Cancel Swap","cancel",!0).setTooltip("True cancels the item swap. False allows the item swap")],summaryItems:["cancel"]})}};c(wa,"new",()=>new wa);let wn=wa;const ya=class ya extends ce{constructor(){super({name:"Kill",description:"Applies skill effects upon killing something",data:[new _("Target Caster","target",!0).setTooltip("True makes children target the caster. False makes children target the attacking entity")],summaryItems:["target"]})}};c(ya,"new",()=>new ya);let yn=ya;const Ta=class Ta extends ce{constructor(){super({name:"Land",description:"Applies skill effects when a player lands on the ground",data:[new V("Min Distance","min-distance").setTooltip("The minimum distance the player should fall before effects activate")],summaryItems:["min-distance"]})}};c(Ta,"new",()=>new Ta);let Tn=Ta;const va=class va extends ce{constructor(){super({name:"Launch",description:"Applies skill effects when a player launches a projectile",data:[new k("Type","type",Ar,"Any").setTooltip("The type of projectile that should be launched")],summaryItems:["type"]})}};c(va,"new",()=>new va);let vn=va;const ba=class ba extends ce{constructor(){super({name:"Left Click",description:"Applies skill effects upon performing a left-click",data:[new k("Crouch","crouch",["Crouch","Dont crouch","Both"],"Crouch").setTooltip("If the player has to be crouching in order for this trigger to function")],summaryItems:["crouch"]})}};c(ba,"new",()=>new ba);let bn=ba;const ka=class ka extends ce{constructor(){super({name:"Move",description:"Applies skill effects when a player moves around. This triggers every tick the player is moving, so use this sparingly. Use the 'api-moved' value to check/use the distance traveled"})}};c(ka,"new",()=>new ka);let kn=ka;const _a=class _a extends ce{constructor(){super({name:"Physical Damage",description:"Applies skill effects when a player deals physical (or non-skill) damage. This includes melee attacks and firing a bow",data:[new _("Target Caster","target",!0).setTooltip("True makes the children target the caster. False makes children target the damaged entity"),new k("Type","type",["Both","Melee","Projectile"],"Both").setTooltip("The type of damage dealt"),new V("Min Damage","dmg-min",0).setTooltip("The minimum damage that needs to be dealt"),new V("Max Damage","dmg-max",999).setTooltip("The minimum damage that needs to be dealt")],summaryItems:["target","type","dmg-min","dmg-max"]})}};c(_a,"new",()=>new _a);let _n=_a;const Ia=class Ia extends ce{constructor(){super({name:"Projectile Hit",description:"Applies skill effects when a projectile hits a block/entity",data:[new _("Target Caster","target",!0).setTooltip("True makes the children target the caster. False makes children target the damaged entity"),new k("Type","type",["Both","Entity","Block"],"Both").setTooltip("The type of what projectile hits"),new k("Projectile","projectile",Ar,["Any"],!0).setTooltip("The type of projectile shot")],summaryItems:["target","type","projectile"]})}};c(Ia,"new",()=>new Ia);let In=Ia;const Da=class Da extends ce{constructor(){super({name:"Projectile Tick",description:"Applies skill effects every interval while a projectile is in the air",data:[new _("Target Caster","target",!0).setTooltip("True makes the children target the caster. False makes children target the damaged entity"),new G("Interval","interval",1).setTooltip("Interval between trigger executions"),new G("Delay","delay",0).setTooltip("Delay before executing trigger for the first time"),new k("Projectile","projectile",Ar,["Any"],!0).setTooltip("The type of projectile shot")],summaryItems:["target","interval","delay","projectile"]})}};c(Da,"new",()=>new Da);let Dn=Da;const Sa=class Sa extends ce{constructor(){super({name:"Right Click",description:"Applies skill effects upon performing a right-click (NOTE: When clicking in air, you have to have an item in your hand)",data:[new k("Crouch","crouch",["Crouch","Dont crouch","Both"],"Crouch").setTooltip("If the player has to be crouching in order for this trigger to function")],summaryItems:["crouch"]})}};c(Sa,"new",()=>new Sa);let Sn=Sa;const Aa=class Aa extends ce{constructor(){super({name:"Skill Cast",description:"Applies skill effects when a player casts a skill",data:[new _("Cancel Cast","cancel",!1).setTooltip("True cancels the skill cast. False allows the skill cast"),new Qe("Classes","allowed-classes").setTooltip("The list of classes which will trigger this effect. Leave blank to allow all to trigger. Use '!xxx' to exclude"),new Qe("Skills","allowed-skills").setTooltip("The list of skills which will trigger this effect. Leave blank to allow all to trigger. Use '!xxx' to exclude")],summaryItems:["cancel","allowed-classes","allowed-skills"]})}};c(Aa,"new",()=>new Aa);let An=Aa;const Va=class Va extends ce{constructor(){super({name:"Skill Damage",description:"Applies skill effects when a player deals damage with a skill",data:[new _("Target Caster","target",!0).setTooltip("True makes children target the caster. False makes children target the damaged entity"),new V("Min Damage","dmg-min",0).setTooltip("The minimum damage that needs to be dealt"),new V("Max Damage","dmg-max",999).setTooltip("The maximum damage that needs to be dealt"),new Qe("Category","category",["default"]).setTooltip("The type of skill damage to apply for. Leave this empty to apply to all skill damage")],summaryItems:["target","dmg-min","dmg-max","category"]})}};c(Va,"new",()=>new Va);let Vn=Va;const qa=class qa extends ce{constructor(){super({name:"Teleport",description:'Applies skill effects when a player gets teleported. Use the "api-distance" value to check/use the distance traveled. You may also use "api-from-x" "api-from-y" "api-from-z" "api-to-x" "api-to-y" and "api-to-z" to check the coordinates of the source and destination regarding the teleport.',data:[new k("Type","type",["Any","Ender Pearl","Command","Plugin","Nether Portal","End Portal","Spectate","End Gateway","Chorus Fruit","Dismount","Unknown"],"Any").setTooltip("The type of projectile that should be launched")],summaryItems:["type"]})}};c(qa,"new",()=>new qa);let qn=qa;const Ea=class Ea extends ce{constructor(){super({name:"Took Physical Damage",description:"Applies skill effects when a player takes physical (or non-skill) damage. This includes melee attacks and projectiles not fired by a skill",data:[new _("Target Caster","target",!0).setTooltip("True makes children target the caster. False makes children target the attacking entity"),new k("Type","type",["Both","Melee","Projectile"],"Both").setTooltip("The type of damage dealt"),new V("Min Damage","dmg-min",0).setTooltip("The minimum damage that needs to be dealt"),new V("Max Damage","dmg-max",999).setTooltip("The maximum damage that needs to be dealt")],summaryItems:["target","type","dmg-min","dmg-max"]})}};c(Ea,"new",()=>new Ea);let En=Ea;const Ca=class Ca extends ce{constructor(){super({name:"Took Skill Damage",description:"Applies skill effects when a player takes damage from a skill other than their own",data:[new _("Target Caster","target",!0).setTooltip("True makes children target the caster. False makes children target the attacking entity"),new V("Min Damage","dmg-min",0).setTooltip("The minimum damage that needs to be dealt"),new V("Max Damage","dmg-max",999).setTooltip("The maximum damage that needs to be dealt"),new Qe("Category","category",["default"]).setTooltip("The type of skill damage to apply for. Leave this empty to apply to all skill damage")],summaryItems:["target","dmg-min","dmg-max","category"]})}};c(Ca,"new",()=>new Ca);let Cn=Ca;const Pa=class Pa extends ce{constructor(){super({name:"Shield",description:"Applies skill effects when the player blocks damage with their shield. Use {api-blocked} to get amount of blocked damage.",data:[new _("Target Caster","target",!0).setTooltip("True makes children target the caster. False makes children target the attacking entity"),new k("Type","type",["Both","Melee","Projectile"],"Both").setTooltip("The type of damage dealt"),new V("Damage Heal","dmg-min",0).setTooltip("The minimum damage that needs to be blocked"),new V("Damage Heal","dmg-max",999).setTooltip("The maximum damage that needs to be blocked")],summaryItems:["target","type","dmg-min","dmg-max"]})}};c(Pa,"new",()=>new Pa);let Pn=Pa;const $a=class $a extends ce{constructor(){super({name:"Signal",description:"Applies skill effects when the player receive a signal emitted from Signal Emit mechanic.",data:[new _("Target Receiver","target",!0).setTooltip("True makes children target the receiver. False makes children target the emitter"),new B("Signal","signal").setTooltip("Name of signal want to receive.")],summaryItems:["target","signal"]})}};c($a,"new",()=>new $a);let $n=$a;const Fa=class Fa extends ce{constructor(){super({name:"World Change",description:"Applies skill effects when a player changes worlds",data:[new Qe("Worlds","worlds",["Any"]).setTooltip('The worlds to check for, "Any" will trigger regardless of world'),new _("Inverse","inverse",!1).setTooltip("Whether to trigger when NOT changing to the specified worlds"),new k("Direction","direction",["To","From","Both"],"To").setTooltip("The direction of the world change to be considered")],summaryItems:["worlds","inverse","direction"]})}};c(Fa,"new",()=>new Fa);let Fn=Fa;const Lt=()=>[new k("Group","group",["Ally","Enemy","Both"],"Enemy").setTooltip("The alignment of targets to get"),new _("Through Wall","wall",!1).setTooltip("Whether to allow targets to be on the other side of a wall"),new _("Include Invulnerable","invulnerable",!1).setTooltip("Whether to target on invulnerable entities"),new k("Include Caster","caster",["True","False","In area"],"False").setTooltip('Whether to include the caster in the target list. "True" will always include them, "False" will never, and "In area" will only if they are within the targeted area'),new b("Max Targets","max",99).setTooltip("The max amount of targets to apply children to")],et=()=>[new ue("Particles at target"),new _("Particles at target","per-target",!1).setTooltip("Displays particles at the location of the current targets"),...lt("per-target"),new k("Arrangement","per-target-arrangement",["Sphere","Circle","Hemisphere"],"Sphere").requireValue("per-target",[!0]).setTooltip("The arrangement to use for the particles. Circle is a 2D circle, Hemisphere is half a 3D sphere, and Sphere is a 3D sphere"),new k("Circle Direction","per-target-direction",["XY","XZ","YZ"],"XZ").requireValue("per-target-arrangement",["Circle"]).requireValue("per-target",[!0]).setTooltip("The orientation of the circle. XY and YZ are vertical circles while XZ is a horizontal circle"),new b("Radius","per-target-radius",.5).requireValue("per-target",[!0]).setTooltip("The radius of the arrangement in blocks"),new _("Increase size by hitbox","per-target-hitbox",!0).requireValue("per-target",[!0]).setTooltip("Increases the 'radius' parameter by the size of the target's hitbox"),new b("Points","per-target-particles",20).requireValue("per-target",[!0]).setTooltip("The amount of points that conform the chosen arrangement")],Oa=class Oa extends ut{constructor(){super({name:"Area",description:"Targets all units in a radius from the current target (the casting player is the default target)",data:[new b("Radius","radius",3).setTooltip("The radius of the area to target in blocks"),...Lt(),new _("Random","random",!1).setTooltip("Whether to randomize the targets selected")],preview:[...et(),new ue("Circle Preview"),new _("Circle Preview","circle",!1).setTooltip("Displays particles as a circle around the targeted area"),new V("Density","circle-density",1).setTooltip("The minimum amount of points to display per meter").requireValue("circle",[!0]),...lt("circle"),new ue("Sphere Preview"),new _("Sphere Preview","sphere",!1).setTooltip("Displays particles as a sphere around the targeted area"),new V("Density","sphere-density",1).setTooltip("The minimum amount of points to display per meter").requireValue("sphere",[!0]),...lt("sphere")],summaryItems:["radius","group","wall","caster","max","random"]})}};c(Oa,"new",()=>new Oa);let On=Oa;const Ra=class Ra extends ut{constructor(){super({name:"Cone",description:"Targets all units in a line in front of the current target (the casting player is the default target). If you include the caster, that counts towards the max amount",data:[new b("Range","range",5).setTooltip("The max distance away any target can be in blocks"),new b("Angle","angle",90).setTooltip("The angle of the cone arc in degrees"),new b("Rotation","rotation",0).setTooltip("The rotation of the cone in degrees"),new _("Reset Y","reset-y",!0).setTooltip("Whether to remove the Y component of the caster/target when determining targets"),...Lt()],preview:[...et(),new ue("Triangle Preview"),new _("Triangle Preview","triangle",!1).setTooltip("Displays particles as a two lines on both sides around the targeted area"),new V("Density","triangle-density",1).setTooltip("The minimum amount of points to display per meter").requireValue("triangle",[!0]),new V("Start distance","triangle-start-distance",2).setTooltip("How far from the target's face to start drawing the preview, in meters").requireValue("triangle",[!0]),...lt("triangle"),new ue("Cone Preview"),new _("Cone Preview","cone",!1).setTooltip("Displays particles as a cone around the targeted area"),new V("Density","cone-density",1).setTooltip("The minimum amount of points to display per meter").requireValue("cone",[!0]),new V("Start distance","cone-start-distance",2).setTooltip("How far from the target's face to start drawing the preview, in meters").requireValue("cone",[!0]),...lt("cone")],summaryItems:["range","angle","group","wall","caster","max"]})}};c(Ra,"new",()=>new Ra);let Rn=Ra;const Na=class Na extends ut{constructor(){super({name:"Linear",description:"Targets all units in a line in front of the current target (the casting player is the default target)",data:[new b("Range","range",5).setTooltip("The max distance away any target can be in blocks"),new b("Tolerance","tolerance").setTooltip("How much to expand the potential entity's hit-box in all directions, in blocks. This makes it easier to aim"),...Lt()],preview:[...et(),new ue("Line Preview"),new _("Line Preview","line",!1).setTooltip("Displays particles as a line of particles in front of the caster"),new V("Density","line-density",1).setTooltip("The minimum amount of points to display per meter").requireValue("line",[!0]),new V("Start distance","line-start-distance",2).setTooltip("How far from the target's face to start drawing the preview, in meters").requireValue("line",[!0]),...lt("line"),new ue("Cylinder Preview"),new _("Cylinder Preview","cylinder",!1).setTooltip("Displays particles as a cylinder of particles in front of the caster, showing the component's tolerance"),new V("Density","cylinder-density",1).setTooltip("The minimum amount of points to display per meter").requireValue("cylinder",[!0]),new V("Start distance","cylinder-start-distance",2).setTooltip("How far from the target's face to start drawing the preview, in meters").requireValue("cylinder",[!0]),...lt("cylinder")],summaryItems:["range","tolerance","group","wall","caster","max"]})}};c(Na,"new",()=>new Na);let Nn=Na;const La=class La extends ut{constructor(){super({name:"Location",description:"Targets the location the target or caster is looking at. Combine this with another targeting type for ranged area effects",data:[new b("Range","range",5).setTooltip("The max distance the location can be from the target's eyes"),new _("Entities","entities",!0).setTooltip("True to account for entities, or false to pass through them"),new _("Fluids","fluids",!1).setTooltip("True to account for fluids (water and lava), or false to pass through them"),new _("Passable blocks","passable",!0).setTooltip("True to account for passable or non-collidable blocks (grass, saplings, etc), or false to pass through them"),new _("Center","center",!1).setTooltip("Whether to move the hit location to the center of the block")],preview:[...et()],summaryItems:["range","entities","fluids","passable"]})}};c(La,"new",()=>new La);let Ln=La;const xa=class xa extends ut{constructor(){super({name:"Nearest",description:"Targets the closest unit(s) in a radius from the current target (the casting player is the default target). If you include the caster, that counts towards the max number",data:[new b("Range","range",3).setTooltip("The radius of the area to target in blocks"),...Lt()],preview:[...et(),new ue("Circle Preview"),new _("Circle Preview","circle",!1).setTooltip("Displays particles as a circle around the targeted area"),new V("Density","circle-density",1).setTooltip("The minimum amount of points to display per meter").requireValue("circle",[!0]),...lt("circle"),new ue("Sphere Preview"),new _("Sphere Preview","sphere",!1).setTooltip("Displays particles as a sphere around the targeted area"),new V("Density","sphere-density",1).setTooltip("The minimum amount of points to display per meter").requireValue("sphere",[!0]),...lt("sphere")],summaryItems:["range","group","wall","caster","max"]})}};c(xa,"new",()=>new xa);let xn=xa;const Ha=class Ha extends ut{constructor(){super({name:"Player",description:"Targets online players within the caster's world",data:[new k("Type","type",["Ally","Enemy","All"],"Ally").setTooltip("The offset from the target in the direction they are facing. Negative numbers go backwards")],preview:[...et()],summaryItems:["type"]})}};c(Ha,"new",()=>new Ha);let Hn=Ha;const Ba=class Ba extends ut{constructor(){super({name:"Offset",description:"Targets a location that is the given offset away from each target",data:[new ue("Offset"),new b("Forward","forward").setTooltip("The offset from the target in the direction they are facing. Negative numbers go backwards"),new b("Upward","upward",2,.5).setTooltip("The offset from the target upwards. Negative numbers go below them"),new b("Right","right").setTooltip("The offset from the target to their right. Negative numbers go to the left")],preview:[...et()],summaryItems:["forward","upward","right"]})}};c(Ba,"new",()=>new Ba);let Bn=Ba;const za=class za extends ut{constructor(){super({name:"Remember",description:'Targets entities stored using the "Remember Targets" mechanic for the matching key. If it was never set, this will fail',data:[new B("Key","key","target").setTooltip('The unique key for the target group that should match that used by the "Remember Targets" skill')],preview:[...et()],summaryItems:["key"]})}};c(za,"new",()=>new za);let zn=za;const Wa=class Wa extends ut{constructor(){super({name:"Self",description:"Returns the current target back to the caster"})}};c(Wa,"new",()=>new Wa);let Wn=Wa;const Ua=class Ua extends ut{constructor(){super({name:"Single",description:"Targets a single unit in front of the current target (the casting player is the default target)",data:[new b("Range","range",5).setTooltip("The max distance away any target can be in blocks"),new b("Tolerance","tolerance").setTooltip("How much to expand the potential entity's hitbox in all directions, in blocks. This makes it easier to aim"),new k("Group","group",["Ally","Enemy","Both"],"Enemy").setTooltip("The alignment of targets to get"),new _("Through Wall","wall",!1).setTooltip("Whether to allow targets to be on the other side of a wall")],preview:[...et(),new ue("Line Preview"),new _("Line Preview","line",!1).setTooltip("Displays particles as a line of particles in front of the caster"),new V("Density","line-density",1).setTooltip("The minimum amount of points to display per meter").requireValue("line",[!0]),new V("Start distance","line-start-distance",2).setTooltip("How far from the target's face to start drawing the preview, in meters").requireValue("line",[!0]),...lt("line"),new ue("Cylinder Preview"),new _("Cylinder Preview","cylinder",!1).setTooltip("Displays particles as a cylinder of particles in front of the caster, showing the component's tolerance"),new V("Density","cylinder-density",1).setTooltip("The minimum amount of points to display per meter").requireValue("cylinder",[!0]),new V("Start distance","cylinder-start-distance",2).setTooltip("How far from the target's face to start drawing the preview, in meters").requireValue("cylinder",[!0]),...lt("cylinder")],summaryItems:["range","tolerance","group","wall"]})}};c(Ua,"new",()=>new Ua);let Un=Ua;const ja=class ja extends ut{constructor(){super({name:"World",description:"Targets all entities in the caster's world",data:[...Lt()],summaryItems:["group","wall","caster","max"]})}};c(ja,"new",()=>new ja);let jn=ja;const kt=(s=new Nt(!1,"Arrow").requireValue("check-mat",[!0]).setTooltip("The type the item needs to be"))=>[new _("Check Material","check-mat",!0).setTooltip("Whether the item needs to be a certain type"),s,new k("Potion","potion",Zc,"Any").requireValue("material",["Potion","Lingering potion","Splash potion"]).setTooltip("The type of potion being consumed"),new _("Check Data","check-data",!1).setTooltip("Whether the item needs to have a certain data value"),new G("Data","data").requireValue("check-data",[!0]).setTooltip("The data value the item must have"),new _("Check Custom Data","check-custom-data",!1).setTooltip("Whether the item needs to have a certain custom model data value"),new G("Custom Data","custom-data").requireValue("check-custom-data",[!0]).setTooltip("The custom model data value the item must have"),new _("Check Lore","check-lore",!1).setTooltip("Whether the item requires a bit of text in its lore"),new B("Lore","lore","text").requireValue("check-lore",[!0]).setTooltip("The text the item requires in its lore"),new _("Check Name","check-name",!1).setTooltip("Whether the item needs to have a bit of text in its display name"),new B("Name","name","name").requireValue("check-name",[!0]).setTooltip("The text the item requires in its display name"),new _("Regex","regex",!1).setTooltip("Whether the name and lore checks are regex strings. If you do not know what regex is, leave this option alone")],Ga=class Ga extends ie{constructor(){super({name:"Altitude",description:"Applies child components whenever the player is on a certain height-level",data:[new b("Min","min").setTooltip("The minimum height a player has to be on"),new b("Max","max").setTooltip("The maximum height a player can be on")],summaryItems:["min","max"]})}};c(Ga,"new",()=>new Ga);let Gn=Ga;const Ya=class Ya extends ie{constructor(){super({name:"Armor",description:"Applies child components when the target is wearing an armor item matching the given details",data:[new k("Armor","armor",["Any","Helmet","Chestplate","Leggings","Boots"]).setTooltip("The type of armor to check"),...kt()],summaryItems:["armor","material","data","lore","name"]})}};c(Ya,"new",()=>new Ya);let Yn=Ya;const Xa=class Xa extends ie{constructor(){super({name:"Attribute",description:"Requires the target to have a given number of attributes",data:[new B("Attribute","attribute","Vitality").setTooltip("The name of the attribute you are checking the value of"),new b("Min","min").setTooltip("The minimum amount of the attribute the target requires"),new b("Max","max",999).setTooltip("The maximum amount of the attribute the target requires")],summaryItems:["attribute","min","max"]})}};c(Xa,"new",()=>new Xa);let Xn=Xa;const Ka=class Ka extends ie{constructor(){super({name:"Biome",description:"Applies child components when in a specified biome",data:[new k("Type","type",["In Biome","Not In Biome"],"In Biome").setTooltip("Whether the target should be in the biome. If checking for in the biome, they must be in any one of the checked biomes. If checking for the opposite, they must not be in any of the checked biomes"),new k("Biome","biome",Pp,["Forest"],!0).setTooltip("The biomes to check for. The expectation would be any of the selected biomes need to match")],summaryItems:["type","biome"]})}};c(Ka,"new",()=>new Ka);let Kn=Ka;const Za=class Za extends ie{constructor(){super({name:"Block",description:"Applies child components if the target is currently standing on a block of the given type",data:[new k("Type","standing",["On Block","Not On Block","In Block","Not In Block"]).setTooltip(`Specifies which block to check and whether it should match the selected material. "On Block" is directly below the player while "In Block" is the block a player's feet are in`),new Nt().setTooltip("The type of the block to require the targets to stand on")],summaryItems:["standing","material"]})}};c(Za,"new",()=>new Za);let Zn=Za;const Ma=class Ma extends ie{constructor(){super({name:"Burning",description:"Applies child components if the caster burns or not",data:[new k("Type","burn",["Burn","Dont burn"],"Burn").setTooltip("Specifies whether the player has to be burning for this skill to be performed")],summaryItems:["burn"]})}};c(Ma,"new",()=>new Ma);let Mn=Ma;const Ja=class Ja extends ie{constructor(){super({name:"Ceiling",description:"Checks the height of the ceiling above each target",data:[new b("Distance","distance",5).setTooltip("How high to check for the ceiling"),new _("At least","at-least",!0).setTooltip("When true, the ceiling must be at least the give number of blocks high. If false, the ceiling must be lower than the given number of blocks")],summaryItems:["distance","at-least"]})}};c(Ja,"new",()=>new Ja);let Jn=Ja;const Qa=class Qa extends ie{constructor(){super({name:"Chance",description:"Rolls a chance to apply child components",data:[new b("Chance","chance",25).setTooltip('The chance to execute children as a percentage. "25" would be 25%')],summaryItems:["chance"]})}};c(Qa,"new",()=>new Qa);let Qn=Qa;const es=class es extends ie{constructor(){super({name:"Class",description:'Applies child components when the target is the given class or optionally a profession of that class. For example, if you check for "Fighter" which professes into "Warrior", a "Warrior" will pass the check if you do not enable "exact"',data:[new Eu("Class","class",!1).setTooltip("The class the player should be"),new _("Exact","exact",!1).setTooltip("Whether the player must be exactly the given class. If false, they can be a later profession of the class")],summaryItems:["class","exact"]})}};c(es,"new",()=>new es);let ei=es;const ts=class ts extends ie{constructor(){super({name:"Class Level",description:"Applies child components when the level of the class with this skill is within the range. This only checks the level of the caster, not the targets",data:[new G("Min Level","min-level",2).setTooltip("The minimum class level the player should be. If the player has multiple classes, this will be of their main class"),new G("Max Level","max-level",99).setTooltip("The maximum class level the player should be. If the player has multiple classes, this will be of their main class")],summaryItems:["min-level","max-level"]})}};c(ts,"new",()=>new ts);let ti=ts;const as=class as extends ie{constructor(){super({name:"Combat",description:"Applies child components to targets that are in/out of combat, depending on the settings",data:[new _("In Combat","combat",!0).setTooltip("Whether the target should be in or out of combat"),new V("Seconds","seconds",10).setTooltip("The time in seconds since the last combat activity before something is considered not in combat")],summaryItems:["combat","seconds"]})}};c(as,"new",()=>new as);let ai=as;const ss=class ss extends ie{constructor(){super({name:"Crouch",description:"Applies child components if the target player(s) are crouching",data:[new _("Crouching","crouch",!0).setTooltip("Whether the player should be crouching")],summaryItems:["crouch"]})}};c(ss,"new",()=>new ss);let si=ss;const os=class os extends ie{constructor(){super({name:"Direction",description:"Applies child components when the target or caster is facing the correct direction relative to the other",data:[new k("Type","type",["Target","Caster"]).setTooltip("The entity to check the direction of"),new k("Direction","direction",["Away","Towards"]).setTooltip("The direction the chosen entity needs to be looking relative to the other")],summaryItems:["type","direction"]})}};c(os,"new",()=>new os);let oi=os;const rs=class rs extends ie{constructor(){super({name:"Distance",description:"Applies child components when the distance between the caster and the target matches the settings",data:[new b("Min Value","min-value").setTooltip("The minimum value for the distance required. This should be >= 0"),new b("Max Value","max-value",50).setTooltip("The maximum value for the distance required. This should be larger than the minimum value")],summaryItems:["min-value","max-value"]})}};c(rs,"new",()=>new rs);let ri=rs;const ns=class ns extends ie{constructor(){super({name:"Elevation",description:"Applies child components when the elevation of the target matches the settings",data:[new k("Type","type",["Normal","Difference"]).setTooltip("The type of comparison to make. Normal is just their Y-coordinate. Difference would be the difference between that the caster's Y-coordinate"),new b("Min Value","min-value").setTooltip('The minimum value for the elevation required. A positive minimum value with a "Difference" type would be for when the target is higher up than the caster'),new b("Max Value","max-value",255).setTooltip('The maximum value for the elevation required. A negative maximum value with a "Difference" type would be for when the target is below the caster')],summaryItems:["type","min-value","max-value"]})}};c(ns,"new",()=>new ns);let ni=ns;const is=class is extends ie{constructor(){super({name:"Else",description:"Applies child elements if the previous component failed to execute. This not only applies for conditions not passing, but mechanics failing due to no target or other cases"})}};c(is,"new",()=>new is);let ii=is;const ls=class ls extends ie{constructor(){super({name:"Entity Type",description:"Applies child elements if the target matches one of the selected entity types",data:[new k("Types","types",["Location",...qu()],[],!0).setTooltip("The entity types to target"),new _("Blacklist","blacklist",!1).setTooltip("Whether to consider the listed types as a blacklist, meaning only entities that do NOT match one of them will pass the condition.")],summaryItems:["types"]})}};c(ls,"new",()=>new ls);let li=ls;const us=class us extends ie{constructor(){super({name:"Fire",description:"Applies child components when the target is on fire",data:[new k("Type","type",["On Fire","Not On Fire"],"On Fire").setTooltip("Whether the target should be on fire")],summaryItems:["type"]})}};c(us,"new",()=>new us);let ui=us;const cs=class cs extends ie{constructor(){super({name:"Flag",description:"Applies child components when the target is marked by the appropriate flag",data:[new k("Type","type",["Set","Not Set"],"Set").setTooltip("Whether the flag should be set"),new B("Key","key","key").setTooltip("The unique key representing the flag. This should match the key for when you set it using the Flag mechanic or the Flat Toggle mechanic")],summaryItems:["type","key"]})}};c(cs,"new",()=>new cs);let ci=cs;const ps=class ps extends ie{constructor(){super({name:"Food",description:"Applies child components when the target's food level matches the settings",data:[new k("Type","type",["Food","Percent","Difference","Difference Percent"]).setTooltip("The type of measurement to use for the food. Food level is their flat food left. Percent is the percentage of food they have left. Difference is the difference between the target's flat food and the caster's. Difference percent is the difference between the target's percentage food left and the caster's"),new b("Min Value","min-value").setTooltip('The minimum food required. A positive minimum with one of the "Difference" types would be for when the target has more food'),new b("Max Value","max-value",10,2).setTooltip('The maximum food required. A negative maximum with one of the "Difference" types would be for when the target has less food')],summaryItems:["type","min-value","max-value"]})}};c(ps,"new",()=>new ps);let pi=ps;const hs=class hs extends ie{constructor(){super({name:"Ground",description:"Applies child components when the target is on the ground",data:[new k("Type","type",["On Ground","Not On Ground"]).setTooltip("Whether the target should be on the ground")],summaryItems:["type"]})}};c(hs,"new",()=>new hs);let hi=hs;const ds=class ds extends ie{constructor(){super({name:"Health",description:"Applies child components when the target's health matches the settings",data:[new k("Type","type",["Health","Percent","Difference","Difference Percent"]).setTooltip("The type of measurement to use for the health. Health is their flat health left. Percent is the percentage of health they have left. Difference is the difference between the target's flat health and the caster's. Difference percent is the difference between the target's percentage health left and the caster's"),new b("Min Value","min-value").setTooltip('The minimum health required. A positive minimum with one of the "Difference" types would be for when the target has more health'),new b("Max Value","max-value",10,2).setTooltip('The maximum health required. A negative maximum with one of the "Difference" types would be for when the target has less health')],summaryItems:["type","min-value","max-value"]})}};c(ds,"new",()=>new ds);let di=ds;const ms=class ms extends ie{constructor(){super({name:"Item",description:"Applies child components when the target is wielding an item matching the given material",data:[...kt()],summaryItems:["material","data","lore","name"]})}};c(ms,"new",()=>new ms);let mi=ms;const fs=class fs extends ie{constructor(){super({name:"Inventory",description:"Applies child components when the target player contains the given item in their inventory. This does not work on mobs",data:[new b("Amount","amount",1).setTooltip("The amount of the item needed in the player's inventory"),...kt()],summaryItems:["material","amount","data","lore","name"]})}};c(fs,"new",()=>new fs);let fi=fs;const gs=class gs extends ie{constructor(){super({name:"Light",description:"Applies child components when the light level at the target's location matches the settings",data:[new b("Min Light","min-light").setTooltip("The minimum light level needed. 16 is full brightness while 0 is complete darkness"),new b("Max Light","max-light",16,16).setTooltip("The maximum light level needed. 16 is full brightness while 0 is complete darkness")],summaryItems:["min-light","max-light"]})}};c(gs,"new",()=>new gs);let gi=gs;const ws=class ws extends ie{constructor(){super({name:"Mana",description:"Applies child components when the target's mana matches the settings",data:[new k("Type","type",["Mana","Percent","Difference","Difference Percent"],"Mana").setTooltip("The type of measurement to use for the mana. Mana is their flat mana left. Percent is the percentage of mana they have left. Difference is the difference between the target's flat mana and the caster's. Difference percent is the difference between the target's percentage mana left and the caster's"),new b("Min Value","min-value").setTooltip("The minimum amount of mana needed"),new b("Max Value","max-value",10,2).setTooltip("The maximum amount of mana needed")],summaryItems:["type","min-value","max-value"]})}};c(ws,"new",()=>new ws);let wi=ws;const ys=class ys extends ie{constructor(){super({name:"Money",description:"Applies child components when the target's balance matches the settings (requires Vault and an economy plugin). Always is false for non-player targets",data:[new k("Type","type",["Min","Max","Between"],"Min").setTooltip("The type of comparison to make"),new b("Min Value","min-value",10).requireValue("type",["Min","Between"]).setTooltip("The minimum balance the target must have, inclusive"),new b("Max Value","max-value",100).requireValue("type",["Max","Between"]).setTooltip("The maximum balance the target can have, inclusive")],summaryItems:["type","min-value","max-value"]})}};c(ys,"new",()=>new ys);let yi=ys;const Ts=class Ts extends ie{constructor(){super({name:"Mounted",description:"Applies child elements if the target is being mounted by one of the selected entity types",data:[new k("Types","types",Mc,["Any"],!0).setTooltip("The entity types that can be mounting the target")],summaryItems:["types"]})}};c(Ts,"new",()=>new Ts);let Ti=Ts;const vs=class vs extends ie{constructor(){super({name:"Mounting",description:"Applies child elements if the target is mounting one of the selected entity types",data:[new k("Types","types",Mc,["Any"],!0).setTooltip("The entity types the target can be mounting")],summaryItems:["types"]})}};c(vs,"new",()=>new vs);let vi=vs;const bs=class bs extends ie{constructor(){super({name:"MythicMob Type",description:"Applies child elements if the target corresponds to one of the entered MythicMob types, or is not a MythicMob if left empty",data:[new Qe("MythicMob Types","types").setTooltip("The MythicMob types to target")],summaryItems:["types"]})}};c(bs,"new",()=>new bs);let bi=bs;const ks=class ks extends ie{constructor(){super({name:"Name",description:"Applies child components when the target has a name matching the settings",data:[new _("Contains Text","contains",!0).setTooltip("Whether the target should have a name containing the text"),new _("Regex","regex",!1).setTooltip("Whether the text is formatted as regex. If you do not know what regex is, ignore this option"),new B("Text","text","text").setTooltip("The text to look for in the target's name")],summaryItems:["contains","text"]})}};c(ks,"new",()=>new ks);let ki=ks;const _s=class _s extends ie{constructor(){super({name:"Offhand",description:"Applies child components when the target is wielding an item matching the given material as an offhand item. This is for v1.9+ servers only",data:[...kt()],summaryItems:["material","data","lore","name"]})}};c(_s,"new",()=>new _s);let _i=_s;const Is=class Is extends ie{constructor(){super({name:"Permission",description:"Applies child components if the caster has the required permission",data:[new B("Permission","perm","some.permission").setTooltip("The permission the player needs to have")],summaryItems:["perm"]})}};c(Is,"new",()=>new Is);let Ii=Is;const Ds=class Ds extends ie{constructor(){super({name:"Potion",description:"Applies child components when the target has the potion effect",data:[new k("Type","type",["Active","Not Active"],"Active").setTooltip("Whether the potion should be active"),new k("Potion","potion",Zc,"Any").setTooltip("The type of potion to look for"),new b("Min Rank","min-rank").setTooltip("The minimum rank the potion effect can be"),new b("Max Rank","max-rank",999).setTooltip("The maximum rank the potion effect can be")],summaryItems:["type","potion","min-rank","max-rank"]})}};c(Ds,"new",()=>new Ds);let Di=Ds;const Ss=class Ss extends ie{constructor(){super({name:"Skill Level",description:"Applies child components when the skill level is with the range. This checks the skill level of the caster, not the targets",data:[new qr("Skill","skill",!1).setTooltip("The name of the skill to check the level of. If you want to check the current skill, enter the current skill's name anyway"),new G("Min Level","min-level",2).setTooltip("The minimum level of the skill needed"),new G("Max Level","max-level",99).setTooltip("The maximum level of the skill needed")],summaryItems:["skill","min-level","max-level"]})}};c(Ss,"new",()=>new Ss);let Si=Ss;const As=class As extends ie{constructor(){super({name:"Slot",description:"Applies child components when the target player has a matching item in the given slot",data:[new Qe("Slots (one per line)","slot",["9"]).setTooltip("The slots to look at. Slots 0-8 are the hot bar, 9-35 are the main inventory, 36-39 are armor, and 40 is the offhand slot. Multiple slots will check if any of the slots match"),...kt()],summaryItems:["slot","material","data","lore","name"]})}};c(As,"new",()=>new As);let Ai=As;const Vs=class Vs extends ie{constructor(){super({name:"Status",description:"Applies child components when the target has the status condition",data:[new k("Type","type",["Active","Not Active"]).setTooltip("Whether the status should be active"),new k("Status","status",["Any","Absorb","Curse","Disarm","Invincible","Invulnerable","Root","Silence","Stun","Bypass Negative"]).setTooltip("The status to look for")],summaryItems:["type","status"]})}};c(Vs,"new",()=>new Vs);let Vi=Vs;const qs=class qs extends ie{constructor(){super({name:"Time",description:"Applies child components when the server time matches the settings",data:[new k("Time","time",["Day","Night"],"Day").setTooltip("The time to check for in the current world")],summaryItems:["time"]})}};c(qs,"new",()=>new qs);let qi=qs;const Es=class Es extends ie{constructor(){super({name:"Tool",description:"Applies child components when the target is wielding a matching tool",data:[new k("Material","material",["Any","Wood","Stone","Iron","Gold","Diamond","Netherite"]).setTooltip("The material the held tool needs to be made out of"),new k("Tool","tool",["Any","Axe","Hoe","Pickaxe","Shovel","Sword"]).setTooltip("The type of tool it needs to be")],summaryItems:["material","tool"]})}};c(Es,"new",()=>new Es);let Ei=Es;const Cs=class Cs extends ie{constructor(){super({name:"Value",description:"Applies child components if a stored value is within the given range",data:[new B("Key","key","value").setTooltip("The unique string used for the value set by the Value mechanics"),new b("Min Value","min-value",1).setTooltip("The lower bound of the required value"),new b("Max Value","max-value",999).setTooltip("The upper bound of the required value")],summaryItems:["key","min-value","max-value"]})}};c(Cs,"new",()=>new Cs);let Ci=Cs;const Ps=class Ps extends ie{constructor(){super({name:"Value Text",description:"Applies child components if text value match to the settings",data:[new k("Mode","mode",["REGEX","EXACTLY","CONTAIN","START","END"],"EXACTLY").setTooltip("The comparison mode should be conditioned."),new B("Key","value","").setTooltip("Key of the value to be compared."),new B("Expect","expect","").setTooltip("Strings used for comparison.")]})}};c(Ps,"new",()=>new Ps);let Pi=Ps;const $s=class $s extends ie{constructor(){super({name:"Water",description:"Applies child components when the target is in or out of water, depending on the settings",data:[new k("State","state",["In Water","Out Of Water"]).setTooltip("Whether the target needs to be in the water")],summaryItems:["state"]})}};c($s,"new",()=>new $s);let $i=$s;const Fs=class Fs extends ie{constructor(){super({name:"Weather",description:"Applies child components when the target's location has the given weather condition",data:[new k("Type","type",["Rain","None","Snow","Thunder"]).setTooltip("Whether the target needs to be in the water")],summaryItems:["type"]})}};c(Fs,"new",()=>new Fs);let Fi=Fs;const Os=class Os extends ie{constructor(){super({name:"World",description:"Applies child components when the target is in a specific world",data:[new _("Blacklist","blacklist",!1).setTooltip("Whether the list should be seen as a blacklist"),new Qe("Worlds","worlds").setTooltip("Which worlds should be taken into consideration")],summaryItems:["blacklist","worlds"]})}};c(Os,"new",()=>new Os);let Oi=Os;const Rs=class Rs extends ie{constructor(){super({name:"Yaw",description:"Applies child components when the target is facing the correct direction. This is on a scale of 0-360 degrees. 0 is south, 90 is west, 180 is north, and 270 is east",data:[new V("Min Yaw","min-yaw",0).setTooltip("The minimum yaw the target should be facing"),new V("Max Yaw","max-yaw",60).setTooltip("The maximum yaw the target should be facing")],summaryItems:["min-yaw","max-yaw"]})}};c(Rs,"new",()=>new Rs);let Ri=Rs;const Er=()=>[new ue("Item Options"),new Nt(!1,"Arrow").setTooltip("The type of item to give to the player"),new G("Amount","amount",1).setTooltip("The quantity of the item to give to the player"),new G("Durability","data").requireValue("material",Lu()).setTooltip("The durability to reduce from the item"),new _("Unbreakable","unbreakable",!1).requireValue("material",Lu()).setTooltip("Whether to make the item unbreakable"),new G("CustomModelData","byte",0).setTooltip("The CustomModelData of the item"),new k("Hide Flags","hide-flags",["Enchants","Attributes","Unbreakable","Destroys","Placed on","Potion effects","Dye"],[],!0).setTooltip("Flags to hide from the item"),new _("Custom Name/Lore","custom",!1).setTooltip("Whether to apply a custom name/lore to the item"),new B("Name","name","Name").requireValue("custom",[!0]).setTooltip("The name of the item"),new Qe("Lore","lore").requireValue("custom",[!0]).setTooltip("The lore text for the item (the text below the name)"),new we("Potion Color","potion_color","#385dc6").requireValue("material",["Potion","Splash potion","Lingering potion"]).setTooltip("The potion color in hex RGB"),new k("Potion Type","potion_type",Jc,"Speed").requireValue("material",["Potion","Splash potion","Lingering potion"]).setTooltip("The type of potion"),new G("Potion Level","potion_level").requireValue("material",["Potion","Splash potion","Lingering potion"]).setTooltip("The potion level"),new G("Potion Duration","potion_duration",30).requireValue("material",["Potion","Splash potion","Lingering potion"]).setTooltip("The potion duration (seconds)"),new we("Armor Color","armor_color","#a06540").requireValue("material",["Leather helmet","Leather chestplate","Leather leggings","Leather boots"]).setTooltip("The armor color in hex RGB"),new Cu().setTooltip("The enchantment to apply to the item")],$t=()=>[new _("Preserve Velocity","preserve").setTooltip("Whether to preserve the target's velocity post-warp"),new _("Set Yaw","setYaw",!1).setTooltip("Whether to set the target's yaw on teleport"),new _("Relative","relative-yaw",!1).requireValue("setYaw",[!0]).setTooltip("Whether to set the yaw relative to the target's current yaw"),new b("Yaw","yaw",0).requireValue("setYaw",[!0]).setTooltip("The Yaw of the desired position (left/right orientation)"),new _("Set Pitch","setPitch",!1).setTooltip("Whether to set the target's pitch on teleport"),new _("Relative","relative-pitch",!1).requireValue("setPitch",[!0]).setTooltip("Whether to set the pitch relative to the target's current pitch"),new b("Pitch","pitch",0).requireValue("setPitch",[!0]).setTooltip("The Pitch of the desired position (up/down orientation)")],xt=()=>[new ue("Particle Options"),new k("Particle","particle",Je,Je()[0]).setTooltip("The type of particle to display"),new k("Material","material",()=>[...Me()],"Arrow").requireValue("particle",["Item crack","Item"]).setTooltip("The material to use for the particles"),new k("Material","material",()=>[...Ge()],"Dirt").requireValue("particle",["Block crack","Block dust","Block","Falling dust","Block marker"]).setTooltip("The block to use for the particles"),new G("Durability","durability",0).requireValue("particle",["Item crack","Item"]).setTooltip("The durability to be reduced from the item used to make the particles"),new G("CustomModelData","type",0).requireValue("particle",["Item crack","item"]).setTooltip("The CustomModelData of the item used to make the particles"),new we("Dust Color","dust-color","#FF0000").requireValue("particle",["Redstone","Dust","Dust color transition"]).setTooltip("The color of the dust particles in hex RGB"),new we("Final Dust Color","final-dust-color","#FF0000").requireValue("particle",["Dust color transition"]).setTooltip("The color to transition to, in hex RGB"),new V("Dust Size","dust-size",1).requireValue("particle",["Redstone","Dust","Dust color transition"]).setTooltip("The size of the dust particles"),new k("Arrangement","arrangement",["Sphere","Circle","Hemisphere"],"Sphere").setTooltip("The arrangement to use for the particles. Circle is a 2D circle, Hemisphere is half a 3D sphere, and Sphere is a 3D sphere"),new k("Circle Direction","direction",["XY","XZ","YZ"],"XZ").requireValue("arrangement",["Circle"]).setTooltip("The orientation of the circle. XY and YZ are vertical circles while XZ is a horizontal circle"),new b("Radius","radius",1).setTooltip("The radius of the arrangement in blocks"),new b("Points","particles",20).setTooltip("The amount of points that conform the chosen arrangement"),new G("Effect Data","data").requireValue("particle",["Smoke","Ender Signal","Mobspawner Flames","Potion Break","Sculk charge"]).setTooltip("The data value to use for the particle. The effect changes between particles such as the orientation for smoke particles or the color for potion break"),new G("Visible Radius","visible-radius",25).setTooltip("How far away players can see the particles from in blocks"),new V("DX","dx").setTooltip("Offset in the X direction, used as the Red value for some particles"),new V("DY","dy").setTooltip("Offset in the Y direction, used as the Green value for some particles"),new V("DZ","dz").setTooltip("Offset in the Z direction, used as the Blue value for some particles"),new V("Amount","amount",1).setTooltip('Number of particles to play per point. For "Spell mob" and "Spell mob ambient" particles, set to 0 to control the particle color'),new V("Speed","speed",.1).setTooltip("Speed of the particle. For some particles controls other parameters, such as size")],Cr=()=>[new ue("Projectile Options"),new b("Velocity","velocity",3).setTooltip("How fast the projectile is launched, in meters per second. A negative value fires it in the opposite direction."),new b("Lifespan","lifespan",5).setTooltip("How long in secods before the projectile will expire in case it doesn't hit anything."),new _("On Expire","on-expire",!1).setTooltip("Whether to add the projectile's expire location as one of the targets. You can filter out this target with EntityTypeContidion: Location"),new k("Spread","spread",["Cone","Horizontal Cone","Rain"],"Cone").setTooltip('The orientation for firing projectiles. Cone will fire arrows in a cone centered on your reticle. Horizontal cone does the same as cone, just locked to the XZ axis (parallel to the ground). Rain drops the projectiles from above the target. For firing one arrow straight, use "Cone"'),new b("Amount","amount",1).setTooltip("The number of projectiles to fire"),new _("Target Blocks","target-blocks",!1).setTooltip("Whether to execute children if the projectile hits a block"),new b("Angle","angle",30).requireValue("spread",["Cone","Horizontal Cone"]).setTooltip("The angle in degrees of the cone arc to spread projectiles over. If you are only firing one projectile, this does not matter."),new b("Height","height",8).requireValue("spread",["Rain"]).setTooltip("The distance in blocks over the target to rain the projectiles from"),new b("Radius","rain-radius",2).requireValue("spread",["Rain"]).setTooltip("The radius of the rain emission area in blocks"),new ue("Offset"),new b("Forward Offset","forward").setTooltip("How far forward in front of the target the projectile should fire from in blocks. A negative value will put it behind."),new b("Upward Offset","upward").setTooltip("How far above the target the projectile should fire from in blocks. A negative value will put it below."),new b("Right Offset","right").setTooltip("How far to the right of the target the projectile should fire from. A negative value will put it to the left.")],Pr=()=>[new ue("Homing"),new _("Homing","homing",!1).setTooltip("Whether to make this a homing projectile"),new k("Target","target",["Nearest","Remember Target"],"Nearest").setTooltip('What target to home into. "Nearest" will track the nearest valid target each tick. "Remember Target" tracks a target saved through a Remember Targets Mechanic.').requireValue("homing",[!0]),new b("Homing distance","homing-distance",10).setTooltip("Maximum distance at which the projectile can target an entity, in meters.").requireValue("homing",[!0]).requireValue("target",["Nearest"]),new B("Remember key","remember-key","target").requireValue("homing",[!0]).requireValue("target",["Remember Target"]),new b("Correction","correction",.5).setTooltip("Maximum corrective acceleration of the projectile, in meters per squared tick. Higher values mean the projectile can make more tight turns.").requireValue("homing",[!0]),new _("Through Wall","wall",!1).setTooltip("Whether to allow targets to be on the other side of a wall").requireValue("homing",[!0])],Qh=s=>(s.requireValue("use-effect",[!0]),s),ed=s=>s,Ht=s=>{let e=ed;return s&&(e=Qh),[new ue("Particle Effect Options"),new _("Use Effect","use-effect").setTooltip("Whether to use a particle effect."),e(new B("Effect Key","effect-key","default").setTooltip("The key to refer to the effect by. Only one effect of each key can be active at a time.")),e(new b("Duration","duration",1).setTooltip("The time to play the effect for in seconds")),e(new B("Shape","-shape","hexagon").setTooltip('Key of a formula for deciding where particles are played each iteration. View "effects.yml" for a list of defined formulas and their keys.')),e(new k("Shape Direction","-shape-dir",["XY","YZ","XZ"],"XY").setTooltip("The plane the shape formula applies to. XZ would be flat, the other two are vertical.")),e(new B("Shape Size","-shape-size","1").setTooltip("Formula for deciding the size of the shape. This can be any sort of formula using the operations defined in the wiki.")),e(new B("Animation","-animation","one-circle").setTooltip('Key of a formula for deciding where the particle effect moves relative to the target. View "effects.yml" for a list of defined formulas and their keys.')),e(new k("Animation Direction","-anim-dir",["XY","YZ","XZ"],"XZ").setTooltip("The plane the animation motion moves through. XZ would be flat, the other two are vertical.")),e(new B("Animation Size","-anim-size","1").setTooltip("Formula for deciding the multiplier of the animation distance. This can be any sort of formula using the operations defined in the wiki.")),e(new G("Interval","-interval",1).setTooltip("Number of ticks between playing particles.")),e(new G("View Range","-view-range",25).setTooltip("How far away the effect can be seen from.")),e(new k("Particle","-particle-type",Je,Je()[0]).setTooltip("The type of particle to use.")),e(new k("Material","-particle-material",Me,"Dirt").requireValue("-particle-type",["Item crack","Item"]).setTooltip("The material to use for the particle.")),e(new k("Material","-particle-material",Ge,"Dirt").requireValue("-particle-type",["Block crack","Block dust","Block","Falling dust","Block marker"]).setTooltip("The block to use for the particle.")),e(new G("Durability","-particle-durability").requireValue("particle",["Item crack","Item"]).setTooltip("The durability to be reduced from the item used to make the particles")),e(new G("CustomModelData","-particle-data").requireValue("-particle-type",["Item crack","Item"]).setTooltip("The data value for the material used by the particle. For 1.14+ determines the CustomModelData of the item.")),new we("Dust Color","-particle-dust-color","#FF0000").requireValue("-particle-type",["Redstone","Dust","Dust color transition"]).setTooltip("The color of the dust particles in hex RGB"),new we("Final Dust Color","-particle-final-dust-color","#FF0000").requireValue("-particle-type",["Dust color transition"]).setTooltip("The color to transition to, in hex RGB"),new V("Dust Size","-particle-dust-size",1).requireValue("-particle-type",["Redstone","Dust","Dust color transition"]).setTooltip("The size of the dust particles"),e(new G("Amount","-particle-amount",1).setTooltip('Number of particles to play per point. For "Spell mob" and "Spell mob ambient" particles, set to 0 to control the particle color.')),e(new V("DX","-particle-dx").setTooltip("Offset in the X direction, used as the Red value for some particles.")),e(new V("DY","-particle-dy").setTooltip("Offset in the Y direction, used as the Green value for some particles.")),e(new V("DZ","-particle-dz").setTooltip("Offset in the Z direction, used as the Blue value for some particles.")),e(new V("Speed","-particle-speed",.1).setTooltip("Speed of the particle. For some particles controls other parameters, such as size.")),e(new V("Initial Rotation","-initial-rotation").setTooltip("The amount to rotate the effect (useful for effects like the square).")),e(new _("Rotate w/ Player","-with-rotation",!0).setTooltip("Whether to follow the rotation of the player for the effect."))]},Ns=class Ns extends L{constructor(){super({name:"Abort Skill",description:"Cancels current skill mechanics",data:[],summaryItems:[]},!1)}};c(Ns,"new",()=>new Ns);let Ni=Ns;const Ls=class Ls extends L{constructor(){super({name:"Armor",description:"Sets the specified armor slot of the target to the item defined by the settings",data:[new k("Slot","slot",["Hand","Off Hand","Feet","Legs","Chest","Head"]).setTooltip("The slot number to set the item to"),new _("Overwrite","overwrite",!1).setTooltip("USE WITH CAUTION. Whether to overwrite an existing item in the slot. If true, will permanently delete the existing iem"),...Er()],summaryItems:["slot","material","data","lore","name"]})}};c(Ls,"new",()=>new Ls);let Li=Ls;const xs=class xs extends L{constructor(){super({name:"Armor Stand",description:"Summons an armor stand that can be used as a marker or for item display (check Armor Mechanic for latter). Applies child components on the armor stand",data:[new B("Armor Stand Key","key","default").setTooltip("The key to refer to the armor stand by. Only one armor stand of each key can be active per target at a time"),new b("Duration","duration",5).setTooltip("How long the armor stand lasts before being deleted"),new B("Name","name","Armor Stand").setTooltip("The name the armor stand displays"),new _("Name visible","name-visible",!1).setTooltip("Whether the armor stand's name should be visible from afar"),new _("Follow target","follow",!1).setTooltip("Whether the armor stand should follow the target"),new _("Marker","marker",!1).setTooltip("Setting this to true will remove the armor stand's hit-box but will also disable gravity"),new _("Apply gravity","gravity",!0).setTooltip("Whether the armor stand should be affected by gravity").requireValue("marker",[!1]),new _("Small","tiny",!1).setTooltip("Whether the armor stand should be small"),new _("Show arms","arms",!1).setTooltip("Whether the armor stand should display its arms"),new _("Show base plate","base",!1).setTooltip("Whether the armor stand should display its base plate"),new _("Visible","visible",!0).setTooltip("Whether the armor stand should be visible"),new ue("Offset"),new b("Forward Offset","forward").setTooltip("How far forward in front of the target the armor stand should be in blocks. A negative value will put it behind"),new b("Upward Offset","upward").setTooltip("How far above the target the armor stand should be in blocks. A negative value will put it below"),new b("Right Offset","right").setTooltip("How far to the right the armor stand should be of the target. A negative value will put it to the left")],summaryItems:["duration","name","follow","gravity","visible"]},!0)}};c(xs,"new",()=>new xs);let xi=xs;const Hs=class Hs extends L{constructor(){super({name:"Armor Stand Pose",description:"Sets the pose of an armor stand target. Values should be in the format x,y,z where rotations are in degrees. Example: 0.0,0.0,0.0",data:[new B("Head","head","").setTooltip("The pose values of the head. Leave empty if should be ignored"),new B("Body","body","").setTooltip("The pose values of the body. Leave empty if should be ignored"),new B("Left Arm","left-arm","").setTooltip("The pose values of the left arm. Leave empty if should be ignored"),new B("Right Arm","right-arm","").setTooltip("The pose values of the right arm. Leave empty if should be ignored"),new B("Left Leg","left-leg","").setTooltip("The pose values of the left leg. Leave empty if should be ignored"),new B("Right Leg","right-leg","").setTooltip("The pose values of the right leg. Leave empty if should be ignored")]})}};c(Hs,"new",()=>new Hs);let Hi=Hs;const Bs=class Bs extends L{constructor(){super({name:"Armor Stand Remove",description:"Removes an armor stand with the given key",data:[new B("Armor Stand Key","key","default").setTooltip("The key to refer to the armor stand by. Only one armor stand of each key can be active per target at a time")],summaryItems:["key"]})}};c(Bs,"new",()=>new Bs);let Bi=Bs;const zs=class zs extends L{constructor(){super({name:"Attribute",description:"Gives a player bonus attributes temporarily",data:[new k("Attribute","key",()=>Tt.getAttributeNames(),["Intelligence"],!0).setTooltip("The attribute to add to"),new k("Operation","operation",["ADD_NUMBER","MULTIPLY_PERCENTAGE"],"ADD_NUMBER").setTooltip("The operation on the original value by amount, ADD_NUMBER: Scalar adding, MULTIPLY_PERCENTAGE: Multiply the value by amount"),new b("Amount","amount",5,2).setTooltip("The amount to use with the operation"),new b("Seconds","seconds",3).setTooltip("How long in seconds to give the attributes to the player"),new _("Stackable","stackable",!1).setTooltip("Whether applying multiple times stacks the effects")],summaryItems:["key","operation","amount","seconds"]})}};c(zs,"new",()=>new zs);let zi=zs;const Ws=class Ws extends L{constructor(){super({name:"Block",description:"Changes blocks to the given type of block for a limited duration",data:[new k("Shape","shape",["Sphere","Cuboid"],"Sphere").setTooltip("The shape of the region to change the blocks for"),new k("Type","type",()=>["Air","Any","Solid",...Ge()],"Solid").setTooltip("The type of blocks to replace. Air or any would be for making obstacles while solid would change the environment"),new k("Block","block",Ge,"Ice").setTooltip("The type of block to turn the region into"),new _("Randomize","randomize",!1).setTooltip("Whether the set block should be randomized with the defined list of blocks"),new k("Blocks","blocks",Ge,[]).setTooltip("The list of blocks to randomly choose from when randomizing").requireValue("randomize",[!0]),new _("Reset Yaw","reset-yaw",!1).setTooltip("Whether the target's yaw should be reset, effectively making the offsets cardinally aligned"),new b("Seconds","seconds",5).setTooltip("How long the blocks should be replaced for"),new _("Fill","fill",!1).setTooltip("Whether the inside of the region should be filled with the blocks, if set to False, the center will be hollow"),new k("Block damage type","block_damage_type",["Static","Random"],"Static").setTooltip("How the block damage should be determined"),new b("Block damage","block_damage",0,0).setTooltip("The static amount of damage to deal to the block, from 0 to 1").requireValue("block_damage_type",["Static"]),new b("Radius","radius",3).requireValue("shape",["Sphere"]).setTooltip("The radius of the sphere region in blocks"),new b("Width (X)","width",5).requireValue("shape",["Cuboid"]).setTooltip("The width of the cuboid in blocks"),new b("Height (Y)","height",5).requireValue("shape",["Cuboid"]).setTooltip("The height of the cuboid in blocks"),new b("Depth (Z)","depth",5).requireValue("shape",["Cuboid"]).setTooltip("The depth of the cuboid in blocks"),new ue("Offset"),new b("Forward Offset","forward").setTooltip("How far forward in front of the target the region should be in blocks. A negative value will put it behind"),new b("Upward Offset","upward").setTooltip("How far above the target the region should be in blocks. A negative value will put it below"),new b("Right Offset","right").setTooltip("How far to the right the region should be of the target. A negative value will put it to the left")],preview:[...et(),new _("Center only","per-target-center-only",!0).setTooltip("Whether to display particles only at the center of the affected area, or at each affected block").requireValue("per-target",[!0])],summaryItems:["shape","type","block","seconds"]})}};c(Ws,"new",()=>new Ws);let Wi=Ws;const Us=class Us extends L{constructor(){super({name:"Buff",description:"Buffs combat stats of the target",data:[new _("Immediate","immediate",!1).setTooltip("Whether to apply the buff to the current damage trigger"),new k("Type","type",["DAMAGE","DEFENSE","SKILL_DAMAGE","SKILL_DEFENSE","HEALING"],"DAMAGE").requireValue("immediate",[!1]).setTooltip("What type of buff to apply. DAMAGE/DEFENSE is for regular attacks, SKILL_DAMAGE/SKILL_DEFENSE are for damage from abilities, and HEALING is for healing from abilities"),new k("Modifier","modifier",["Flat","Multiplier"],"Flat").setTooltip("The sort of scaling for the buff. Flat will increase/reduce incoming damage by a fixed amount where Multiplier does it by a percentage of the damage. Multipliers above 1 will increase damage taken while multipliers below 1 reduce damage taken"),new B("Category","category","").requireValue("type",["SKILL_DAMAGE","SKILL_DEFENSE"]).setTooltip("What kind of skill damage to affect. If left empty, this will affect all skill damage"),new b("Value","value",1).setTooltip("The amount to increase/decrease incoming damage by"),new b("Seconds","seconds",3).requireValue("immediate",[!1]).setTooltip("The duration of the buff in seconds")],summaryItems:["type","modifier","value","seconds"]})}};c(Us,"new",()=>new Us);let Ui=Us;const js=class js extends L{constructor(){super({name:"Cancel",description:"Cancels the event that caused the trigger this is under to go off. For example, damage based triggers will stop the damage that was dealt while the Launch trigger would stop the projectile from firing"})}};c(js,"new",()=>new js);let ji=js;const Gs=class Gs extends L{constructor(){super({name:"Cancel Effect",description:"Stops a particle effect prematurely",data:[new B("Effect Key","effect-key","default").setTooltip("The key used when setting up the effect")],summaryItems:["effect-key"]},!1)}};c(Gs,"new",()=>new Gs);let Gi=Gs;const Ys=class Ys extends L{constructor(){super({name:"Channel",description:"Applies child effects after a duration which can be interrupted. During the channel, the player cannot move, attack, or use other spells",data:[new _("Still","still",!0).setTooltip("Whether to hold the player in place while channeling"),new b("Time","time",3).setTooltip("The amouont of time, in seconds, to channel for")],summaryItems:["still","time"]},!0)}};c(Ys,"new",()=>new Ys);let Yi=Ys;const Xs=class Xs extends L{constructor(){super({name:"Cleanse",description:"Cleanses negative potion or status effects from the targets",data:[new k("Potion","potion",$p,void 0,!0).setTooltip("The type of potion effect to remove from the target"),new k("Status","status",["All","Curse","Disarm","Root","Silence","Stun"],void 0,!0).setTooltip("The status to remove from the target"),new _("Extinguish Target","extinguish",!0).setTooltip("Whether to extinguish the player if they are on fire"),new _("Reset Negative Stats","reset-negative-stats",!0).setTooltip("Whether to reset the negative stats of the target, mainly below default speed")],summaryItems:["potion","status"]},!1)}};c(Xs,"new",()=>new Xs);let Xi=Xs;const Ks=class Ks extends L{constructor(){super({name:"Command",description:"Executes a command for each of the targets",data:[new B("Command","command","").setTooltip(`The command to execute. {player} = caster's name, {target} = target's name, {targetUUID} = target's UUID (useful if targets are non players), &lc: "{", &rc: "}", &sq: "'"`),new k("Execute Type","type",["Console","OP"],"OP").setTooltip("Console: executes the command from the console. OP: Only if the target is a player, will have them execute it while given a temporary OP permission (If server closes in the meantime, the permission might stay, not recommended!!)")],summaryItems:["command","type"]},!1)}};c(Ks,"new",()=>new Ks);let Ki=Ks;const Zs=class Zs extends L{constructor(){super({name:"Cooldown",description:"Lowers the cooldowns of the target's skill(s). If you provide a negative amount, it will increase the cooldown",data:[new B('Skill (or "all")',"skill","all").setTooltip("The skill to modify the cooldown for"),new k("Type","type",["Seconds","Percent"],"Seconds").setTooltip("The modification unit to use. Seconds will add/subtract seconds from the cooldown while Percent will add/subtract a percentage of its full cooldown"),new b("Value","value",-1).setTooltip("The amount to add/subtract from the skill's cooldown")],summaryItems:["skill","type","value"]},!1)}};c(Zs,"new",()=>new Zs);let Zi=Zs;const Ms=class Ms extends L{constructor(){super({name:"Damage",description:"Inflicts skill damage to each target. Multiplier type would be a percentage of the target health",data:[new k("Type","type",["Damage","Multiplier","Percent Left","Percent Missing"],"Damage").setTooltip("The unit to use for the amount of damage. Damage will deal flat damage, Multiplier will deal a percentage of the target's max health, Percent Left will deal a percentage of their current health, and Percent Missing will deal a percentage of the difference between their max health and current health"),new b("Value","value",3,1).setTooltip("The amount of damage to deal"),new _("True Damage","true").setTooltip("Whether to deal true damage. True damage ignores armor and all plugin checks, and doesn not have a damage animation nor knockback"),new B("Damage Type","classifier","default").setTooltip('The type of damage to deal. Can act as elemental damage or fake physical damage. Supports Damage types from ProRPGItems like "PRORPGITEMS_magical"'),new _("Apply Knockback","knockback",!0).setTooltip("Whether the damage will inflict knockback. Ignored if it is True Damage"),new k("Damage Cause","cause",["Contact","Custom","Entity Attack","Entity Sweep Attack","Projectile","Suffocation","Fall","Fire","Fire Tick","Melting","Lava","Drowning","Block Explosion","Entity Explosion","Void","Lightning","Suicide","Starvation","Poison","Magic","Wither","Falling Block","Thorns","Dragon Breath","Fly Into Wall","Hot Floor","Cramming","Dryout","Freeze","Sonic Boom"],"Custom").setTooltip("Damage Cause considered by the server. This will have influence over the death message and ProRPGItems' defenses").requireValue("true",[!1])],summaryItems:["value","true","knockback"]},!1)}};c(Ms,"new",()=>new Ms);let Mi=Ms;const Js=class Js extends L{constructor(){super({name:"Damage Buff",description:"Modifies the physical damage dealt by each target by a multiplier or a flat amount for a limited duration. Negative flat amounts or multipliers less than one will reduce damage dealt while the opposite will increase damage dealt. (e.g. a 5% damage buff would be a multiplier or 1.05)",data:[new k("Type","type",["Flat","Multiplier"],"Flat").setTooltip("The type of buff to apply. Flat increases damage by a fixed amount while multiplier increases it by a percentage"),new _("Skill Damage","skill").setTooltip("Whether to buff skill damage. If false, it will affect physical damage"),new b("Value","value",1).setTooltip('The amount to increase/decrease the damage by. A negative amoutn with the "Flat" type will decrease damage, similar to a number less than 1 for the multiplier'),new b("Seconds","seconds",3).setTooltip("The duration of the buff in seconds")],summaryItems:["type","skill","value","seconds"]},!1)}};c(Js,"new",()=>new Js);let Ji=Js;const Qs=class Qs extends L{constructor(){super({name:"Damage Lore",description:"Damages each target based on a value found in the lore of the item held by the caster",data:[new k("Hand","hand",["Main","Offhand"],"Main").setTooltip("The hand to check for the item. Offhand items are MC 1.9+ only"),new B("Regex","regex","Damage: {value}").setTooltip("The regex for the text to look for. Use {value} for where the important number should be. If you do not know about regex, consider looking it up on Wikipedia or avoid using major characters such as [ ] { } ( ) . + ? * ^ \\ |"),new b("Multiplier","multiplier",1).setTooltip("The multiplier to use on the value to get the actual damage to deal"),new _("True Damage","true").setTooltip("Whether to deal true damage. True damage ignores armor and all plugin checks"),new B("Classifier","classifier","default").setTooltip("The type of damage to deal. Can act as elemental damage or fake physical damage"),new _("Apply Knockback","knockback",!0).setTooltip("Whether the damage will inflict knockback. Ignored if it is True Damage"),new k("Damage Cause","cause",["Contact","Entity Attack","Entity Sweep Attack","Projectile","Suffocation","Fall","Fire","Fire Tick","Melting","Lava","Drowning","Block Explosion","Entity Explosion","Void","Lightning","Suicide","Starvation","Poison","Magic","Wither","Falling Block","Thorns","Dragon Breath","Custom","Fly Into Wall","Hot Floor","Cramming","Dryout","Freeze","Sonic Boom"],"Entity Attack").setTooltip("Damage Cause considered by the server. This will have influence over the death message and ProRPGItems' defenses").requireValue("true",[!1])],summaryItems:["hand","multiplier","true","knockback"]},!1)}};c(Qs,"new",()=>new Qs);let Qi=Qs;const eo=class eo extends L{constructor(){super({name:"Defense Buff",description:"Modifies the physical damage taken by each target by a multiplier or a flat amount for a limited duration. Negative flag amounts or multipliers less than one will reduce damage taken while the opposite will increase damage taken. (e.g. a 5% defense buff would be a multiplier or 0.95, since you would be taking 95% damage)",data:[new k("Type","type",["Flat","Multiplier"],"Flat").setTooltip("The type of buff to apply. Flat will increase/reduce incoming damage by a fixed amount where Multiplier does it by a percentage of the damage. Multipliers above 1 will increase damage taken while multipliers below 1 reduce damage taken"),new _("Skill Defense","skill").setTooltip("Whether to buff skill defense. If false, it will affect physical defense"),new b("Value","value",1).setTooltip("The amount to increase/decrease incoming damage by"),new b("Seconds","seconds",3).setTooltip("The duration of the buff in seconds")],summaryItems:["type","skill","value","seconds"]},!1)}};c(eo,"new",()=>new eo);let el=eo;const to=class to extends L{constructor(){super({name:"Delay",description:"Applies child components after a delay",data:[new b("Delay","delay",2).setTooltip("The amount of time to wait before applying child components in seconds"),new _("Cleanup","cleanup",!0).setTooltip("Whether this delay should be cleaned up on abort or logout/class change"),new _("Single Instance","single-instance",!1).setTooltip("Whether to only allow one instance of this delay per player. When true, this will cancel the previous delay and start the new one in its place.")],summaryItems:["delay","cleanup","single-instance"]},!0)}};c(to,"new",()=>new to);let tl=to;const ao=class ao extends L{constructor(){super({name:"Disguise",description:"Disguises each target according to the settings. This mechanic requires the LibsDisguise plugin to be installed on your server",data:[new b("Duration","duration",-1).setTooltip("How long to apply the disguise for in seconds. Use a negative number to permanently disguise the targets"),new k("Type","type",["Mob","Player","Misc"],"Mob").setTooltip("The type of disguise to use, as defined by the LibsDisguise plugin"),new k("Mob","mob",Fp,"Zombie").requireValue("type",["Mob"]).setTooltip("The type of mob to disguise the target as"),new _("Adult","adult",!0).requireValue("type",["Mob"]).setTooltip("Whether to use the adult variant of the mob"),new B("Player","player","Eniripsa96").requireValue("type",["Player"]).setTooltip("The player to disguise the target as"),new _("Change Name","change-name",!1).requireValue("type",["Player"]).setTooltip("Whether to change the entity's name to the player after disguising them"),new k("Misc","misc",Op,"Painting").requireValue("type",["Misc"]).setTooltip("The object to disguise the target as"),new G("Data","data",0).requireValue("misc",["Area effect cloud","Armor stand","Arrow","Boat","Dragon fireball","Egg","Ender crystal","Ender pearl","Ender signal","Experience orb","Fireball","Firework","Fishing hook","Item frame","Leash hitch","Minecart","Minecart chest","Minecart command","Minecart furnace","Minecart hopper","Minecart mob spawner","Minecart tnt","Painting","Primed tnt","Shulker bullet","Snowball","Spectral arrow","Splash potion","Thrown exp bottle","Wither skull"]).setTooltip("Data value to use for the disguise type. What it does depends on the disguise"),new k("Material","mat",()=>[...Me()],"Arrow").requireValue("misc",["Dropped item"]).setTooltip("Material to use for the disguise type."),new k("Material","mat",()=>[...Ge()],"Anvil").requireValue("misc",["Falling block"]).setTooltip("Block to use for the disguise type.")],summaryItems:["duration","type","mob","player","misc"]},!1)}};c(ao,"new",()=>new ao);let al=ao;const so=class so extends L{constructor(){super({name:"Durability",description:"Lowers the durability of a held item",data:[new b("Amount","amount",1).setTooltip("Amount to reduce the item's durability by"),new _("Offhand","offhand").setTooltip("Whether to apply to the offhand slot")],summaryItems:["amount","offhand"]},!1)}};c(so,"new",()=>new so);let sl=so;const oo=class oo extends L{constructor(){super({name:"Experience",description:"Modifies target's specified class experience",data:[new G("Value","value",1),new k("Mode","mode",["give","take","set"],"give",!1).setTooltip("To give, take or set specified valued"),new k("Type","type",["flat","percent"],"flat",!1).setTooltip("Flat value or percent from next level experience"),new B("Group","group","class").setTooltip("Group name to modify experience"),new _("Level Down","level-down",!1).setTooltip("Whether to use skill and level down player class if current exp is insufficient")],summaryItems:["value","mode","type","group"]},!1)}};c(oo,"new",()=>new oo);let ol=oo;const ro=class ro extends L{constructor(){super({name:"Explosion",description:"Causes an explosion at the current target's position",data:[new b("Power","power",3).setTooltip("The strength of the explosion"),new _("Damage Blocks","damage").setTooltip("Whether to damage blocks with the explosion"),new _("Fire","fire").setTooltip("Whether to set affected blocks on fire")],summaryItems:["power","damage","fire"]},!1)}};c(ro,"new",()=>new ro);let rl=ro;const no=class no extends L{constructor(){super({name:"Fire",description:"Sets the target on fire for a duration",data:[new b("Damage","damage",1).setTooltip("The damage dealt by each fire tick"),new b("Seconds","seconds",3,1).setTooltip("The duration of the fire in seconds")],summaryItems:["damage","seconds"]},!1)}};c(no,"new",()=>new no);let nl=no;const io=class io extends L{constructor(){super({name:"Flag",description:"Marks the target with a flag for a duration. Flags can be checked by other triggers, spells or the related for interesting synergies and effects",data:[new B("Key","key","key").setTooltip("The unique string for the flag. Use the same key when checking it in a Flag Condition"),new b("Seconds","seconds",3,1).setTooltip("The duration the flag should be set for. To set one indefinitely, use Flag Toggle")],summaryItems:["key","seconds"]})}};c(io,"new",()=>new io);let il=io;const lo=class lo extends L{constructor(){super({name:"Flag Clear",description:"Clears a flag from the target",data:[new B("Key","key","key").setTooltip("The unique string for the flag. This should match that of the mechanic that set the flag to begin with")],summaryItems:["key"]})}};c(lo,"new",()=>new lo);let ll=lo;const uo=class uo extends L{constructor(){super({name:"Flag Toggle",description:"Toggles a flag on or off for the target. This can be used to make toggle effects",data:[new B("Key","key","key").setTooltip("The unique string for the flag. Use the same key when checking it in a Flag Condition")],summaryItems:["key"]})}};c(uo,"new",()=>new uo);let ul=uo;const co=class co extends L{constructor(){super({name:"Food",description:"Adds or removes to a player's hunger and saturation",data:[new b("Food","food",1,1).setTooltip("The amount of food to give. Use a negative number to lower the food meter"),new b("Saturation","saturation").setTooltip("How much saturation to give. Use a negative number to lower saturation. This is the hidden value that determines how long until food starts going down")],summaryItems:["food","saturation"]},!1)}};c(co,"new",()=>new co);let cl=co;const po=class po extends L{constructor(){super({name:"Forget Targets",description:'Clears targets stored by the "Remember Targets" mechanic',data:[new B("Key","key","key").setTooltip("The unique key the targets were stored under")],summaryItems:["key"]},!1)}};c(po,"new",()=>new po);let pl=po;const ho=class ho extends L{constructor(){super({name:"GKCooldown",description:"Modifies the cooldown of the selected target's skill(s) in GKMagic's cooldown system.",data:[new B("Skill","skill","").setTooltip('The skill to modify the cooldown for, "all" to specify all the skills, leave it empty to specify the current skill.'),new k("Type","type",["Seconds","Percent"],"Seconds").setTooltip("The modification unit to use. Seconds will add/set seconds from the cooldown while Percent will add/set a percentage of its full cooldown"),new k("Percent Reference","percent_reference",["Skill Cooldown","Current Cooldown"],"Skill Cooldown").requireValue("type",["Percent"]).setTooltip("How to determine type:percent's base value. Skill Cooldown is the cooldown of the skill stored in database, Current Cooldown is the current cooldown of the player on the skill"),new k("Action","action",["Add","Set"],"Set").setTooltip("Whether to add or set the cooldown"),new b("Value","value",0,0).setTooltip("The amount to add to/set the skill's cooldown, a negative amount means to subtract cooldown")],summaryItems:["skill","type","value"]},!1)}};c(ho,"new",()=>new ho);let hl=ho;const mo=class mo extends L{constructor(){super({name:"GKSummon",description:"Summon an entity. Some option have no use for some entities, for example, set move speed 69 for a shulker.",data:[new B("Entity","entity","Allay").setTooltip("The entity to be summoned"),new b("Health","health",20,0).setTooltip("The health of the entities"),new b("Attack Damage","damage",2,0).setTooltip("The attack damage of the entities"),new b("Knockback","knockback",1,0).setTooltip("The power of knockback when the entities attack others"),new b("Walk Speed","walk_speed",-1,0).setTooltip("The move speed of the entities, leave negative and their walk speed should be the same as they used to"),new b("Fly Speed","fly_speed",-1,0).setTooltip("The fly speed of the entities, leave negative and their fly speed should be the same as they used to"),new b("Follow Range","follow_range",-1,0).setTooltip("The entities can detect enemies within how many blocks and trace them, , leave negative and their follow range should be the same as they used to"),new b("Armor","armor",0,0).setTooltip("The armor value of the entities"),new _("Adult","adult",!0).setTooltip("The entity should be an adult or a baby"),new b("Duration","duration",10,0).setTooltip("How many seconds it should exist"),new b("Amount","amount",1,0).setTooltip("How many entities will be summoned"),new B("Target","target","").requireValue("entity",["Shulker bullet"]).setTooltip("The target you want this bullet trace to"),new _("Ride","ride",!1).setTooltip("Whether to make launcher get on the entity"),new Qe("Skills","skills",[]).setTooltip("The skills to give the wolf. Skills are executed at the level of the skill summoning the wolf. Skills needing a Cast trigger will not work.")],summaryItems:["skill","type","value"]},!1)}};c(mo,"new",()=>new mo);let dl=mo;const fo=class fo extends L{constructor(){super({name:"Heal",description:"Restores health to each target",data:[new k("Type","type",["Health","Percent"],"Health").setTooltip("The unit to use for the amount of health to restore. Health restores a flat amount while Percent restores a percentage of their max health"),new b("Value","value",3,1).setTooltip("The amount of health to restore")],summaryItems:["type","value"]},!1)}};c(fo,"new",()=>new fo);let ml=fo;const go=class go extends L{constructor(){super({name:"Health Set",description:"Sets the target's health to the specified amount, ignoring resistances, damage buffs, and so on",data:[new b("Health","health",1).setTooltip("The health to set to")],summaryItems:["health"]},!1)}};c(go,"new",()=>new go);let fl=go;const wo=class wo extends L{constructor(){super({name:"Held Item",description:"Sets the held item slot of the target player. This will do nothing if trying to set it to a skill slot",data:[new b("Slot","slot").setTooltip("The slot to set it to")],summaryItems:["slot"]},!1)}};c(wo,"new",()=>new wo);let gl=wo;const yo=class yo extends L{constructor(){super({name:"Immunity",description:"Provides damage immunity from one source for a duration",data:[new k("Type","type",Rp,"Poison").setTooltip("The damage type to give an immunity for"),new b("Seconds","seconds",3).setTooltip("How long to give an immunity for"),new b("Multiplier","multiplier").setTooltip("The multiplier for the incoming damage. Use 0 if you want full immunity")],summaryItems:["type","seconds","multiplier"]})}};c(yo,"new",()=>new yo);let wl=yo;const To=class To extends L{constructor(){super({name:"Interrupt",description:"Interrupts any channeling being done by each target if applicable"})}};c(To,"new",()=>new To);let yl=To;const vo=class vo extends L{constructor(){super({name:"Invisibility",description:"Applies invisibility effect on target, optionally hiding equipment (Requires ProtocolLib).",data:[new G("Duration","duration",200).setTooltip("Duration in ticks"),new _("Hide Equipment","hideEquipment",!1).setTooltip("Whether to hide equipment or not. Requires ProtocolLib.")],summaryItems:["duration","hideEquipment"]})}};c(vo,"new",()=>new vo);let Tl=vo;const bo=class bo extends L{constructor(){super({name:"Item",description:"Gives each player target the item defined by the settings",data:[...Er()],summaryItems:["material","amount"]})}};c(bo,"new",()=>new bo);let vl=bo;const ko=class ko extends L{constructor(){super({name:"Item Drop",description:"Spawns a dropped item defined by the settings at the specified location",data:[new b("Pickup Delay","pickup_delay",10).setTooltip("How many ticks must pass before the item can be picked up, in ticks"),new b("Duration","duration",6e3).setTooltip("The time after which the item will despawn if not picked up, in ticks. Caps at 6000"),...Er(),new ue("Offset"),new b("Forward offset","forward").setTooltip("How far forward in blocks to teleport. A negative value teleports backwards"),new b("Upward offset","upward").setTooltip("How far upward in blocks to teleport. A negative value teleports downward"),new b("Right offset","right").setTooltip("How far to the right in blocks to teleport. A negative value teleports to the left")],summaryItems:["pickup_delay","duration","material","amount"]})}};c(ko,"new",()=>new ko);let bl=ko;const _o=class _o extends L{constructor(){super({name:"Item Projectile",description:"Launches a projectile using an item as its visual that applies child components upon landing. The target passed on will be the collided target or the location where it landed if it missed",data:[new k("Group","group",["Ally","Enemy"],"Enemy").setTooltip("The alignment of targets to hit"),new _("Wall Collisions","walls",!0).setTooltip("Wheter to account for wall collisions. If false, the item will just slide through them."),new b("Collision Radius","collision-radius",.2).setTooltip("The radius of the projectile considered when calculating collisions."),...Er(),...Pr(),...Cr(),...Ht(!0)],preview:[new G("Refresh period","period",5).setTooltip("How many ticks to wait before refreshing the preview, recalculating targets and the location of the particle effects"),new ue("Particles at target"),new _("Particles at target","per-target",!1).setTooltip("Displays particles at the location of the current targets"),new k("Particle","per-target-particle",Je,"Crit").setTooltip("The type of particle to display").requireValue("per-target",[!0]),new k("Material","per-target-material",()=>[...Me()],"Arrow").requireValue("per-target-particle",["Item crack","Item"]).requireValue("per-target",[!0]).setTooltip("The material to use for the particles"),new k("Material","per-target-material",()=>[...Ge()],"Dirt").requireValue("per-target-particle",["Block crack","Block dust","Block","Falling dust","Block marker"]).requireValue("per-target",[!0]).setTooltip("The block to use for the particles"),new G("Durability","per-target-durability",0).requireValue("per-target-particle",["Item crack","Item"]).requireValue("per-target",[!0]).setTooltip("The durability to be reduced from the item used to make the particles"),new G("CustomModelData","per-target-type",0).requireValue("per-target-particle",["Item crack","Item"]).requireValue("per-target",[!0]).setTooltip("The CustomModelData of the item used to make the particles"),new we("Dust Color","per-target-dust-color","#FF0000").requireValue("per-target-particle",["Redstone","Dust","Dust color transition"]).requireValue("per-target",[!0]).setTooltip("The color of the dust particles in hex RGB"),new we("Final Dust Color","per-target-final-dust-color","#FF0000").requireValue("per-target-particle",["Dust color transition"]).requireValue("per-target",[!0]).setTooltip("The color to transition to, in hex RGB"),new V("Dust Size","per-target-dust-size",1).requireValue("per-target-particle",["Redstone","Dust","Dust color transition"]).requireValue("per-target",[!0]).setTooltip("The size of the dust particles"),new G("Effect Data","per-target-data").requireValue("per-target-particle",["Smoke","Ender Signal","Mobspawner Flames","Potion Break","Sculk charge"]).requireValue("per-target",[!0]).setTooltip("The data value to use for the particle. The effect changes between particles such as the orientation for smoke particles or the color for potion break"),new V("DX","per-target-dx").requireValue("per-target",[!0]).setTooltip("Offset in the X direction, used as the Red value for some particles"),new V("DY","per-target-dy").requireValue("per-target",[!0]).setTooltip("Offset in the Y direction, used as the Green value for some particles"),new V("DZ","per-target-dz").requireValue("per-target",[!0]).setTooltip("Offset in the Z direction, used as the Blue value for some particles"),new V("Amount","per-target-amount",1).requireValue("per-target",[!0]).setTooltip('Number of particles to play per point. For "Spell mob" and "Spell mob ambient" particles, set to 0 to control the particle color'),new V("Speed","per-target-speed",.1).requireValue("per-target",[!0]).setTooltip("Speed of the particle. For some particles controls other parameters, such as size"),new k("Arrangement","per-target-arrangement",["Sphere","Circle","Hemisphere"],"Sphere").requireValue("per-target",[!0]).setTooltip("The arrangement to use for the particles. Circle is a 2D circle, Hemisphere is half a 3D sphere, and Sphere is a 3D sphere"),new k("Circle Direction","per-target-direction",["XY","XZ","YZ"],"XZ").requireValue("per-target-arrangement",["Circle"]).requireValue("per-target",[!0]).setTooltip("The orientation of the circle. XY and YZ are vertical circles while XZ is a horizontal circle"),new b("Radius","per-target-radius",.5).requireValue("per-target",[!0]).setTooltip("The radius of the arrangement in blocks"),new _("Increase size by hitbox","per-target-hitbox",!0).requireValue("per-target",[!0]).setTooltip("Increases the 'radius' parameter by the size of the target's hitbox"),new b("Points","per-target-particles",20).requireValue("per-target",[!0]).setTooltip("The amount of points that conform the chosen arrangement"),new ue("Path Preview"),new _("Path Preview","path",!1).setTooltip("Displays particles through the paths of the projectiles"),new V("Steps per particle","path-steps",2).setTooltip("How many collision steps to run between each particle display").requireValue("path",[!0]),new k("Particle","path-particle",Je,"Crit").setTooltip("The type of particle to display").requireValue("path",[!0]),new k("Material","path-material",()=>[...Me()],"Arrow").requireValue("path-particle",["Item crack","Item"]).requireValue("path",[!0]).setTooltip("The material to use for the particles"),new k("Material","path-material",()=>[...Ge()],"Dirt").requireValue("path-particle",["Block crack","Block dust","Block","Falling dust","Block marker"]).requireValue("path",[!0]).setTooltip("The block to use for the particles"),new G("Durability","path-durability",0).requireValue("path-particle",["Item crack","Item"]).requireValue("path",[!0]).setTooltip("The durability to be reduced from the item used to make the particles"),new G("CustomModelData","path-type",0).requireValue("path-particle",["Item crack","Item"]).requireValue("path",[!0]).setTooltip("The CustomModelData of the item used to make the particles"),new we("Dust Color","path-dust-color","#FF0000").requireValue("path-particle",["Redstone","Dust","Dust color transition"]).requireValue("path",[!0]).setTooltip("The color of the dust particles in hex RGB"),new we("Final Dust Color","path-final-dust-color","#FF0000").requireValue("path-particle",["Dust color transition"]).requireValue("path",[!0]).setTooltip("The color to transition to, in hex RGB"),new V("Dust Size","path-dust-size",1).requireValue("path-particle",["Redstone","Dust","Dust color transition"]).requireValue("path",[!0]).setTooltip("The size of the dust particles"),new G("Effect Data","path-data").requireValue("path-particle",["Smoke","Ender Signal","Mobspawner Flames","Potion Break","Sculk charge"]).requireValue("path",[!0]).setTooltip("The data value to use for the particle. The effect changes between particles such as the orientation for smoke particles or the color for potion break"),new V("DX","path-dx").requireValue("path",[!0]).setTooltip("Offset in the X direction, used as the Red value for some particles"),new V("DY","path-dy").requireValue("path",[!0]).setTooltip("Offset in the Y direction, used as the Green value for some particles"),new V("DZ","path-dz").requireValue("path",[!0]).setTooltip("Offset in the Z direction, used as the Blue value for some particles"),new V("Amount","path-amount",1).requireValue("path",[!0]).setTooltip('Number of particles to play per point. For "Spell mob" and "Spell mob ambient" particles, set to 0 to control the particle color'),new V("Speed","path-speed",.1).requireValue("path",[!0]).setTooltip("Speed of the particle. For some particles controls other parameters, such as size")],summaryItems:["group","material","velocity","spread","angle","correction","homing","collision-radius"]},!0)}};c(_o,"new",()=>new _o);let kl=_o;const Io=class Io extends L{constructor(){super({name:"Item Remove",description:"Removes an item from a player inventory. This does nothing to mobs",data:[new b("Amount","amount",1).setTooltip("The amount of the item needed in the player's inventory"),...kt()],summaryItems:["amount","material"]},!1)}};c(Io,"new",()=>new Io);let _l=Io;const Do=class Do extends L{constructor(){super({name:"Launch",description:"Launches the target relative to their forward direction. Use negative values to go in the opposite direction (e.g. negative forward makes the target go backwards)",data:[new k("Relative","relative",["Target","Caster","Between"],"Target").setTooltip('Determines what is considered "forward". Target uses the direction the target is facing, Caster uses the direction the caster is facing, and Between uses the direction from the target to the caster'),new _("Reset Y","reset-y").setTooltip("Whether to reset the Y value. False means the upward velocity is a combination of the setting and the relative vector."),new b("Forward Speed","forward").setTooltip("The speed to give the target in the direction they are facing/looking"),new b("Upward Speed","upward",2,.5).setTooltip("The speed to give the target upwards, this is added to the calculated vector if 'Use Look' is true"),new b("Right Speed","right").setTooltip("The speed to give the target to their right")],summaryItems:["relative","reset-y","forward","upward","right"]},!1)}};c(Do,"new",()=>new Do);let Il=Do;const So=class So extends L{constructor(){super({name:"Launch To",description:"Launches the target to the caster or the caster to the target",data:[new k("Type","type",["Caster to Target","Target to Caster"],"Caster to Target").setTooltip("Determines launches target to caster or launches caster to target"),new b("Speed","speed",1,0).setTooltip("The speed when player been launching. If higher, player will be launched farther"),new b("Height","height",1,0).setTooltip("The height when launching")],summaryItems:["type","speed","height"]},!1)}};c(So,"new",()=>new So);let Dl=So;const Ao=class Ao extends L{constructor(){super({name:"Lightning",description:"Strikes lightning on or near the target, applying child components to the struck targets. Negative offsets will offset it in the opposite direction (e.g. negative forward offset puts it behind the target)",data:[new b("Damage","damage",5).setTooltip("The damage dealt by the lightning bolt"),new k("Group","group",["Ally","Enemy","Both"],"Enemy").setTooltip("The alignment of targets to hit"),new _("Include Caster","caster").setTooltip("Whether the lightning strike can hit the caster"),new _("Fire","fire",!0).setTooltip("Whether the lightning should start a fire on hit"),new ue("Offset"),new b("Forward Offset","forward").setTooltip("How far in front of the target in blocks to place the lightning"),new b("Right Offset","right").setTooltip("How far to the right of the target in blocks to place the lightning")],summaryItems:["damage","group","caster","fire"]},!0)}};c(Ao,"new",()=>new Ao);let Sl=Ao;const Vo=class Vo extends L{constructor(){super({name:"Mana",description:"Restores or deducts mana from the target",data:[new k("Type","type",["Mana","Percent"],"Mana").setTooltip("The unit to use for the amount of mana to restore/drain. Mana does a flat amount while Percent does a percentage of their max mana"),new b("Value","value",1).setTooltip("The amount of mana to restore/drain")],summaryItems:["type","value"]},!1)}};c(Vo,"new",()=>new Vo);let Al=Vo;const qo=class qo extends L{constructor(){super({name:"Message",description:"Sends a message to each player target. To include numbers from Value mechanics, use the filters {<key>} where <key> is the key the value is stored under",data:[new B("Message","message","text").setTooltip(`The message to display. {player} = caster's name, {target} = target's name, {targetUUID} = target's UUID (useful if targets are non players), &lc: "{", &rc: "}", &sq: "'"`)],summaryItems:["message"]})}};c(qo,"new",()=>new qo);let Vl=qo;const Eo=class Eo extends L{constructor(){super({name:"Mine",description:"Destroys a selection of blocks at the location of the target",data:[new k("Material","materials",()=>["Origin","Any",...Ge()],["Origin"],!0).setTooltip("The types of blocks allowed to be broken. 'Origin' refers to the material at the targeted location"),new _("Drop","drop",!0).setTooltip("Whether to create drops for the destroyed blocks"),new k("Tool","tool",()=>["Caster","Target",...Me()],"Diamond pickaxe").requireValue("drop",[!0]).setTooltip("What tool to use when breaking the blocks. This allows to take into account the fact that, for example, Diamond Ore does not drop when mined with a Stone Pickaxe, as well as to consider enchantments like Looting and Silk Touch. 'Caster' an 'Target' refers to the items in their respective main hands"),new k("Shape","shape",["Sphere","Cuboid"],"Sphere").setTooltip("The shape of the region to mine"),new b("Radius","radius",2).requireValue("shape",["Sphere"]).setTooltip("The radius of the sphere, in blocks"),new b("Width (X)","width",3).requireValue("shape",["Cuboid"]).setTooltip("The width of the cuboid, in blocks"),new b("Height (Y)","height",3).requireValue("shape",["Cuboid"]).setTooltip("The height of the cuboid, in blocks"),new b("Depth (Z)","depth",3).requireValue("shape",["Cuboid"]).setTooltip("The depth of the cuboid, in blocks"),new ue("Offset"),new b("Forward Offset","forward").setTooltip("How far forward in front of the target the region should be in blocks. A negative value will put it behind"),new b("Upward Offset","upward").setTooltip("How far above the target the region should be in blocks. A negative value will put it below"),new b("Right Offset","right").setTooltip("How far to the right the region should be of the target. A negative value will put it to the left")],preview:[...et(),new _("Center only","per-target-center-only",!0).setTooltip("Whether to display particles only at the center of the affected area, or at each affected block").requireValue("per-target",[!0])],summaryItems:["materials","drop","tool","shape","radius"]})}};c(Eo,"new",()=>new Eo);let ql=Eo;const Co=class Co extends L{constructor(){super({name:"Money",description:"Adds or multiplies the target's balance by some amount (requires Vault and an economy plugin). Fails if the resulting balance is not within the range allowed by the economy plugin",data:[new k("Type","type",["Add","Multiply"],"Add").setTooltip("Whether the target's balance will be added or multiplied by the set amount"),new b("Amount","amount",5).setTooltip("The amount that the target's balance will be added or multiplied by. Can be negative"),new _("Allows negative","allows_negative").setTooltip("Whether the mechanic will be executed even if it will result in the target having a negative balance")],summaryItems:["type","amount"]})}};c(Co,"new",()=>new Co);let El=Co;const Po=class Po extends L{constructor(){super({name:"Mount",description:"Mounts entities",data:[new k("Type","type",["Caster->Target","Target->Caster"],"Caster->Target").setTooltip("The direction of the mounting"),new b("Stack Size","max",5).setTooltip("The maximum amount of entities to stack")],summaryItems:["type"]})}};c(Po,"new",()=>new Po);let Cl=Po;const $o=class $o extends L{constructor(){super({name:"Particle",description:"Plays a particle effect about the target",data:[...xt(),new ue("Offset"),new V("Forward Offset","forward").setTooltip("How far forward in front of the target in blocks to play the particles. A negative value will go behind"),new V("Upward Offset","upward").setTooltip("How far above the target in blocks to play the particles. A negative value will go below"),new V("Right Offset","right").setTooltip("How far to the right of the target to play the particles. A negative value will go to the left")],summaryItems:["particle","amount","spread","dust-color"]})}};c($o,"new",()=>new $o);let Pl=$o;const Fo=class Fo extends L{constructor(){super({name:"Particle Animation",description:"Plays an animated particle effect at the location of each target over time by applying various transformations",data:[new G("Steps","steps",1).setTooltip("The number of times to play particles and apply translations each application"),new V("Frequency","frequency",.05).setTooltip("How often to apply the animation in seconds. 0.05 is the fastest (1 tick). Lower than that will act the same"),new G("Angle","angle",0).setTooltip("How far the animation should rotate over the duration in degrees"),new G("Start Angle","start",0).setTooltip("The starting orientation of the animation. Horizontal translations and the forward/right offsets will be based off of this"),new b("Duration","duration",5).setTooltip("How long the animation should last for in seconds"),new b("H-Translation","h-translation").setTooltip("How far the animation moves horizontally relative to the center over a cycle. Positive values make it expand from the center while negative values make it contract"),new b("V-Translation","v-translation").setTooltip("How far the animation moves vertically over a cycle. Positive values make it rise while negative values make it sink"),new G("H-Cycles","h-cycles",1).setTooltip("How many times to move the animation position throughout the animation. Every other cycle moves it back to where it started. For example, two cycles would move it out and then back in"),new G("V-Cycles","v-cycles",1).setTooltip("How many times to move the animation position throughout the animation. Every other cycle moves it back to where it started. For example, two cycles would move it up and then back down"),...xt(),new ue("Offset"),new V("Forward Offset","forward",0).setTooltip("How far forward in front of the target in blocks to play the particles. A negative value will go behind"),new V("Upward Offset","upward",0).setTooltip("How far above the target in blocks to play the particles. A negative value will go below"),new V("Right Offset","right",0).setTooltip("How far to the right of the target to play the particles. A negative value will go to the left"),new _("Rotate w/ Player","-with-rotation").setTooltip("Whether to follow the rotation of the player for the effect")],summaryItems:["steps","frequency","angle","duration","particle","amount","spread","dust-color"]})}};c(Fo,"new",()=>new Fo);let $l=Fo;const Oo=class Oo extends L{constructor(){super({name:"Particle Effect",description:"Plays a particle effect that follows the current target, using formulas to determine shape, size, and motion",data:[...Ht(!1)],summaryItems:["effect-key","-particle","-particle-dust-color"]})}};c(Oo,"new",()=>new Oo);let Fl=Oo;const Ro=class Ro extends L{constructor(){super({name:"Particle Image",description:"Displays an image using particles that (optionally) follows the current target",data:[new B("Effect Key","effect-key","default").setTooltip("The key to refer to the effect by. Only one effect of each key can be active at a time."),new B("Image","img","default.png").setTooltip("The image to display. Put images in the plugins/Fabled/images folder"),new b("Duration","duration",5).setTooltip("The time to play the effect for in seconds"),new G("Interval","interval",5).setTooltip("Number of ticks between playing particles."),new G("Frame Frequency","iterations-per-frame",3).setTooltip("Number of iterations before moving to the next frame of a gif. 1 is the fastest, 0 will not animate"),new G("View Range","view-range",25).setTooltip("How far away the effect can be seen from."),new k("Direction","direction",["XY","YZ","XZ"],"XY").setTooltip("The plane the shape formula applies to. Player follows the player's look direction. XZ would be flat, the other two are vertical."),new V("Width","width",3).setTooltip("The width of the image in blocks"),new V("Height","height",3).requireValue("lock-aspect",[!1]).setTooltip("The height of the image in blocks"),new _("Lock Aspect Ratio","lock-aspect",!0).setTooltip("Whether to keep the aspect ratio of the image"),new G("Resolution","resolution",6).setTooltip("Number of particles per block. 6 particles per block is typically pretty decent with a dust size of 1"),new B("Dust Size","dust-size","1").setTooltip("The formula for the size of the dust particles. <code>t</code> is the number of iterations, <code>l</code> is the skill level"),new B("Rotate","rotate","0").setTooltip("The formula to rotate the effect, <code>t</code> is the number of iterations, <code>l</code> is the skill level"),new B("Tilt","tilt","0").setTooltip("The formula to tilt the effect forward, <code>t</code> is the number of iterations, <code>l</code> is the skill level"),new B("Spin","spin","0").setTooltip("The formula to spin the effect, <code>t</code> is the number of iterations, <code>l</code> is the skill level"),new B("Scale","scale","1").setTooltip("The formula to scale the effect, <code>t</code> is the number of iterations, <code>l</code> is the skill level"),new B("Forward Offset","forward","0").setTooltip("The formula to offset the effect forward, <code>t</code> is the number of iterations, <code>l</code> is the skill level"),new B("Upward Offset","upward","0").setTooltip("The formula to offset the effect upward, <code>t</code> is the number of iterations, <code>l</code> is the skill level"),new B("Right Offset","right","0").setTooltip("The formula to offset the effect to the right, <code>t</code> is the number of iterations, <code>l</code> is the skill level"),new _("Rotate w/ Player","with-rotation",!0).setTooltip("Whether to follow the rotation of the player for the effect.")],summaryItems:["effect-key","img","duration"]})}};c(Ro,"new",()=>new Ro);let Ol=Ro;const No=class No extends L{constructor(){super({name:"Particle Projectile",description:"Launches a projectile using particles as its visual that applies child components upon landing. The target passed on will be the collided target or the location where it landed if it missed",data:[new _("Pierce","pierce").setTooltip("Whether this projectile should pierce through initial targets and continue hitting those behind them"),new _("Pierce through blocks","pierce-blocks").setTooltip("Whether this projectile should pierce through blocks"),new k("Group","group",["Ally","Enemy"],"Enemy").setTooltip("The alignment of targets to hit"),new G("Steps","steps",2).setTooltip("Amount of collision steps to run per meter travelled."),new b("Collision Radius","collision-radius",.8).setTooltip("The radius of the projectile considered when calculating collisions."),new b("Gravity","gravity",-.04).setTooltip("Vertical acceleration the projectile is subjected to, in meters per squared tick. Negative values make it fall while positive values make it rise."),new b("Drag","drag",.02).setTooltip("Air resistance of the projectile, in inverse seconds. Greater values mean the projectile will slow down more over time, and reach a lower terminal velocity."),new G("Particle period","period",2).setTooltip("How often to play a particle effect where the projectile is."),new _("ride","ride",!1).setTooltip("Whether the caster should ride the projectile"),...Pr(),...Cr(),...xt(),...Ht(!0)],preview:[new G("Refresh period","period",5).setTooltip("How many ticks to wait before refreshing the preview, recalculating targets and the location of the particle effects"),new ue("Particles at target"),new _("Particles at target","per-target",!1).setTooltip("Displays particles at the location of the current targets"),new k("Particle","per-target-particle",Je,"Crit").setTooltip("The type of particle to display").requireValue("per-target",[!0]),new k("Material","per-target-material",()=>[...Me()],"Arrow").requireValue("per-target-particle",["Item crack","Item"]).requireValue("per-target",[!0]).setTooltip("The material to use for the particles"),new k("Material","per-target-material",()=>[...Ge()],"Dirt").requireValue("per-target-particle",["Block crack","Block dust","Block","Falling dust","Block marker"]).requireValue("per-target",[!0]).setTooltip("The block to use for the particles"),new G("Durability","per-target-durability",0).requireValue("per-target-particle",["Item crack","Item"]).requireValue("per-target",[!0]).setTooltip("The durability to be reduced from the item used to make the particles"),new G("CustomModelData","per-target-type",0).requireValue("per-target-particle",["Item crack","Item"]).requireValue("per-target",[!0]).setTooltip("The CustomModelData of the item used to make the particles"),new we("Dust Color","per-target-dust-color","#FF0000").requireValue("per-target-particle",["Redstone","Dust","Dust color transition"]).requireValue("per-target",[!0]).setTooltip("The color of the dust particles in hex RGB"),new we("Final Dust Color","per-target-final-dust-color","#FF0000").requireValue("per-target-particle",["Dust color transition"]).requireValue("per-target",[!0]).setTooltip("The color to transition to, in hex RGB"),new V("Dust Size","per-target-dust-size",1).requireValue("per-target-particle",["Redstone","Dust","Dust color transition"]).requireValue("per-target",[!0]).setTooltip("The size of the dust particles"),new G("Effect Data","per-target-data").requireValue("per-target-particle",["Smoke","Ender Signal","Mobspawner Flames","Potion Break","Sculk charge"]).requireValue("per-target",[!0]).setTooltip("The data value to use for the particle. The effect changes between particles such as the orientation for smoke particles or the color for potion break"),new V("DX","per-target-dx").requireValue("per-target",[!0]).setTooltip("Offset in the X direction, used as the Red value for some particles"),new V("DY","per-target-dy").requireValue("per-target",[!0]).setTooltip("Offset in the Y direction, used as the Green value for some particles"),new V("DZ","per-target-dz").requireValue("per-target",[!0]).setTooltip("Offset in the Z direction, used as the Blue value for some particles"),new V("Amount","per-target-amount",1).requireValue("per-target",[!0]).setTooltip('Number of particles to play per point. For "Spell mob" and "Spell mob ambient" particles, set to 0 to control the particle color'),new V("Speed","per-target-speed",.1).requireValue("per-target",[!0]).setTooltip("Speed of the particle. For some particles controls other parameters, such as size"),new k("Arrangement","per-target-arrangement",["Sphere","Circle","Hemisphere"],"Sphere").requireValue("per-target",[!0]).setTooltip("The arrangement to use for the particles. Circle is a 2D circle, Hemisphere is half a 3D sphere, and Sphere is a 3D sphere"),new k("Circle Direction","per-target-direction",["XY","XZ","YZ"],"XZ").requireValue("per-target-arrangement",["Circle"]).requireValue("per-target",[!0]).setTooltip("The orientation of the circle. XY and YZ are vertical circles while XZ is a horizontal circle"),new b("Radius","per-target-radius",.5).requireValue("per-target",[!0]).setTooltip("The radius of the arrangement in blocks"),new _("Increase size by hitbox","per-target-hitbox",!0).requireValue("per-target",[!0]).setTooltip("Increases the 'radius' parameter by the size of the target's hitbox"),new b("Points","per-target-particles",20).requireValue("per-target",[!0]).setTooltip("The amount of points that conform the chosen arrangement"),new ue("Path Preview"),new _("Path Preview","path",!1).setTooltip("Displays particles through the paths of the projectiles"),new V("Steps per particle","path-steps",2).setTooltip("How many collision steps to run between each particle display").requireValue("path",[!0]),new k("Particle","path-particle",Je,"Crit").setTooltip("The type of particle to display").requireValue("path",[!0]),new k("Material","path-material",()=>[...Me()],"Arrow").requireValue("path-particle",["Item crack","Item"]).requireValue("path",[!0]).setTooltip("The material to use for the particles"),new k("Material","path-material",()=>[...Ge()],"Dirt").requireValue("path-particle",["Block crack","Block dust","Block","Falling dust","Block marker"]).requireValue("path",[!0]).setTooltip("The block to use for the particles"),new G("Durability","path-durability",0).requireValue("path-particle",["Item crack","Item"]).requireValue("path",[!0]).setTooltip("The durability to be reduced from the item used to make the particles"),new G("CustomModelData","path-type",0).requireValue("path-particle",["Item crack","Item"]).requireValue("path",[!0]).setTooltip("The CustomModelData of the item used to make the particles"),new we("Dust Color","path-dust-color","#FF0000").requireValue("path-particle",["Redstone","Dust","Dust color transition"]).requireValue("path",[!0]).setTooltip("The color of the dust particles in hex RGB"),new we("Final Dust Color","path-final-dust-color","#FF0000").requireValue("path-particle",["Dust color transition"]).requireValue("path",[!0]).setTooltip("The color to transition to, in hex RGB"),new V("Dust Size","path-dust-size",1).requireValue("path-particle",["Redstone","Dust","Dust color transition"]).requireValue("path",[!0]).setTooltip("The size of the dust particles"),new G("Effect Data","path-data").requireValue("path-particle",["Smoke","Ender Signal","Mobspawner Flames","Potion Break","Sculk charge"]).requireValue("path",[!0]).setTooltip("The data value to use for the particle. The effect changes between particles such as the orientation for smoke particles or the color for potion break"),new V("DX","path-dx").requireValue("path",[!0]).setTooltip("Offset in the X direction, used as the Red value for some particles"),new V("DY","path-dy").requireValue("path",[!0]).setTooltip("Offset in the Y direction, used as the Green value for some particles"),new V("DZ","path-dz").requireValue("path",[!0]).setTooltip("Offset in the Z direction, used as the Blue value for some particles"),new V("Amount","path-amount",1).requireValue("path",[!0]).setTooltip('Number of particles to play per point. For "Spell mob" and "Spell mob ambient" particles, set to 0 to control the particle color'),new V("Speed","path-speed",.1).requireValue("path",[!0]).setTooltip("Speed of the particle. For some particles controls other parameters, such as size")],summaryItems:["steps","gravity","drag","frequency","pierce","group","particle","amount","spread","dust-color","correction","homing"]},!0)}};c(No,"new",()=>new No);let Rl=No;const Lo=class Lo extends L{constructor(){super({name:"Passive",description:"Applies child components continuously every period. The seconds value below is the period or how often it applies",data:[new b("Seconds","seconds",1).setTooltip("The delay in seconds between each application")],summaryItems:["seconds"]},!0)}};c(Lo,"new",()=>new Lo);let Nl=Lo;const xo=class xo extends L{constructor(){super({name:"Permission",description:"Grants each player target a permission for a limited duration. This mechanic requires Vault with an accompanying permissions plugin in order to work",data:[new B("Permission","perm","plugin.perm.key").setTooltip("The permission to give to the player"),new b("Seconds","seconds",3).setTooltip("How long in seconds to give the permission to the player")],summaryItems:["perm","seconds"]})}};c(xo,"new",()=>new xo);let Ll=xo;const Ho=class Ho extends L{constructor(){super({name:"Potion",description:"Applies a potion effect to the target for a duration",data:[new k("Potion","potion",Jc,"Absorption").setTooltip("The type of potion effect to apply"),new _("Ambient Particles","ambient",!0).setTooltip("Whether to show ambient particles"),new b("Tier","tier",1).setTooltip("The strength of the potion"),new b("Seconds","seconds",3,1).setTooltip("How long to apply the effect for")],summaryItems:["potion","tier","seconds"]},!1)}};c(Ho,"new",()=>new Ho);let xl=Ho;const Bo=class Bo extends L{constructor(){super({name:"Potion Projectile",description:"Drops a splash potion from each target that does not apply potion effects by default. This will apply child elements when the potion lands. The targets supplied will be everything hit by the potion. If nothing is hit by the potion, the target will be the location it landed",data:[new we("Color","color","#ff0000").setTooltip("The hex color code to use for the potion"),new k("Group","group",["Ally","Enemy","Both"],"Enemy").setTooltip("The alignment of entities to hit"),new _("Flaming","flaming",!1).setTooltip("Whether to make the launched projectiles on fire"),new _("Linger","linger",!1).setTooltip("Whether the potion should be a lingering potion (for 1.9+ only)"),new ue("Area Effect Cloud").requireValue("linger",[!0]),new b("Duration","duration",30).setTooltip("How long the resulting area effect cloud lasts, in seconds.").requireValue("linger",[!0]),new b("Wait time","wait-time",.5).setTooltip("How long an entity has to be exposed to the cloud before its effect is applied, in seconds.").requireValue("linger",[!0]),new b("Reapplication delay","reapplication-delay",1).setTooltip("For how long an entity will be immune from subsequent exposure, in seconds.").requireValue("linger",[!0]),new b("Duration on use","duration-on-use",0).setTooltip("How much the duration of the cloud will decrease by when it applies an effect to an entity, in seconds.").requireValue("linger",[!0]),new b("Radius","cloud-radius",3).setTooltip("The initial radius of the cloud, in meters.").requireValue("linger",[!0]),new b("Radius on use","radius-on-use",-.5).setTooltip("How much the radius of the cloud will decrease by when it applies an effect to an entity, in meters.").requireValue("linger",[!0]),new b("Radius per tick","radius-per-tick",-.1).setTooltip("How much the radius of the cloud will decrease by, in meters per second").requireValue("linger",[!0]),new k("Cloud Particle","cloud-particle",Je,"Spell mob").setTooltip("The type of particle the cloud is composed of").requireValue("linger",[!0]),new k("Material","cloud-material",()=>[...Me()],"Arrow").requireValue("cloud-particle",["Item crack","Item"]).setTooltip("The material to use for the particles"),new k("Material","cloud-material",()=>[...Ge()],"Dirt").requireValue("cloud-particle",["Block crack","Block dust","Block","Falling dust","Block marker"]).setTooltip("The block to use for the particles"),new G("Durability","cloud-durability",0).requireValue("cloud-particle",["Item crack","Item"]).setTooltip("The durability to be reduced from the item used to make the particles"),new G("CustomModelData","cloud-type",0).requireValue("cloud-particle",["Item crack","Item"]).setTooltip("The CustomModelData of the item used to make the particles"),new we("Dust Color","cloud-dust-color","#FF0000").requireValue("cloud-particle",["Redstone","Dust","Dust color transition"]).setTooltip("The color of the dust particles in hex RGB"),new we("Final Dust Color","cloud-final-dust-color","#FF0000").requireValue("cloud-particle",["Dust color transition"]).setTooltip("The color to transition to, in hex RGB"),new V("Dust Size","cloud-dust-size",1).requireValue("cloud-particle",["Redstone","Dust","Dust color transition"]).setTooltip("The size of the dust particles"),...Pr(),...Cr(),...xt(),...Ht(!0)],preview:[new G("Refresh period","period",5).setTooltip("How many ticks to wait before refreshing the preview, recalculating targets and the location of the particle effects"),new ue("Particles at target"),new _("Particles at target","per-target",!1).setTooltip("Displays particles at the location of the current targets"),new k("Particle","per-target-particle",Je,"Crit").setTooltip("The type of particle to display").requireValue("per-target",[!0]),new k("Material","per-target-material",()=>[...Me()],"Arrow").requireValue("per-target-particle",["Item crack","Item"]).requireValue("per-target",[!0]).setTooltip("The material to use for the particles"),new k("Material","per-target-material",()=>[...Ge()],"Dirt").requireValue("per-target-particle",["Block crack","Block dust","Block","Falling dust","Block marker"]).requireValue("per-target",[!0]).setTooltip("The block to use for the particles"),new G("Durability","per-target-durability",0).requireValue("per-target-particle",["Item crack","Item"]).requireValue("per-target",[!0]).setTooltip("The durability to be reduced from the item used to make the particles"),new G("CustomModelData","per-target-type",0).requireValue("per-target-particle",["Item crack","Item"]).requireValue("per-target",[!0]).setTooltip("The CustomModelData of the item used to make the particles"),new we("Dust Color","per-target-dust-color","#FF0000").requireValue("per-target-particle",["Redstone","Dust","Dust color transition"]).requireValue("per-target",[!0]).setTooltip("The color of the dust particles in hex RGB"),new we("Final Dust Color","per-target-final-dust-color","#FF0000").requireValue("per-target-particle",["Dust color transition"]).requireValue("per-target",[!0]).setTooltip("The color to transition to, in hex RGB"),new V("Dust Size","per-target-dust-size",1).requireValue("per-target-particle",["Redstone","Dust","Dust color transition"]).requireValue("per-target",[!0]).setTooltip("The size of the dust particles"),new G("Effect Data","per-target-data").requireValue("per-target-particle",["Smoke","Ender Signal","Mobspawner Flames","Potion Break","Sculk charge"]).requireValue("per-target",[!0]).setTooltip("The data value to use for the particle. The effect changes between particles such as the orientation for smoke particles or the color for potion break"),new V("DX","per-target-dx").requireValue("per-target",[!0]).setTooltip("Offset in the X direction, used as the Red value for some particles"),new V("DY","per-target-dy").requireValue("per-target",[!0]).setTooltip("Offset in the Y direction, used as the Green value for some particles"),new V("DZ","per-target-dz").requireValue("per-target",[!0]).setTooltip("Offset in the Z direction, used as the Blue value for some particles"),new V("Amount","per-target-amount",1).requireValue("per-target",[!0]).setTooltip('Number of particles to play per point. For "Spell mob" and "Spell mob ambient" particles, set to 0 to control the particle color'),new V("Speed","per-target-speed",.1).requireValue("per-target",[!0]).setTooltip("Speed of the particle. For some particles controls other parameters, such as size"),new k("Arrangement","per-target-arrangement",["Sphere","Circle","Hemisphere"],"Sphere").requireValue("per-target",[!0]).setTooltip("The arrangement to use for the particles. Circle is a 2D circle, Hemisphere is half a 3D sphere, and Sphere is a 3D sphere"),new k("Circle Direction","per-target-direction",["XY","XZ","YZ"],"XZ").requireValue("per-target-arrangement",["Circle"]).requireValue("per-target",[!0]).setTooltip("The orientation of the circle. XY and YZ are vertical circles while XZ is a horizontal circle"),new b("Radius","per-target-radius",.5).requireValue("per-target",[!0]).setTooltip("The radius of the arrangement in blocks"),new _("Increase size by hitbox","per-target-hitbox",!0).requireValue("per-target",[!0]).setTooltip("Increases the 'radius' parameter by the size of the target's hitbox"),new b("Points","per-target-particles",20).requireValue("per-target",[!0]).setTooltip("The amount of points that conform the chosen arrangement"),new ue("Path Preview"),new _("Path Preview","path",!1).setTooltip("Displays particles through the paths of the projectiles"),new V("Steps per particle","path-steps",2).setTooltip("How many collision steps to run between each particle display").requireValue("path",[!0]),new k("Particle","path-particle",Je,"Crit").setTooltip("The type of particle to display").requireValue("path",[!0]),new k("Material","path-material",()=>[...Me()],"Arrow").requireValue("path-particle",["Item crack","Item"]).requireValue("path",[!0]).setTooltip("The material to use for the particles"),new k("Material","path-material",()=>[...Ge()],"Dirt").requireValue("path-particle",["Block crack","Block dust","Block","Falling dust","Block marker"]).requireValue("path",[!0]).setTooltip("The block to use for the particles"),new G("Durability","path-durability",0).requireValue("path-particle",["Item crack","Item"]).requireValue("path",[!0]).setTooltip("The durability to be reduced from the item used to make the particles"),new G("CustomModelData","path-type",0).requireValue("path-particle",["Item crack","Item"]).requireValue("path",[!0]).setTooltip("The CustomModelData of the item used to make the particles"),new we("Dust Color","path-dust-color","#FF0000").requireValue("path-particle",["Redstone","Dust","Dust color transition"]).requireValue("path",[!0]).setTooltip("The color of the dust particles in hex RGB"),new we("Final Dust Color","path-final-dust-color","#FF0000").requireValue("path-particle",["Dust color transition"]).requireValue("path",[!0]).setTooltip("The color to transition to, in hex RGB"),new V("Dust Size","path-dust-size",1).requireValue("path-particle",["Redstone","Dust","Dust color transition"]).requireValue("path",[!0]).setTooltip("The size of the dust particles"),new G("Effect Data","path-data").requireValue("path-particle",["Smoke","Ender Signal","Mobspawner Flames","Potion Break","Sculk charge"]).requireValue("path",[!0]).setTooltip("The data value to use for the particle. The effect changes between particles such as the orientation for smoke particles or the color for potion break"),new V("DX","path-dx").requireValue("path",[!0]).setTooltip("Offset in the X direction, used as the Red value for some particles"),new V("DY","path-dy").requireValue("path",[!0]).setTooltip("Offset in the Y direction, used as the Green value for some particles"),new V("DZ","path-dz").requireValue("path",[!0]).setTooltip("Offset in the Z direction, used as the Blue value for some particles"),new V("Amount","path-amount",1).requireValue("path",[!0]).setTooltip('Number of particles to play per point. For "Spell mob" and "Spell mob ambient" particles, set to 0 to control the particle color'),new V("Speed","path-speed",.1).requireValue("path",[!0]).setTooltip("Speed of the particle. For some particles controls other parameters, such as size")],summaryItems:["group","color","linger","velocity","spread","angle","amount","correction","homing"]},!0)}};c(Bo,"new",()=>new Bo);let Hl=Bo;const zo=class zo extends L{constructor(){super({name:"Projectile",description:"Launches a projectile that applies child components on hit. The target supplied will be the struck target",data:[new k("Projectile","projectile",Np,"Arrow").setTooltip("The type of projectile to fire"),new _("Flaming","flaming",!1).setTooltip("Whether to make the launched projectiles on fire"),new k("Cost","cost",["None","All","One"],"None").setTooltip(`The item cost of the skill. "One" will only charge the player 1 item of it's type, whereas "All" will charge 1 for each fired projectile`),new ue("Item Override").requireValue("projectile",["Egg","Ender pearl","Snowball","Splash potion","Thrown exp bottle","Trident"]),new _("Override item","override-item",!1).setTooltip("Whether to override the item display of the projectile"),new k("Material","material",()=>[...Me()],"Snowball").requireValue("projectile",["Egg","Ender pearl","Snowball","Splash potion","Thrown exp bottle","Trident"]).requireValue("override-item",[!0]).setTooltip("The material to use for the projectile"),new _("Enchanted","enchanted",!1).requireValue("projectile",["Egg","Ender pearl","Snowball","Splash potion","Thrown exp bottle","Trident"]).requireValue("override-item",[!0]).setTooltip("Whether to apply the enchanted glint in the item"),new G("Durability","durability",0).requireValue("projectile",["Egg","Ender pearl","Snowball","Splash potion","Thrown exp bottle","Trident"]).requireValue("override-item",[!0]).setTooltip("The durability to be reduced from the item used for the projectile"),new G("CustomModelData","custom-model-data",0).requireValue("projectile",["Egg","Ender pearl","Snowball","Splash potion","Thrown exp bottle","Trident"]).requireValue("override-item",[!0]).setTooltip("The CustomModelData of the item used for the projectile"),...Pr(),...Cr(),...xt(),...Ht(!0)],preview:[new G("Refresh period","period",5).setTooltip("How many ticks to wait before refreshing the preview, recalculating targets and the location of the particle effects"),new ue("Particles at target"),new _("Particles at target","per-target",!1).setTooltip("Displays particles at the location of the current targets"),new k("Particle","per-target-particle",Je,"Crit").setTooltip("The type of particle to display").requireValue("per-target",[!0]),new k("Material","per-target-material",()=>[...Me()],"Arrow").requireValue("per-target-particle",["Item crack","Item"]).requireValue("per-target",[!0]).setTooltip("The material to use for the particles"),new k("Material","per-target-material",()=>[...Ge()],"Dirt").requireValue("per-target-particle",["Block crack","Block dust","Block","Falling dust","Block marker"]).requireValue("per-target",[!0]).setTooltip("The block to use for the particles"),new G("Durability","per-target-durability",0).requireValue("per-target-particle",["Item crack","Item"]).requireValue("per-target",[!0]).setTooltip("The durability to be reduced from the item used to make the particles"),new G("CustomModelData","per-target-type",0).requireValue("per-target-particle",["Item crack","Item"]).requireValue("per-target",[!0]).setTooltip("The CustomModelData of the item used to make the particles"),new we("Dust Color","per-target-dust-color","#FF0000").requireValue("per-target-particle",["Redstone","Dust","Dust color transition"]).requireValue("per-target",[!0]).setTooltip("The color of the dust particles in hex RGB"),new we("Final Dust Color","per-target-final-dust-color","#FF0000").requireValue("per-target-particle",["Dust color transition"]).requireValue("per-target",[!0]).setTooltip("The color to transition to, in hex RGB"),new V("Dust Size","per-target-dust-size",1).requireValue("per-target-particle",["Redstone","Dust","Dust color transition"]).requireValue("per-target",[!0]).setTooltip("The size of the dust particles"),new G("Effect Data","per-target-data").requireValue("per-target-particle",["Smoke","Ender Signal","Mobspawner Flames","Potion Break","Sculk charge"]).requireValue("per-target",[!0]).setTooltip("The data value to use for the particle. The effect changes between particles such as the orientation for smoke particles or the color for potion break"),new V("DX","per-target-dx").requireValue("per-target",[!0]).setTooltip("Offset in the X direction, used as the Red value for some particles"),new V("DY","per-target-dy").requireValue("per-target",[!0]).setTooltip("Offset in the Y direction, used as the Green value for some particles"),new V("DZ","per-target-dz").requireValue("per-target",[!0]).setTooltip("Offset in the Z direction, used as the Blue value for some particles"),new V("Amount","per-target-amount",1).requireValue("per-target",[!0]).setTooltip('Number of particles to play per point. For "Spell mob" and "Spell mob ambient" particles, set to 0 to control the particle color'),new V("Speed","per-target-speed",.1).requireValue("per-target",[!0]).setTooltip("Speed of the particle. For some particles controls other parameters, such as size"),new k("Arrangement","per-target-arrangement",["Sphere","Circle","Hemisphere"],"Sphere").requireValue("per-target",[!0]).setTooltip("The arrangement to use for the particles. Circle is a 2D circle, Hemisphere is half a 3D sphere, and Sphere is a 3D sphere"),new k("Circle Direction","per-target-direction",["XY","XZ","YZ"],"XZ").requireValue("per-target-arrangement",["Circle"]).requireValue("per-target",[!0]).setTooltip("The orientation of the circle. XY and YZ are vertical circles while XZ is a horizontal circle"),new b("Radius","per-target-radius",.5).requireValue("per-target",[!0]).setTooltip("The radius of the arrangement in blocks"),new _("Increase size by hitbox","per-target-hitbox",!0).requireValue("per-target",[!0]).setTooltip("Increases the 'radius' parameter by the size of the target's hitbox"),new b("Points","per-target-particles",20).requireValue("per-target",[!0]).setTooltip("The amount of points that conform the chosen arrangement"),new ue("Path Preview"),new _("Path Preview","path",!1).setTooltip("Displays particles through the paths of the projectiles"),new V("Steps per particle","path-steps",2).setTooltip("How many collision steps to run between each particle display").requireValue("path",[!0]),new k("Particle","path-particle",Je,"Crit").setTooltip("The type of particle to display").requireValue("path",[!0]),new k("Material","path-material",()=>[...Me()],"Arrow").requireValue("path-particle",["Item crack","Item"]).requireValue("path",[!0]).setTooltip("The material to use for the particles"),new k("Material","path-material",()=>[...Ge()],"Dirt").requireValue("path-particle",["Block crack","Block dust","Block","Falling dust","Block marker"]).requireValue("path",[!0]).setTooltip("The block to use for the particles"),new G("Durability","path-durability",0).requireValue("path-particle",["Item crack","Item"]).requireValue("path",[!0]).setTooltip("The durability to be reduced from the item used to make the particles"),new G("CustomModelData","path-type",0).requireValue("path-particle",["Item crack","Item"]).requireValue("path",[!0]).setTooltip("The CustomModelData of the item used to make the particles"),new we("Dust Color","path-dust-color","#FF0000").requireValue("path-particle",["Redstone","Dust","Dust color transition"]).requireValue("path",[!0]).setTooltip("The color of the dust particles in hex RGB"),new we("Final Dust Color","path-final-dust-color","#FF0000").requireValue("path-particle",["Dust color transition"]).requireValue("path",[!0]).setTooltip("The color to transition to, in hex RGB"),new V("Dust Size","path-dust-size",1).requireValue("path-particle",["Redstone","Dust","Dust color transition"]).requireValue("path",[!0]).setTooltip("The size of the dust particles"),new G("Effect Data","path-data").requireValue("path-particle",["Smoke","Ender Signal","Mobspawner Flames","Potion Break","Sculk charge"]).requireValue("path",[!0]).setTooltip("The data value to use for the particle. The effect changes between particles such as the orientation for smoke particles or the color for potion break"),new V("DX","path-dx").requireValue("path",[!0]).setTooltip("Offset in the X direction, used as the Red value for some particles"),new V("DY","path-dy").requireValue("path",[!0]).setTooltip("Offset in the Y direction, used as the Green value for some particles"),new V("DZ","path-dz").requireValue("path",[!0]).setTooltip("Offset in the Z direction, used as the Blue value for some particles"),new V("Amount","path-amount",1).requireValue("path",[!0]).setTooltip('Number of particles to play per point. For "Spell mob" and "Spell mob ambient" particles, set to 0 to control the particle color'),new V("Speed","path-speed",.1).requireValue("path",[!0]).setTooltip("Speed of the particle. For some particles controls other parameters, such as size")],summaryItems:["projectile","flaming","cost","particle","amount","spread","dust-color","effect-key","correction","homing"]},!0)}};c(zo,"new",()=>new zo);let Bl=zo;const Wo=class Wo extends L{constructor(){super({name:"Purge",description:"Purges the target of positive potion effects or statuses",data:[new k("Potion","potion",Lp,void 0,!0).setTooltip("The potion effect to remove from the target, if any"),new k("Status","status",["All","Absorb","Invincible"],["All"],!0).setTooltip("The status to remove from the target, if any")],summaryItems:["potion","status"]},!1)}};c(Wo,"new",()=>new Wo);let zl=Wo;const Uo=class Uo extends L{constructor(){super({name:"Push",description:"Pushes the target relative to the caster. This will do nothing if used with the caster as the target. Positive numbers apply knockback while negative numbers pull them in",data:[new k("Type","type",["Fixed","Inverse","Scaled"],"Fixed").setTooltip("How to scale the speed based on relative position. Fixed does the same speed to all targets. Inverse pushes enemies farther away faster. Scaled pushes enemies closer faster"),new b("Speed","speed",3,1).setTooltip("How fast to push the target away. Use a negative value to pull them closer"),new B("Source","source","none").setTooltip("The source to push/pull from. This should be a key used in a Remember Targets mechanic. If no targets are remembered, this will default to the caster")],summaryItems:["type","speed"]},!1)}};c(Uo,"new",()=>new Uo);let Wl=Uo;const jo=class jo extends L{constructor(){super({name:"Remember Targets",description:"Stores the current targets for later use under a specified key",data:[new B("Key","key","target").setTooltip('The unique key to store the targets under. The "Remember" target will use this key to apply effects to the targets later on')],summaryItems:["key"]},!1)}};c(jo,"new",()=>new jo);let Ul=jo;const Go=class Go extends L{constructor(){super({name:"Repeat",description:"Applies child components multiple times. When it applies them is determined by the delay (seconds before the first application) and period (seconds between successive applications)",data:[new b("Repetitions","repetitions",3).setTooltip("How many times to activate child components"),new V("Period","period",1).setTooltip("The time in seconds between each time applying child components"),new V("Delay","delay").setTooltip("The initial delay before starting to apply child components"),new _("Stop on Fail","stop-on-fail",!1).setTooltip("Whether to stop the repeat task early if the effects fail")],summaryItems:["repetitions","period","delay","stop-on-fail"]},!0)}};c(Go,"new",()=>new Go);let jl=Go;const Yo=class Yo extends L{constructor(){super({name:"Signal Emit",description:"Send a custom signal to all target that can be reused and processed separately.",data:[new B("Signal","signal").setTooltip("The name of signal will be emit."),new _("Self-handling","handler",!1).setTooltip(`
If true, the signal will be sent to the caster itself and the target are the current targets.
 If false, a signal is sent to each target and the target is caster`),new Qe("Arguments","argument").setTooltip("Arguments used for signal processing. One value per line. The value will be stored in value api-arg[<index>]. The first value will be specially stored at api-arg")],summaryItems:["signal","handler","argument"]},!1)}};c(Yo,"new",()=>new Yo);let Gl=Yo;const Xo=class Xo extends L{constructor(){super({name:"Skill cast",description:"Make target cast other skill. Applicable to players only!",data:[new k("Cast mode","mode",["All","First","Random"],"All").setTooltip("Choose which skills to cast (excluding unavailable skills)."),new _("Force cast","force",!1).setTooltip("True if player will cast regardless of whether they have that skill or not"),new Qe("Skills","skills").setTooltip('The list of skills.Each skill can come with the level like "example skill:3". If player has skill, level will is available level. Else, level is 1.')],summaryItems:["mode","force","skills"]},!1)}};c(Xo,"new",()=>new Xo);let Yl=Xo;const Ko=class Ko extends L{constructor(){super({name:"Sound",description:"Plays a sound at the target's location",data:[new k("Sound","sound",()=>["Custom",...xp()],"Ambient Cave").setTooltip("The sound clip to play. Select 'Custom' to enter custom sounds from your resource pack"),new B("Custom sound name","custom","myrp:some_sound").requireValue("sound",["Custom"]).setTooltip("Namespaced key of your custom sound"),new b("Volume","volume",100).setTooltip("The volume of the sound as a percentage. Numbers above 100 will not get any louder, but will be heard from a farther distance"),new b("Pitch","pitch",1).setTooltip("The pitch of the sound as a numeric speed multiplier between 0.5 and 2")],summaryItems:["sound","volume","pitch"]},!1)}};c(Ko,"new",()=>new Ko);let Xl=Ko;const Zo=class Zo extends L{constructor(){super({name:"Stat",description:'Gives a player bonus stat temporarily. All available <a href="https://github.com/promcteam/proskillapi/wiki/attributes#attribute-stats">attribute stats</a>',data:[new B("Stat","key","health").setTooltip("The name of the stat to add to"),new k("Operation","operation",["ADD_NUMBER","MULTIPLY_PERCENTAGE"],"ADD_NUMBER").setTooltip("The operation on the original value by amount, ADD_NUMBER: Scalar adding, MULTIPLY_PERCENTAGE: Multiply the value by amount"),new b("Amount","amount",5,2).setTooltip("The amount to use with the operation"),new b("Seconds","seconds",3).setTooltip("How long in seconds to give the stat to the player"),new _("Stackable","stackable").setTooltip("Whether applying multiple times stacks the effects")],summaryItems:["key","operation","amount","seconds"]})}};c(Zo,"new",()=>new Zo);let Kl=Zo;const Mo=class Mo extends L{constructor(){super({name:"Status",description:"Applies a status effect to the target for a duration",data:[new k("Status","status",["Absorb","Curse","Disarm","Invincible","Invulnerable","Root","Silence","Stun","Bypass Negative"],"Stun").setTooltip("The status to apply"),new b("Duration","duration",3,1).setTooltip("How long in seconds to apply the status")],summaryItems:["status","duration"]})}};c(Mo,"new",()=>new Mo);let Zl=Mo;const Jo=class Jo extends L{constructor(){super({name:"Summon",description:"Summons a mob on each target. Child components will start off targeting the mob so you can add effects to it. Hostile mobs may attack the caster",data:[new k("Type","type",qu,"Zombie"),new B("Name","name","{player}'s Minion").setTooltip("The displayed name of the wolf. Use {player} to embed the caster's name"),new b("Health","health",10).setTooltip("The starting health of the mob"),new b("Amount","amount",1).setTooltip("How many mobs to summon")],summaryItems:["type","name","amount"]},!0)}};c(Jo,"new",()=>new Jo);let Ml=Jo;const Qo=class Qo extends L{constructor(){super({name:"Taunt",description:"Draws aggro of targeted creatures. Regular mobs are set to attack the caster. The Spigot/Bukkit API for this was not functional on older versions, so it may not work on older servers. For MythicMobs, this uses their aggro system using the amount chosen below",data:[new b("Amount","amount",1).setTooltip("The amount of aggro to apply if MythicMobs is active. Use negative amounts to reduce aggro")],summaryItems:["amount"]},!1)}};c(Qo,"new",()=>new Qo);let Jl=Qo;const er=class er extends L{constructor(){super({name:"Throw",description:"Throws entities off of the target's head and targets them for child components",data:[new k("Relative","relative",["Target","Caster","Thrown"],"Caster").setTooltip('Determines what is considered "forward". Target uses the direction the target is facing, Caster uses the direction the caster is facing, Thrown uses the direction of the entity to be thrown'),new b("Speed","speed",2).setTooltip("The speed to give the target in the direction they are facing")],summaryItems:["relative","speed"]},!0)}};c(er,"new",()=>new er);let Ql=er;const tr=class tr extends L{constructor(){super({name:"Trigger",description:"Listens for a trigger on the current targets for a duration",data:[new k("Trigger","trigger",()=>Object.values(Ke(Qc)).map(e=>e.name),"Death").setTooltip("The trigger to listen for"),new b("Duration","duration",5).setTooltip("How long to listen to the trigger for"),new _("Stackable","stackable",!0).setTooltip("Whether different players (or the same player) can listen to the same target at the same time"),new _("Once","once",!0).setTooltip("Whether the trigger should only be used once each cast. When false, the trigger can execute as many times as it happens for the duration"),new k("Material","material",Hp,["Any"],!0).requireValue("trigger",["Block Break","Block Place"]).setTooltip("The type of block expected to be handled"),new G("Data","data",-1).requireValue("trigger",["Block Break","Block Place"]).setTooltip("The expected data value of the block (-1 for any data value)"),new k("Crouch","crouch",["Crouch","Dont crouch","Both"],"Crouch").requireValue("trigger",["Left Click","Right Click"]).setTooltip("If the player has to be crouching in order for this trigger to function"),new k("Type","type",["Start Crouching","Stop Crouching","Both"],"Start Crouching").requireValue("trigger",["Crouch"]).setTooltip("Whether you want to apply components when crouching or not crouching"),new k("Drop multiple","drop multiple",["True","False","Ignore"],"Ignore").requireValue("trigger",["Drop Item"]).setTooltip("Whether the player has to drop multiple items or a single item"),new k("Type","type",Kc,["Fall"],!0).requireValue("trigger",["Environment Damage"]).setTooltip("The source of damage to apply for"),new _("Cancel swap","cancel",!0).requireValue("trigger",["Item Swap"]).setTooltip("True cancels the item swap. False allows the item swap"),new V("Min Distance","min-distance",0).requireValue("trigger",["Land"]).setTooltip("The minimum distance the player should fall before effects activating"),new k("Type","type",Ar,"Any").requireValue("trigger",["Launch"]).setTooltip("The type of projectile that should be launched"),new k("Type","type",["Both","Melee","Projectile"],"Both").requireValue("trigger",["Physical Damage","Took Physical Damage"]).setTooltip("The type of damage dealt"),new B("Category","category","").requireValue("trigger",["Skill Damage","Took Skill Damage"]).setTooltip("The type of skill damage to apply for. Leave this empty to apply to all skill damage"),new _("Target Listen Target","target",!0).requireValue("trigger",["Physical Damage","Skill Damage","Took Physical Damage","Took Skill Damage"]).setTooltip("True makes children target the target that has been listened to. False makes children target the entity fighting the target entity"),new V("Min Damage","dmg-min",0).requireValue("trigger",["Physical Damage","Skill Damage","Took Physical Damage","Took Skill Damage"]).setTooltip("The minimum damage that needs to be dealt"),new V("Max Damage","dmg-max",999).requireValue("trigger",["Physical Damage","Skill Damage","Took Physical Damage","Took Skill Damage"]).setTooltip("The maximum damage that needs to be dealt"),new B("Signal","signal","").requireValue("trigger",["Signal"]).setTooltip("The name of signal will be listened to")],summaryItems:["trigger","duration","once","signal"]},!0)}};c(tr,"new",()=>new tr);let eu=tr;const ar=class ar extends L{constructor(){super({name:"Value Add",description:"Adds to a stored value under a unique key for the caster. If the value wasn't set before, this will set the value to the given amount",data:[new B("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new b("Amount","amount",1).setTooltip("The amount to add to the value"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","amount","save"]},!1)}};c(ar,"new",()=>new ar);let tu=ar;const sr=class sr extends L{constructor(){super({name:"Value Attribute",description:"Loads a player's attribute count for a specific attribute as a stored value to be used in other mechanics",data:[new B("Key","key","attribute").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new k("Attribute","attribute",Tt.getAttributeNames,"Vitality",!1).setTooltip("The attribute you are loading the value of"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","attribute","save"]},!1)}};c(sr,"new",()=>new sr);let au=sr;const or=class or extends L{constructor(){super({name:"Value Copy",description:"Copies a stored value from the caster to the target or vice versa",data:[new B("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new B("Destination","destination","value").setTooltip("The key to copy the original value to"),new _("To target","to-target",!0).setTooltip("Whether to copy the value to the target or from the target to the caster"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","destination","to-target","save"]},!1)}};c(or,"new",()=>new or);let su=or;const rr=class rr extends L{constructor(){super({name:"Value Distance",description:"Stores the distance between the target and the caster into a value",data:[new B("Key","key","attribute").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","save"]},!1)}};c(rr,"new",()=>new rr);let ou=rr;const nr=class nr extends L{constructor(){super({name:"Value Divide",description:"Divides a stored value under a unique key for the caster. If the value wasn't set before, this will not do anything",data:[new B("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new b("Divisor","divisor",1).setTooltip("The amount to divide the value by"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","divisor","save"]},!1)}};c(nr,"new",()=>new nr);let ru=nr;const ir=class ir extends L{constructor(){super({name:"Value Health",description:"Stores the target's current health as a value under a given key for the caster",data:[new B("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new k("Type","type",["Current","Max","Missing","Percent"],"Current").setTooltip("Current provides the health the target has, max provides their total health, missing provides how much health they have lost, and percent is the ratio of health to total health"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","type","save"]},!1)}};c(ir,"new",()=>new ir);let nu=ir;const lr=class lr extends L{constructor(){super({name:"Value Location",description:"Loads the first target's current location into a stored value for use at a later time",data:[new B("Key","key","location").setTooltip("The unique key to store the location under. This key can be used in place of attribute values to use the stored value"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","save"]},!1)}};c(lr,"new",()=>new lr);let iu=lr;const ur=class ur extends L{constructor(){super({name:"Value Load",description:"If there is a value already stored on the account, that value will be retrieved and then be used as a normal value.",data:[new B("Key","key").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value."),new _("Override","override",!0).setTooltip("If false and the current value have been set, nothing will change."),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","override","save"]},!1)}};c(ur,"new",()=>new ur);let lu=ur;const cr=class cr extends L{constructor(){super({name:"Value Lore",description:"Loads a value from a held item's lore into a stored value under the given unique key for the caster",data:[new B("Key","key","lore").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new k("Hand","hand",["Main","Offhand"],"Main").setTooltip("The hand to check for the item. Offhand items are MC 1.9+ only"),new B("Regex","regex","Damage: {value}").setTooltip("The regex string to look for, using {value} as the number to store. If you do not know about regex, consider looking it up on Wikipedia or avoid using major characters such as [ ] { } ( ) . + ? * ^ \\ |"),new b("Multiplier","multiplier",1).setTooltip("The multiplier for the acquired value. If you want the value to remain unchanged, leave this value at 1"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","hand","regex","multiplier","save"]},!1)}};c(cr,"new",()=>new cr);let uu=cr;const pr=class pr extends L{constructor(){super({name:"Value Lore Slot",description:"Loads a value from an item's lore into a stored value under the given unique key for the caster",data:[new B("Key","key","lore").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new G("Slot","slot",9).setTooltip("The slot of the inventory to fetch the item from. Slots 0-8 are the hotbar, 9-35 are the main inventory, 36-39 are armor, and 40 is the offhand slot"),new B("Regex","regex","Damage: {value}").setTooltip("The regex string to look for, using {value} as the number to store. If you do not know about regex, consider looking it up on Wikipedia or avoid using major characters such as [ ] { } ( ) . + ? * ^ \\ |"),new b("Multiplier","multiplier",1).setTooltip("The multiplier for the acquired value. If you want the value to remain unchanged, leave this value at 1"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","slot","regex","multiplier","save"]},!1)}};c(pr,"new",()=>new pr);let cu=pr;const hr=class hr extends L{constructor(){super({name:"Value Mana",description:"Stores the target player's current mana as a value under a given key for the caster",data:[new B("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new k("Type","type",["Current","Max","Missing","Percent"],"Current").setTooltip("Current provides the mana the target has, max provides their total mana, missing provides how much mana they have lost, and percent is the ratio of health to total mana"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","type","save"]},!1)}};c(hr,"new",()=>new hr);let pu=hr;const dr=class dr extends L{constructor(){super({name:"Value Multiply",description:"Multiplies a stored value under a unique key for the caster. If the value wasn't set before, this will not do anything",data:[new B("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new b("Multiplier","multiplier",1).setTooltip("The amount to multiply the value by"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","multiplier","save"]},!1)}};c(dr,"new",()=>new dr);let hu=dr;const mr=class mr extends L{constructor(){super({name:"Value Placeholder",description:"Uses a placeholder string and stores it as a value for the caster",data:[new B("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new k("Type","type",["Number","String"],"Number").setTooltip("The type of value to store. Number values require numeric placeholders. String values can be used in messages or commands"),new B("Placeholder","placeholder","{value}").setTooltip("The placeholder string to use. Can contain multiple placeholders if using the String type"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","type","placeholder","save"]},!1)}};c(mr,"new",()=>new mr);let du=mr;const fr=class fr extends L{constructor(){super({name:"Value Random",description:"Stores a specified value under a given key for the caster",data:[new B("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new _("Integer","integer",!1).setTooltip("Whether to only generate integer values"),new k("Type","type",["Normal","Triangular"],"Normal").setTooltip("The type of random to use. Triangular favors numbers in the middle, similar to rolling two dice"),new b("Min","min").setTooltip("The minimum value it can be"),new b("Max","max").setTooltip("The maximum value it can be"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","type","min","max","save"]},!1)}};c(fr,"new",()=>new fr);let mu=fr;const gr=class gr extends L{constructor(){super({name:"Value Rotation",description:"Stores a value as the rotation between the target's look direction and a remembered location as a source. The caster is used if no targets are remembered or no source key is passed",data:[new B("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new B("Source","source","").setTooltip("The key to use as the source location for the rotation. If left empty, the caster is used"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","source","save"]},!1)}};c(gr,"new",()=>new gr);let fu=gr;const wr=class wr extends L{constructor(){super({name:"Value Round",description:"Rounds a stored value under a unique key for the caster. If the value wasn't set before, this will not do anything",data:[new B("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new k("Type","type",["Round","Ceiling","Floor"],"Round").setTooltip("The type of rounding to use. Round rounds to the nearest integer, ceiling rounds up, and floor rounds down"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","type","save"]},!1)}};c(wr,"new",()=>new wr);let gu=wr;const yr=class yr extends L{constructor(){super({name:"Value Set",description:"Stores a specified value under a given key for the caster",data:[new B("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new b("Value","value",1).setTooltip("The value to store under the key"),new _("Save","save",!1).setTooltip("If true, save the key value to persistent value. Persistent value is not lost when the player leaves the server and is stored separately on each account")],summaryItems:["key","value","save"]},!1)}};c(yr,"new",()=>new yr);let wu=yr;const Tr=class Tr extends L{constructor(){super({name:"Warp",description:"Warps the target relative to their forward direction. Use negative numbers to go in the opposite direction (e.g. negative forward will cause the target to warp backwards)",data:[new _("Through Walls","walls").setTooltip("Whether to allow the target to teleport through walls"),new _("Open Spaces Only","open",!0).setTooltip("Whether to only allow teleporting to open spaces. The side-effect of open spaces is the warp position is set to the middle of the block instead of the complete relative position"),new ue("Position"),new b("Forward","forward",3,1).setTooltip("How far forward in blocks to teleport. A negative value teleports backwards"),new b("Upward","upward").setTooltip("How far upward in blocks to teleport. A negative value teleports downward"),new b("Right","right").setTooltip("How far to the right in blocks to teleport. A negative value teleports to the left"),...$t()],preview:[...et()],summaryItems:["walls","forward","upward","right","preserve"]},!1)}};c(Tr,"new",()=>new Tr);let yu=Tr;const vr=class vr extends L{constructor(){super({name:"Warp Location",description:"Warps the target to a specified location",data:[new B('World (or "current")',"world","current").setTooltip("The name of the world that the location is in"),new V("X","x",0).setTooltip("The X-coordinate of the desired position"),new V("Y","y",0).setTooltip("The Y-coordinate of the desired position"),new V("Z","z",0).setTooltip("The Z-coordinate of the desired position"),...$t()],preview:[...et()],summaryItems:["world","x","y","z","preserve"]},!1)}};c(vr,"new",()=>new vr);let Tu=vr;const br=class br extends L{constructor(){super({name:"Warp Random",description:"Warps the target in a random direction the given distance",data:[new _("Only Horizontal","horizontal",!0).setTooltip("Whether to limit the random position to the horizontal plane"),new _("Through Walls","walls",!1).setTooltip("Whether to allow the target to teleport through walls"),new b("Distance","distance",3,1).setTooltip("The max distance in blocks to teleport"),...$t()],summaryItems:["horizontal","walls","distance","preserve"]},!1)}};c(br,"new",()=>new br);let vu=br;const kr=class kr extends L{constructor(){super({name:"Warp Swap",description:"Switches the location of the caster and the target. If multiple targets are provided, this takes the first one",data:[...$t()],summaryItems:["preserve"]})}};c(kr,"new",()=>new kr);let bu=kr;const _r=class _r extends L{constructor(){super({name:"Warp Target",description:"Warps either the target or the caster to the other. This does nothing when the target is the caster",data:[new k("Type","type",["Caster to Target","Target to Caster"],"Caster to Target").setTooltip("The direction to warp the involved targets"),...$t()],summaryItems:["type","preserve"]})}};c(_r,"new",()=>new _r);let ku=_r;const Ir=class Ir extends L{constructor(){super({name:"Warp Value",description:"Warps all targets to a location remembered using the Value Location mechanic",data:[new B("Key","key","location").setTooltip("The unique key the location is stored under. This should be the same key used in the Value Location mechanic"),...$t()],preview:[...et()],summaryItems:["key","preserve"]},!1)}};c(Ir,"new",()=>new Ir);let _u=Ir;const Dr=class Dr extends L{constructor(){super({name:"Wolf",description:"Summons a wolf on each target for a duration. Child components will start off targeting the wolf so you can add effects to it. You can also give it its own skillset, though Cast triggers will not occur",data:[new k("Collar Color","color",Bp,"Black").setTooltip("The color of the collar that the wolf should wear"),new B("Wolf Name","name","{player}'s Wolf").setTooltip("The displayed name of the wolf. Use {player} to embed the caster's name"),new b("Health","health",10).setTooltip("The starting health of the wolf"),new b("Damage","damage",3).setTooltip("The damage dealt by the wolf each attack"),new _("Sitting","sitting",!1).setTooltip("Whether the wolf starts off sitting"),new b("Duration","seconds",10).setTooltip("How long to summon the wolf for"),new b("Amount","amount",1).setTooltip("How many wolves to summon"),new qr("Skills","skills",!0).setTooltip("The skills to give the wolf. Skills are executed at the level of the skill summoning the wolf. Skills needing a Cast trigger will not work"),new _("Silent","silent",!0).setTooltip("Whether the wolf should be silent"),new _("No AI","no_ai",!1).setTooltip("Whether the wolf should be controlled by an AI"),new k("Target","aggro_target",Object.values(Ke(Ur)).map(e=>e.name),"Nearest").setTooltip("The target to aggro on")],summaryItems:["color","name","seconds","amount","aggro_target"]},!0);for(const e of Object.values(Ke(Ur))){this.data.push(new ue("Target: "+e.name).requireValue("aggro_target",[e.name]));const t=new e.component;for(let a of t.data)a=a.clone(),this.data.push(a.requireValue("aggro_target",[e.name]))}}};c(Dr,"new",()=>new Dr);let Iu=Dr;const lt=s=>[new G("Refresh period",s+"-period",5).requireValue(s,[!0]).setTooltip("How many ticks to wait before refreshing the preview, recalculating targets and the location of the particle effects"),new k("Particle",s+"-particle",Je,"Crit").setTooltip("The type of particle to display").requireValue(s,[!0]),new k("Material",s+"-material",()=>[...Me()],"Arrow").requireValue(s+"-particle",["Item crack","Item"]).requireValue(s,[!0]).setTooltip("The material to use for the particles"),new k("Material",s+"-material",()=>[...Ge()],"Dirt").requireValue(s+"-particle",["Block crack","Block dust","Block","Falling dust","Block marker"]).requireValue(s,[!0]).setTooltip("The block to use for the particles"),new G("Durability",s+"-durability",0).requireValue(s+"-particle",["Item crack","Item"]).requireValue(s,[!0]).setTooltip("The durability to be reduced from the item used to make the particles"),new G("CustomModelData",s+"-type",0).requireValue(s+"-particle",["Item crack","Item"]).requireValue(s,[!0]).setTooltip("The CustomModelData of the item used to make the particles"),new we("Dust Color",s+"-dust-color","#FF0000").requireValue(s+"-particle",["Redstone","Dust","Dust color transition"]).requireValue(s,[!0]).setTooltip("The color of the dust particles in hex RGB"),new we("Final Dust Color",s+"-final-dust-color","#FF0000").requireValue(s+"-particle",["Dust color transition"]).requireValue(s,[!0]).setTooltip("The color to transition to, in hex RGB"),new V("Dust Size",s+"-dust-size",1).requireValue(s+"-particle",["Redstone","Dust","Dust color transition"]).requireValue(s,[!0]).setTooltip("The size of the dust particles"),new G("Effect Data",s+"-data").requireValue(s+"-particle",["Smoke","Ender Signal","Mobspawner Flames","Potion Break","Sculk charge"]).requireValue(s,[!0]).setTooltip("The data value to use for the particle. The effect changes between particles such as the orientation for smoke particles or the color for potion break"),new V("DX",s+"-dx").requireValue(s,[!0]).setTooltip("Offset in the X direction, used as the Red value for some particles"),new V("DY",s+"-dy").requireValue(s,[!0]).setTooltip("Offset in the Y direction, used as the Green value for some particles"),new V("DZ",s+"-dz").requireValue(s,[!0]).setTooltip("Offset in the Z direction, used as the Blue value for some particles"),new V("Amount",s+"-amount",1).requireValue(s,[!0]).setTooltip('Number of particles to play per point. For "Spell mob" and "Spell mob ambient" particles, set to 0 to control the particle color'),new V("Speed",s+"-speed",.1).requireValue(s,[!0]).setTooltip("Speed of the particle. For some particles controls other parameters, such as size")],td=()=>{Qc.set({ATTR_CHANGE:{name:"Attribute Change",component:Zr},BLOCK_BREAK:{name:"Block Break",component:Mr},BLOCK_PLACE:{name:"Block Place",component:Jr},CAST:{name:"Cast",component:Qr},CHAT:{name:"Chat",component:en},CLEANUP:{name:"Cleanup",component:tn},CROUCH:{name:"Crouch",component:sn},DEATH:{name:"Death",component:on},ENTITY_TARGET:{name:"Entity Target",component:nn},HEAL:{name:"Heal",component:fn},INIT:{name:"Initialize",component:gn},KILL:{name:"Kill",component:yn},LAND:{name:"Land",component:Tn},LEFT_CLICK:{name:"Left Click",component:bn},RIGHT_CLICK:{name:"Right Click",component:Sn},MOVE:{name:"Move",component:kn},PROJ_HIT:{name:"Projectile Hit",component:In},PROJ_LAUNCH:{name:"Projectile Launch",alias:"Launch",component:vn},PROJ_TICK:{name:"Projectile Tick",component:Dn},SHIELD:{name:"Shield",component:Pn},SIGNAL:{name:"Signal",component:$n},SKILL_CAST:{name:"Skill Cast",component:An},TELEPORT:{name:"Teleport",component:qn},WORLD_CHANGE:{name:"World Change",component:Fn},ARMOR_EQUIP:{name:"Armor Equip",component:Kr,section:"Item"},CONSUME:{name:"Consume",component:an,section:"Item"},DROP_ITEM:{name:"Drop Item",component:rn,section:"Item"},ITEM_SWAP:{name:"Item Swap",component:wn,section:"Item"},FISHING:{name:"Fishing",component:un,section:"Fishing"},FISHING_BITE:{name:"Fishing Bite",component:cn,section:"Fishing"},FISHING_FAIL:{name:"Fishing Fail",component:pn,section:"Fishing"},FISHING_GRAB:{name:"Fishing Grab",component:hn,section:"Fishing"},FISHING_GROUND:{name:"Fishing Ground",component:dn,section:"Fishing"},FISHING_REEL:{name:"Fishing Reel",component:mn,section:"Fishing"},ENV_DAMAGE:{name:"Environment Damage",component:ln,section:"Damage"},PHYS_DAMAGE:{name:"Physical Damage",component:_n,section:"Damage"},TOOK_PHYS:{name:"Took Physical Damage",component:En,section:"Damage"},SKILL_DAMAGE:{name:"Skill Damage",component:Vn,section:"Damage"},TOOK_SKILL:{name:"Took Skill Damage",component:Cn,section:"Damage"}}),Ur.set({AREA:{name:"Area",component:On},CONE:{name:"Cone",component:Rn},LINEAR:{name:"Linear",component:Nn},LOCATION:{name:"Location",component:Ln},NEAREST:{name:"Nearest",component:xn},OFFSET:{name:"Offset",component:Bn},PLAYER:{name:"Player",component:Hn},REMEMBER:{name:"Remember",component:zn},SELF:{name:"Self",component:Wn},SINGLE:{name:"Single",component:Un},WORLD:{name:"World",component:jn}}),Wp.set({ALTITUDE:{name:"Altitude",component:Gn},ARMOR:{name:"Armor",component:Yn},ATTRIBUTE:{name:"Attribute",component:Xn},BIOME:{name:"Biome",component:Kn},BLOCK:{name:"Block",component:Zn},BURNING:{name:"Burning",component:Mn},CEILING:{name:"Ceiling",component:Jn},CHANCE:{name:"Chance",component:Qn},CLASS:{name:"Class",component:ei},CLASS_LEVEL:{name:"Class Level",component:ti},COMBAT:{name:"Combat",component:ai},CROUCH:{name:"Crouch",component:si},DIRECTION:{name:"Direction",component:oi},DISTANCE:{name:"Distance",component:ri},ELEVATION:{name:"Elevation",component:ni},ELSE:{name:"Else",component:ii},ENTITY_TYPE:{name:"Entity Type",component:li},FIRE:{name:"Fire",component:ui},FLAG:{name:"Flag",component:ci},FOOD:{name:"Food",component:pi},GROUND:{name:"Ground",component:hi},HEALTH:{name:"Health",component:di},INVENTORY:{name:"Inventory",component:fi},ITEM:{name:"Item",component:mi},LIGHT:{name:"Light",component:gi},MANA:{name:"Mana",component:wi},MONEY:{name:"Money",component:yi},MOUNTED:{name:"Mounted",component:Ti},MOUNTING:{name:"Mounting",component:vi},MYTHICMOB_TYPE:{name:"MythicMob Type",component:bi},NAME:{name:"Name",component:ki},OFFHAND:{name:"Offhand",component:_i},PERMISSION:{name:"Permission",component:Ii},POTION:{name:"Potion",component:Di},SKILL_LEVEL:{name:"Skill Level",component:Si},SLOT:{name:"Slot",component:Ai},STATUS:{name:"Status",component:Vi},TIME:{name:"Time",component:qi},TOOL:{name:"Tool",component:Ei},VALUE:{name:"Value",component:Ci},VALUETEXT:{name:"Value Text",component:Pi},WATER:{name:"Water",component:$i},WEATHER:{name:"Weather",component:Fi},WORLD:{name:"World",component:Oi},YAW:{name:"Yaw",component:Ri}}),Up.set({ABORT_SKILL:{name:"Abort Skill",component:Ni},ARMOR:{name:"Armor",component:Li},ARMOR_STAND:{name:"Armor Stand",component:xi},ARMOR_STAND_POSE:{name:"Armor Stand Pose",component:Hi},ARMOR_STAND_REMOVE:{name:"Armor Stand Remove",component:Bi},ATTRIBUTE:{name:"Attribute",component:zi},BLOCK:{name:"Block",component:Wi},BUFF:{name:"Buff",component:Ui},CANCEL:{name:"Cancel",component:ji},CHANNEL:{name:"Channel",component:Yi},CLEANSE:{name:"Cleanse",component:Xi},COMMAND:{name:"Command",component:Ki},COOLDOWN:{name:"Cooldown",component:Zi},DAMAGE:{name:"Damage",component:Mi},DAMAGE_BUFF:{name:"Damage Buff",component:Ji},DAMAGE_LORE:{name:"Damage Lore",component:Qi},DEFENSE_BUFF:{name:"Defense Buff",component:el},DELAY:{name:"Delay",component:tl},DISGUISE:{name:"Disguise",component:al},DURABILITY:{name:"Durability",component:sl},EXPERIENCE:{name:"Experience",component:ol},EXPLOSION:{name:"Explosion",component:rl},FIRE:{name:"Fire",component:nl},FOOD:{name:"Food",component:cl},FORGET_TARGETS:{name:"Forget Targets",component:pl},GKCOOLDOWN:{name:"GKCooldown",component:hl},GKSUMMON:{name:"GKSummon",component:dl},HEAL:{name:"Heal",component:ml},HEALTH_SET:{name:"Health Set",component:fl},HELD_ITEM:{name:"Held Item",component:gl},IMMUNITY:{name:"Immunity",component:wl},INTERRUPT:{name:"Interrupt",component:yl},INVISIBILITY:{name:"Invisibility",component:Tl},ITEM:{name:"Item",component:vl},ITEM_DROP:{name:"Item Drop",component:bl},ITEM_PROJECTILE:{name:"Item Projectile",component:kl},ITEM_REMOVE:{name:"Item Remove",component:_l},LAUNCH:{name:"Launch",component:Il},LAUNCH_TO:{name:"Launch To",component:Dl},LIGHTNING:{name:"Lightning",component:Sl},MANA:{name:"Mana",component:Al},MESSAGE:{name:"Message",component:Vl},MINE:{name:"Mine",component:ql},MONEY:{name:"Money",component:El},MOUNT:{name:"Mount",component:Cl},PASSIVE:{name:"Passive",component:Nl},PERMISSION:{name:"Permission",component:Ll},POTION:{name:"Potion",component:xl},POTION_PROJECTILE:{name:"Potion Projectile",component:Hl},PROJECTILE:{name:"Projectile",component:Bl},PURGE:{name:"Purge",component:zl},PUSH:{name:"Push",component:Wl},REMEMBER_TARGETS:{name:"Remember Targets",component:Ul},REPEAT:{name:"Repeat",component:jl},SIGNAL_EMIT:{name:"Signal Emit",component:Gl},SKILL_CAST:{name:"Skill Cast",component:Yl},SOUND:{name:"Sound",component:Xl},STAT:{name:"Stat",component:Kl},STATUS:{name:"Status",component:Zl},SUMMON:{name:"Summon",component:Ml},TAUNT:{name:"Taunt",component:Jl},THROW:{name:"Throw",component:Ql},TRIGGER:{name:"Trigger",component:eu},WOLF:{name:"Wolf",component:Iu},CANCEL_EFFECT:{name:"Cancel Effect",component:Gi,section:"Particle"},PARTICLE:{name:"Particle",component:Pl,section:"Particle"},PARTICLE_ANIMATION:{name:"Particle Animation",component:$l,section:"Particle"},PARTICLE_EFFECT:{name:"Particle Effect",component:Fl,section:"Particle"},PARTICLE_IMAGE:{name:"Particle Image",component:Ol,section:"Particle"},PARTICLE_PROJECTILE:{name:"Particle Projectile",component:Rl,section:"Particle"},FLAG:{name:"Flag",component:il,section:"Flag"},FLAG_CLEAR:{name:"Flag Clear",component:ll,section:"Flag"},FLAG_TOGGLE:{name:"Flag Toggle",component:ul,section:"Flag"},VALUE_ADD:{name:"Value Add",component:tu,section:"Value"},VALUE_ATTRIBUTE:{name:"Value Attribute",component:au,section:"Value"},VALUE_COPY:{name:"Value Copy",component:su,section:"Value"},VALUE_DISTANCE:{name:"Value Distance",component:ou,section:"Value"},VALUE_DIVIDE:{name:"Value Divide",component:ru,section:"Value"},VALUE_HEALTH:{name:"Value Health",component:nu,section:"Value"},VALUE_LOAD:{name:"Value Load",component:lu,section:"Value"},VALUE_LOCATION:{name:"Value Location",component:iu,section:"Value"},VALUE_LORE:{name:"Value Lore",component:uu,section:"Value"},VALUE_LORE_SLOT:{name:"Value Lore Slot",component:cu,section:"Value"},VALUE_MANA:{name:"Value Mana",component:pu,section:"Value"},VALUE_MULTIPLY:{name:"Value Multiply",component:hu,section:"Value"},VALUE_PLACEHOLDER:{name:"Value Placeholder",component:du,section:"Value"},VALUE_RANDOM:{name:"Value Random",component:mu,section:"Value"},VALUE_ROTATION:{name:"Value Rotation",component:fu,section:"Value"},VALUE_ROUND:{name:"Value Round",component:gu,section:"Value"},VALUE_SET:{name:"Value Set",component:wu,section:"Value"},WARP:{name:"Warp",component:yu,section:"Warp"},WARP_LOC:{name:"Warp Location",component:Tu,section:"Warp"},WARP_RANDOM:{name:"Warp Random",component:vu,section:"Warp"},WARP_SWAP:{name:"Warp Swap",component:bu,section:"Warp"},WARP_TARGET:{name:"Warp Target",component:ku,section:"Warp"},WARP_VALUE:{name:"Warp Value",component:_u,section:"Warp"}}),jp.set(!0)};function sc(s){return Object.prototype.toString.call(s)==="[object Date]"}function Du(s,e){if(s===e||s!==s)return()=>s;const t=typeof s;if(t!==typeof e||Array.isArray(s)!==Array.isArray(e))throw new Error("Cannot interpolate values of different type");if(Array.isArray(s)){const a=e.map((r,i)=>Du(s[i],r));return r=>a.map(i=>i(r))}if(t==="object"){if(!s||!e)throw new Error("Object cannot be null");if(sc(s)&&sc(e)){s=s.getTime(),e=e.getTime();const i=e-s;return o=>new Date(s+o*i)}const a=Object.keys(e),r={};return a.forEach(i=>{r[i]=Du(s[i],e[i])}),i=>{const o={};return a.forEach(l=>{o[l]=r[l](i)}),o}}if(t==="number"){const a=e-s;return r=>s+r*a}throw new Error(`Cannot interpolate ${t} values`)}function ad(s,e={}){const t=hp(s);let a,r=s;function i(o,l){if(s==null)return t.set(s=o),Promise.resolve();r=o;let n=a,u=!1,{delay:p=0,duration:w=400,easing:h=zc,interpolate:m=Du}=jt(jt({},e),l);if(w===0)return n&&(n.abort(),n=null),t.set(s=r),Promise.resolve();const y=vp()+p;let T;return a=bp(C=>{if(C<y)return!0;u||(T=m(s,o),typeof w=="function"&&(w=w(s,o)),u=!0),n&&(n.abort(),n=null);const d=C-y;return d>w?(t.set(s=o),!1):(t.set(s=T(h(d/w))),!0)}),a.promise}return{set:i,update:(o,l)=>i(o(r,s),l),subscribe:t.subscribe}}function sd(s){let e,t=s[0].msg+"",a;return{c(){e=new gp(!1),a=Ce(),this.h()},l(r){e=wp(r,!1),a=Ce(),this.h()},h(){e.a=a},m(r,i){e.m(t,r,i),P(r,a,i)},p(r,i){i&1&&t!==(t=r[0].msg+"")&&e.p(t)},i:fe,o:fe,d(r){r&&(v(a),e.d())}}}function od(s){let e,t,a;const r=[s[2]];var i=s[0].component.src;function o(l,n){let u={};for(let p=0;p<r.length;p+=1)u=jt(u,r[p]);return n!==void 0&&n&4&&(u=jt(u,Ju(r,[Qu(l[2])]))),{props:u}}return i&&(e=Gt(i,o(s))),{c(){e&&J(e.$$.fragment),t=Ce()},l(l){e&&ae(e.$$.fragment,l),t=Ce()},m(l,n){e&&Q(e,l,n),P(l,t,n),a=!0},p(l,n){if(n&1&&i!==(i=l[0].component.src)){if(e){Te();const u=e;F(u.$$.fragment,1,0,()=>{ee(u,1)}),ve()}i?(e=Gt(i,o(l,n)),J(e.$$.fragment),E(e.$$.fragment,1),Q(e,t.parentNode,t)):e=null}else if(i){const u=n&4?Ju(r,[Qu(l[2])]):{};e.$set(u)}},i(l){a||(e&&E(e.$$.fragment,l),a=!0)},o(l){e&&F(e.$$.fragment,l),a=!1},d(l){l&&v(t),e&&ee(e,l)}}}function oc(s){let e,t,a;return{c(){e=S("div"),this.h()},l(r){e=A(r,"DIV",{class:!0,role:!0,tabindex:!0}),Z(e).forEach(v),this.h()},h(){f(e,"class","_toastBtn pe svelte-95rq8t"),f(e,"role","button"),f(e,"tabindex","0")},m(r,i){P(r,e,i),t||(a=[R(e,"click",s[4]),R(e,"keydown",s[8])],t=!0)},p:fe,d(r){r&&v(e),t=!1,be(a)}}}function rd(s){let e,t,a,r,i,o,l,n,u,p;const w=[od,sd],h=[];function m(T,C){return T[0].component?0:1}a=m(s),r=h[a]=w[a](s);let y=s[0].dismissable&&oc(s);return{c(){e=S("div"),t=S("div"),r.c(),i=W(),y&&y.c(),o=W(),l=S("progress"),this.h()},l(T){e=A(T,"DIV",{role:!0,class:!0});var C=Z(e);t=A(C,"DIV",{class:!0});var d=Z(t);r.l(d),d.forEach(v),i=U(C),y&&y.l(C),o=U(C),l=A(C,"PROGRESS",{class:!0}),Z(l).forEach(v),C.forEach(v),this.h()},h(){f(t,"class","_toastMsg svelte-95rq8t"),Ie(t,"pe",s[0].component),f(l,"class","_toastBar svelte-95rq8t"),l.value=s[1],f(e,"role","status"),f(e,"class","_toastItem svelte-95rq8t"),Ie(e,"pe",s[0].pausable)},m(T,C){P(T,e,C),D(e,t),h[a].m(t,null),D(e,i),y&&y.m(e,null),D(e,o),D(e,l),n=!0,u||(p=[R(e,"mouseenter",s[9]),R(e,"mouseleave",s[6])],u=!0)},p(T,[C]){let d=a;a=m(T),a===d?h[a].p(T,C):(Te(),F(h[d],1,1,()=>{h[d]=null}),ve(),r=h[a],r?r.p(T,C):(r=h[a]=w[a](T),r.c()),E(r,1),r.m(t,null)),(!n||C&1)&&Ie(t,"pe",T[0].component),T[0].dismissable?y?y.p(T,C):(y=oc(T),y.c(),y.m(e,o)):y&&(y.d(1),y=null),(!n||C&2)&&(l.value=T[1]),(!n||C&1)&&Ie(e,"pe",T[0].pausable)},i(T){n||(E(r),n=!0)},o(T){F(r),n=!1},d(T){T&&v(e),h[a].d(),y&&y.d(),u=!1,be(p)}}}function zr(s,e="undefined"){return typeof s===e}function nd(s,e,t){let a,{item:r}=e,i=r.initial,o=i,l=!1,n={},u;const p=ad(r.initial,{duration:r.duration,easing:zc});de(s,p,g=>t(1,a=g));function w(){Yr.pop(r.id)}function h(){(a===1||a===0)&&w()}function m(){!l&&a!==i&&(p.set(a,{duration:0}),l=!0)}function y(){if(l){const g=r.duration,I=g-g*((a-o)/(i-o));p.set(i,{duration:I}).then(h),l=!1}}function T(g=document){if(zr(g.hidden))return;const I=()=>g.hidden?m():y(),N="visibilitychange";g.addEventListener(N,I),u=()=>g.removeEventListener(N,I),I()}Su(T),Au(()=>{zr(r.onpop,"function")&&r.onpop(r.id),u&&u()});const C=g=>{g instanceof KeyboardEvent&&["Enter"," "].includes(g.key)&&w()},d=()=>{r.pausable&&m()};return s.$$set=g=>{"item"in g&&t(0,r=g.item)},s.$$.update=()=>{if(s.$$.dirty&1&&(zr(r.progress)||t(0,r.next=r.progress,r)),s.$$.dirty&131&&i!==r.next&&(t(7,i=r.next),o=a,l=!1,p.set(i).then(h)),s.$$.dirty&1&&r.component){const{props:g={},sendIdTo:I}=r.component;t(2,n={...g,...I&&{[I]:r.id}})}},[r,a,n,p,w,m,y,i,C,d]}class id extends Fe{constructor(e){super(),Oe(this,e,nd,rd,$e,{item:0})}}function rc(s,e,t){const a=s.slice();return a[4]=e[t],a}function nc(s,e){let t,a,r,i,o,l,n,u,p=fe,w;return a=new id({props:{item:e[4]}}),{key:s,first:null,c(){t=S("li"),J(a.$$.fragment),r=W(),this.h()},l(h){t=A(h,"LI",{class:!0,style:!0});var m=Z(t);ae(a.$$.fragment,m),r=U(m),m.forEach(v),this.h()},h(){var h;f(t,"class",i=Ru((h=e[4].classes)==null?void 0:h.join(" "))+" svelte-1u812xz"),f(t,"style",o=ic(e[4].theme)),this.first=t},m(h,m){P(h,t,m),Q(a,t,null),D(t,r),w=!0},p(h,m){var T;e=h;const y={};m&1&&(y.item=e[4]),a.$set(y),(!w||m&1&&i!==(i=Ru((T=e[4].classes)==null?void 0:T.join(" "))+" svelte-1u812xz"))&&f(t,"class",i),(!w||m&1&&o!==(o=ic(e[4].theme)))&&f(t,"style",o)},r(){u=t.getBoundingClientRect()},f(){_p(t),p(),Ip(t,u)},a(){p(),p=Dp(t,u,Sp,{duration:200})},i(h){w||(E(a.$$.fragment,h),h&&De(()=>{w&&(n&&n.end(1),l=Et(t,me,e[4].intro),l.start())}),w=!0)},o(h){F(a.$$.fragment,h),l&&l.invalidate(),h&&(n=Ct(t,Gp,{})),w=!1},d(h){h&&v(t),ee(a),h&&n&&n.end()}}}function ld(s){let e,t=[],a=new Map,r,i=Pe(s[0]);const o=l=>l[4].id;for(let l=0;l<i.length;l+=1){let n=rc(s,i,l),u=o(n);a.set(u,t[l]=nc(u,n))}return{c(){e=S("ul");for(let l=0;l<t.length;l+=1)t[l].c();this.h()},l(l){e=A(l,"UL",{class:!0});var n=Z(e);for(let u=0;u<t.length;u+=1)t[u].l(n);n.forEach(v),this.h()},h(){f(e,"class","_toastContainer svelte-1u812xz")},m(l,n){P(l,e,n);for(let u=0;u<t.length;u+=1)t[u]&&t[u].m(e,null);r=!0},p(l,[n]){if(n&1){i=Pe(l[0]),Te();for(let u=0;u<t.length;u+=1)t[u].r();t=Rt(t,n,o,1,l,i,a,e,kp,nc,null,rc);for(let u=0;u<t.length;u+=1)t[u].a();ve()}},i(l){if(!r){for(let n=0;n<i.length;n+=1)E(t[n]);r=!0}},o(l){for(let n=0;n<t.length;n+=1)F(t[n]);r=!1},d(l){l&&v(e);for(let n=0;n<t.length;n+=1)t[n].d()}}}function ic(s){return s?Object.keys(s).reduce((e,t)=>`${e}${t}:${s[t]};`,""):void 0}function ud(s,e,t){let a;de(s,Yr,l=>t(3,a=l));let{options:r={}}=e,{target:i="default"}=e,o=[];return s.$$set=l=>{"options"in l&&t(1,r=l.options),"target"in l&&t(2,i=l.target)},s.$$.update=()=>{s.$$.dirty&6&&Yr._init(i,r),s.$$.dirty&12&&t(0,o=a.filter(l=>l.target===i))},[o,r,i,a]}class cd extends Fe{constructor(e){super(),Oe(this,e,ud,ld,$e,{options:1,target:2})}}const pd=!1,hd=["skill.gkpixel.com","synthesis.travja.dev"],Ft=`


~~~~~


`,dd=async({url:s})=>{if(ah(),sh(),td(),!s.host.includes("localhost")&&s.searchParams.has("migrationData")){np({url:s.searchParams.get("migrationData")||void 0}).then(e=>{const t=e.split(Ft)[0],a=e.split(Ft)[1],r=e.split(Ft)[2],i=e.split(Ft)[3],o=e.split(Ft)[4];Bu(t).forEach(l=>{localStorage.setItem("sapi.skill."+l.name,jr.stringify(l,{lineWidth:0,aliasDuplicateObjects:!1}))}),Bu(a).forEach(l=>{localStorage.setItem("sapi.class."+l.name,jr.stringify(l,{lineWidth:0,aliasDuplicateObjects:!1}))}),localStorage.setItem("skillFolders",r),localStorage.setItem("classFolders",i),localStorage.setItem("attribs",o),window.location.href=`https://${hd}${ft}`}).catch(console.error);return}},Fm=Object.freeze(Object.defineProperty({__proto__:null,load:dd,ssr:pd},Symbol.toStringTag,{value:"Module"}));function md(s){let e,t,a,r="Upload File",i,o,l="Select File",n,u,p,w,h='<span class="svelte-8b3mcy">OR</span>',m,y,T,C="Import from URL",d,g,I,N,O="Import",X,x;return{c(){e=S("div"),t=S("div"),a=S("div"),a.textContent=r,i=W(),o=S("label"),o.textContent=l,n=W(),u=S("input"),p=W(),w=S("div"),w.innerHTML=h,m=W(),y=S("div"),T=S("div"),T.textContent=C,d=W(),g=S("input"),I=W(),N=S("div"),N.textContent=O,this.h()},l(q){e=A(q,"DIV",{class:!0});var H=Z(e);t=A(H,"DIV",{class:!0});var se=Z(t);a=A(se,"DIV",{"data-svelte-h":!0}),re(a)!=="svelte-d6qc1n"&&(a.textContent=r),i=U(se),o=A(se,"LABEL",{for:!0,class:!0,"data-svelte-h":!0}),re(o)!=="svelte-rsmggv"&&(o.textContent=l),n=U(se),u=A(se,"INPUT",{id:!0,type:!0,class:!0}),se.forEach(v),p=U(H),w=A(H,"DIV",{class:!0,"data-svelte-h":!0}),re(w)!=="svelte-1vhlovm"&&(w.innerHTML=h),m=U(H),y=A(H,"DIV",{class:!0});var Y=Z(y);T=A(Y,"DIV",{"data-svelte-h":!0}),re(T)!=="svelte-kmd8jc"&&(T.textContent=C),d=U(Y),g=A(Y,"INPUT",{class:!0}),I=U(Y),N=A(Y,"DIV",{class:!0,tabindex:!0,role:!0,"data-svelte-h":!0}),re(N)!=="svelte-9wtjih"&&(N.textContent=O),Y.forEach(v),H.forEach(v),this.h()},h(){f(o,"for","file-upload"),f(o,"class","button"),f(u,"id","file-upload"),f(u,"type","file"),f(u,"class","hidden svelte-8b3mcy"),u.multiple=!0,f(t,"class","option svelte-8b3mcy"),f(w,"class","or svelte-8b3mcy"),f(g,"class","svelte-8b3mcy"),f(N,"class","button"),f(N,"tabindex","0"),f(N,"role","button"),f(y,"class","option svelte-8b3mcy"),f(e,"class","options svelte-8b3mcy")},m(q,H){P(q,e,H),D(e,t),D(t,a),D(t,i),D(t,o),D(t,n),D(t,u),D(e,p),D(e,w),D(e,m),D(e,y),D(y,T),D(y,d),D(y,g),it(g,s[1]),D(y,I),D(y,N),X||(x=[R(u,"change",s[4]),R(g,"input",s[5]),R(N,"click",s[3]),R(N,"keypress",s[6])],X=!0)},p(q,H){H&2&&g.value!==q[1]&&it(g,q[1])},d(q){q&&v(e),X=!1,be(x)}}}function fd(s){let e,t;return e=new Vt({props:{open:!0,$$slots:{default:[md]},$$scope:{ctx:s}}}),e.$on("close",s[2]),{c(){J(e.$$.fragment)},l(a){ae(e.$$.fragment,a)},m(a,r){Q(e,a,r),t=!0},p(a,[r]){const i={};r&131&&(i.$$scope={dirty:r,ctx:a}),e.$set(i)},i(a){t||(E(e.$$.fragment,a),t=!0)},o(a){F(e.$$.fragment,a),t=!1},d(a){ee(e,a)}}}function gd(s,e,t){let a,r;const i=()=>{t(1,a=t(0,r=void 0)),ep(!1)},o=()=>{a&&(a.startsWith("http")||t(1,a="https://"+a),np({url:a}).then(p=>{i(),Yp(p)}).catch(console.error))};function l(){r=this.files,t(0,r)}function n(){a=this.value,t(1,a)}const u=p=>p.key==="Enter"&&o();return s.$$.update=()=>{if(s.$$.dirty&1&&r&&r.length>0)for(const p of r)p.name.indexOf(".yml")!=-1&&(tp(p),i())},[r,a,i,o,l,n,u]}class wd extends Fe{constructor(e){super(),Oe(this,e,gd,fd,$e,{})}}function lc(s){let e,t,a=s[0].substring(0,1).toUpperCase()+s[0].substring(1)+"",r,i,o,l;return{c(){e=S("div"),t=pe("分享 "),r=pe(a),this.h()},l(n){e=A(n,"DIV",{class:!0,tabindex:!0,role:!0,title:!0});var u=Z(e);t=he(u,"分享 "),r=he(u,a),u.forEach(v),this.h()},h(){f(e,"class","chip share svelte-374drf"),f(e,"tabindex","0"),f(e,"role","button"),f(e,"title",i="Share "+(s[0].substring(0,1).toUpperCase()+s[0].substring(1)))},m(n,u){P(n,e,u),D(e,t),D(e,r),o||(l=[R(e,"click",Xe(s[1])),R(e,"keypress",s[5])],o=!0)},p(n,u){u&1&&a!==(a=n[0].substring(0,1).toUpperCase()+n[0].substring(1)+"")&&Le(r,a),u&1&&i!==(i="Share "+(n[0].substring(0,1).toUpperCase()+n[0].substring(1)))&&f(e,"title",i)},d(n){n&&v(e),o=!1,be(l)}}}function yd(s){let e,t,a,r='<span class="material-symbols-rounded">menu</span>',i,o,l,n,u,p="從檔案匯入",w,h,m,y=s[0]&&lc(s);return{c(){e=S("div"),t=S("nav"),a=S("div"),a.innerHTML=r,i=W(),o=S("div"),l=W(),n=S("div"),u=S("div"),u.textContent=p,w=W(),y&&y.c(),this.h()},l(T){e=A(T,"DIV",{class:!0});var C=Z(e);t=A(C,"NAV",{class:!0});var d=Z(t);a=A(d,"DIV",{class:!0,tabindex:!0,role:!0,"data-svelte-h":!0}),re(a)!=="svelte-hdnmnk"&&(a.innerHTML=r),i=U(d),o=A(d,"DIV",{}),Z(o).forEach(v),l=U(d),n=A(d,"DIV",{class:!0});var g=Z(n);u=A(g,"DIV",{class:!0,tabindex:!0,role:!0,title:!0,"data-svelte-h":!0}),re(u)!=="svelte-196wrwh"&&(u.textContent=p),w=U(g),y&&y.l(g),g.forEach(v),d.forEach(v),C.forEach(v),this.h()},h(){f(a,"class","chip hamburger svelte-374drf"),f(a,"tabindex","0"),f(a,"role","button"),f(u,"class","chip import svelte-374drf"),f(u,"tabindex","0"),f(u,"role","button"),f(u,"title","Import Data"),f(n,"class","transfer svelte-374drf"),f(t,"class","svelte-374drf"),f(e,"class","nav-wrap svelte-374drf")},m(T,C){P(T,e,C),D(e,t),D(t,a),D(t,i),D(t,o),D(t,l),D(t,n),D(n,u),D(n,w),y&&y.m(n,null),h||(m=[R(a,"click",Xe(ap)),R(a,"keypress",s[3]),R(u,"click",Xe(s[2])),R(u,"keypress",s[4])],h=!0)},p(T,[C]){T[0]?y?y.p(T,C):(y=lc(T),y.c(),y.m(n,null)):y&&(y.d(1),y=null)},i:fe,o:fe,d(T){T&&v(e),y&&y.d(),h=!1,be(m)}}}function Td(s,e,t){let a;de(s,Xp,u=>t(0,a=u));const r=()=>{let u=Ke(Yt);if(!u)return;let p=jr.stringify({[u.name]:u.serializeYaml()},{lineWidth:0,aliasDuplicateObjects:!1});ih(p).then(w=>{var h;(h=navigator==null?void 0:navigator.clipboard)==null||h.writeText(w),window.open(w)}).catch(w=>console.error(w))},i=()=>{ep(!0)};return[a,r,i,u=>{u.key==="Enter"&&(u.stopPropagation(),ap())},u=>{u.key==="Enter"&&(u.stopPropagation(),i())},u=>{u.key==="Enter"&&(u.stopPropagation(),r())}]}class vd extends Fe{constructor(e){super(),Oe(this,e,Td,yd,$e,{})}}function uc(s){let e,t="登入",a,r;return{c(){e=S("div"),e.textContent=t,this.h()},l(i){e=A(i,"DIV",{class:!0,tabindex:!0,role:!0,style:!0,title:!0,"data-svelte-h":!0}),re(e)!=="svelte-c2gjef"&&(e.textContent=t),this.h()},h(){f(e,"class","chip svelte-1p9qe63"),f(e,"tabindex","0"),f(e,"role","button"),ne(e,"background-color","#0079d9"),f(e,"title","登入 GKIDMS")},m(i,o){P(i,e,o),a||(r=[R(e,"click",Xe(op)),R(e,"keypress",s[3])],a=!0)},d(i){i&&v(e),a=!1,be(r)}}}function cc(s){let e,t,a,r,i=s[0].profile.given_name+"",o,l,n,u="登出",p,w;return{c(){e=S("img"),a=W(),r=S("div"),o=pe(i),l=W(),n=S("div"),n.textContent=u,this.h()},l(h){e=A(h,"IMG",{style:!0,src:!0,alt:!0,class:!0}),a=U(h),r=A(h,"DIV",{style:!0,class:!0});var m=Z(r);o=he(m,i),m.forEach(v),l=U(h),n=A(h,"DIV",{class:!0,tabindex:!0,role:!0,style:!0,title:!0,"data-svelte-h":!0}),re(n)!=="svelte-11zhfr6"&&(n.textContent=u),this.h()},h(){ne(e,"margin","auto"),ne(e,"margin-right","10px"),ne(e,"height","35px"),Nu(e.src,t=s[0].profile.avatar)||f(e,"src",t),f(e,"alt","Avatar"),f(e,"class","svelte-1p9qe63"),ne(r,"margin","auto"),ne(r,"margin-right","20px"),f(r,"class","svelte-1p9qe63"),f(n,"class","chip svelte-1p9qe63"),f(n,"tabindex","0"),f(n,"role","button"),ne(n,"background-color","#d92800"),f(n,"title","登出 GKIDMS")},m(h,m){P(h,e,m),P(h,a,m),P(h,r,m),D(r,o),P(h,l,m),P(h,n,m),p||(w=[R(n,"click",Xe(rp)),R(n,"keypress",s[4])],p=!0)},p(h,m){m&1&&!Nu(e.src,t=h[0].profile.avatar)&&f(e,"src",t),m&1&&i!==(i=h[0].profile.given_name+"")&&Le(o,i)},d(h){h&&(v(e),v(a),v(r),v(l),v(n)),p=!1,be(w)}}}function bd(s){let e,t,a,r="GKPixel©",i,o,l="技能編輯器™",n,u,p,w=new Date().getFullYear()+"",h,m,y,T,C,d,g=s[0]==null&&uc(s),I=s[0]!=null&&cc(s);return{c(){e=S("div"),t=S("div"),a=S("h1"),a.textContent=r,i=W(),o=S("h2"),o.textContent=l,n=W(),u=S("div"),p=pe("© ProMCTeam and GKPixelTeam "),h=pe(w),m=W(),y=S("div"),g&&g.c(),T=W(),I&&I.c(),this.h()},l(N){e=A(N,"DIV",{id:!0,class:!0});var O=Z(e);t=A(O,"DIV",{class:!0,tabindex:!0,role:!0});var X=Z(t);a=A(X,"H1",{class:!0,"data-svelte-h":!0}),re(a)!=="svelte-jvwokd"&&(a.textContent=r),i=U(X),o=A(X,"H2",{class:!0,"data-svelte-h":!0}),re(o)!=="svelte-1xnlyzh"&&(o.textContent=l),n=U(X),u=A(X,"DIV",{class:!0});var x=Z(u);p=he(x,"© ProMCTeam and GKPixelTeam "),h=he(x,w),x.forEach(v),X.forEach(v),m=U(O),y=A(O,"DIV",{class:!0});var q=Z(y);g&&g.l(q),T=U(q),I&&I.l(q),q.forEach(v),O.forEach(v),this.h()},h(){f(a,"class","accent svelte-1p9qe63"),f(o,"class","svelte-1p9qe63"),f(u,"class","copy svelte-1p9qe63"),f(t,"class","home svelte-1p9qe63"),f(t,"tabindex","0"),f(t,"role","button"),f(y,"class","socials svelte-1p9qe63"),f(e,"id","header"),f(e,"class","svelte-1p9qe63")},m(N,O){P(N,e,O),D(e,t),D(t,a),D(t,i),D(t,o),D(t,n),D(t,u),D(u,p),D(u,h),D(e,m),D(e,y),g&&g.m(y,null),D(y,T),I&&I.m(y,null),C||(d=[R(t,"click",s[1]),R(t,"keypress",s[2])],C=!0)},p(N,[O]){N[0]==null?g||(g=uc(N),g.c(),g.m(y,T)):g&&(g.d(1),g=null),N[0]!=null?I?I.p(N,O):(I=cc(N),I.c(),I.m(y,null)):I&&(I.d(1),I=null)},i:fe,o:fe,d(N){N&&v(e),g&&g.d(),I&&I.d(),C=!1,be(d)}}}function kd(s,e,t){let a=null;oh.getUser().then(n=>{t(0,a=n),console.log(n)});const r=()=>St(`${ft}/`),i=n=>n.key==="Enter"&&St(`${ft}/`),o=n=>{n.key==="Enter"&&(n.stopPropagation(),op())},l=n=>{n.key==="Enter"&&(n.stopPropagation(),rp())};return t(0,a=null),[a,r,i,o,l]}class _d extends Fe{constructor(e){super(),Oe(this,e,kd,bd,$e,{})}}function pc(s){let e,t,a,r,i="save",o,l,n,u,p="content_copy",w,h,m,y,T="delete",C,d,g,I=s[2]instanceof ot&&hc(s);return{c(){e=S("div"),I&&I.c(),t=W(),a=S("div"),r=S("span"),r.textContent=i,l=W(),n=S("div"),u=S("span"),u.textContent=p,h=W(),m=S("div"),y=S("span"),y.textContent=T,this.h()},l(N){e=A(N,"DIV",{class:!0});var O=Z(e);I&&I.l(O),t=U(O),a=A(O,"DIV",{tabindex:!0,role:!0,class:!0,title:!0});var X=Z(a);r=A(X,"SPAN",{class:!0,"data-svelte-h":!0}),re(r)!=="svelte-m7sczt"&&(r.textContent=i),X.forEach(v),l=U(O),n=A(O,"DIV",{tabindex:!0,role:!0,class:!0,title:!0});var x=Z(n);u=A(x,"SPAN",{class:!0,"data-svelte-h":!0}),re(u)!=="svelte-1umu3ov"&&(u.textContent=p),x.forEach(v),h=U(O),m=A(O,"DIV",{tabindex:!0,role:!0,class:!0,title:!0});var q=Z(m);y=A(q,"SPAN",{class:!0,"data-svelte-h":!0}),re(y)!=="svelte-1m77sfb"&&(y.textContent=T),q.forEach(v),O.forEach(v),this.h()},h(){f(r,"class","material-symbols-rounded"),f(a,"tabindex","0"),f(a,"role","button"),f(a,"class","download svelte-2gsmqy"),f(a,"title",o="Save "+(s[2].dataType.substring(0,1).toUpperCase()+s[2].dataType.substring(1))),f(u,"class","material-symbols-rounded"),f(n,"tabindex","0"),f(n,"role","button"),f(n,"class","clone svelte-2gsmqy"),f(n,"title",w="Clone "+(s[2].dataType.substring(0,1).toUpperCase()+s[2].dataType.substring(1))),f(y,"class","material-symbols-rounded"),f(m,"tabindex","0"),f(m,"role","button"),f(m,"class","delete svelte-2gsmqy"),f(m,"title",C="Delete "+(s[2].dataType.substring(0,1).toUpperCase()+s[2].dataType.substring(1))),f(e,"class","buttons svelte-2gsmqy")},m(N,O){P(N,e,O),I&&I.m(e,null),D(e,t),D(e,a),D(a,r),D(e,l),D(e,n),D(n,u),D(e,h),D(e,m),D(m,y),d||(g=[R(a,"click",Xe(pt(s[15]))),R(a,"keypress",Xe(pt(s[16]))),R(n,"click",Xe(pt(s[17]))),R(n,"keypress",Xe(pt(s[18]))),R(m,"click",Xe(pt(s[19]))),R(m,"keypress",Xe(pt(s[20])))],d=!0)},p(N,O){N[2]instanceof ot?I?I.p(N,O):(I=hc(N),I.c(),I.m(e,t)):I&&(I.d(1),I=null),O&4&&o!==(o="Save "+(N[2].dataType.substring(0,1).toUpperCase()+N[2].dataType.substring(1)))&&f(a,"title",o),O&4&&w!==(w="Clone "+(N[2].dataType.substring(0,1).toUpperCase()+N[2].dataType.substring(1)))&&f(n,"title",w),O&4&&C!==(C="Delete "+(N[2].dataType.substring(0,1).toUpperCase()+N[2].dataType.substring(1)))&&f(m,"title",C)},d(N){N&&v(e),I&&I.d(),d=!1,be(g)}}}function hc(s){let e,t,a="edit",r;return{c(){e=S("a"),t=S("span"),t.textContent=a,this.h()},l(i){e=A(i,"A",{href:!0,class:!0,title:!0});var o=Z(e);t=A(o,"SPAN",{class:!0,"data-svelte-h":!0}),re(t)!=="svelte-qeheo0"&&(t.textContent=a),o.forEach(v),this.h()},h(){f(t,"class","material-symbols-rounded"),f(e,"href",r=ft+"/skill/"+s[2].name+"/edit"),f(e,"class","edit svelte-2gsmqy"),f(e,"title","Edit Skill")},m(i,o){P(i,e,o),D(e,t)},p(i,o){o&4&&r!==(r=ft+"/skill/"+i[2].name+"/edit")&&f(e,"href",r)},d(i){i&&v(e)}}}function Id(s){var T;let e,t,a=((T=s[2])==null?void 0:T.name)+"",r,i,o,l,n,u="Cancel",p,w,h="Delete",m,y;return{c(){e=S("h3"),t=pe("Do you really want to delete "),r=pe(a),i=pe("?"),o=W(),l=S("div"),n=S("div"),n.textContent=u,p=W(),w=S("div"),w.textContent=h,this.h()},l(C){e=A(C,"H3",{});var d=Z(e);t=he(d,"Do you really want to delete "),r=he(d,a),i=he(d,"?"),d.forEach(v),o=U(C),l=A(C,"DIV",{class:!0});var g=Z(l);n=A(g,"DIV",{class:!0,tabindex:!0,role:!0,"data-svelte-h":!0}),re(n)!=="svelte-1h5bffi"&&(n.textContent=u),p=U(g),w=A(g,"DIV",{class:!0,tabindex:!0,role:!0,"data-svelte-h":!0}),re(w)!=="svelte-uc75g2"&&(w.textContent=h),g.forEach(v),this.h()},h(){f(n,"class","button svelte-2gsmqy"),f(n,"tabindex","0"),f(n,"role","button"),f(w,"class","button modal-delete svelte-2gsmqy"),f(w,"tabindex","0"),f(w,"role","button"),f(l,"class","modal-buttons svelte-2gsmqy")},m(C,d){P(C,e,d),D(e,t),D(e,r),D(e,i),P(C,o,d),P(C,l,d),D(l,n),D(l,p),D(l,w),m||(y=[R(n,"click",s[23]),R(n,"keypress",s[24]),R(w,"click",s[25]),R(w,"keypress",s[26])],m=!0)},p(C,d){var g;d&4&&a!==(a=((g=C[2])==null?void 0:g.name)+"")&&Le(r,a)},d(C){C&&(v(e),v(o),v(l)),m=!1,be(y)}}}function Dd(s){let e,t,a,r,i,o,l,n,u,p,w;const h=s[13].default,m=Wc(h,s,s[28],null);let y=s[2]&&pc(s);function T(d){s[27](d)}let C={$$slots:{default:[Id]},$$scope:{ctx:s}};return s[4]!==void 0&&(C.open=s[4]),l=new Vt({props:C}),Re.push(()=>Be(l,"open",T)),{c(){e=S("div"),m&&m.c(),t=W(),y&&y.c(),o=W(),J(l.$$.fragment),this.h()},l(d){e=A(d,"DIV",{class:!0,draggable:!0,tabindex:!0,role:!0});var g=Z(e);m&&m.l(g),t=U(g),y&&y.l(g),g.forEach(v),o=U(d),ae(l.$$.fragment,d),this.h()},h(){f(e,"class","sidebar-entry svelte-2gsmqy"),f(e,"draggable",a=!!s[2]),f(e,"tabindex","0"),f(e,"role","menuitem"),Ie(e,"over",s[3]),Ie(e,"active",s[2]&&s[5]===s[2]),Ie(e,"in-folder",!!mt.getFolder(s[2]))},m(d,g){P(d,e,g),m&&m.m(e,null),D(e,t),y&&y.m(e,null),P(d,o,g),Q(l,d,g),u=!0,p||(w=[R(e,"dragstart",s[8]),R(e,"drop",Xe(pt(s[9]))),R(e,"dragover",pt(s[10])),R(e,"dragleave",s[21]),R(e,"click",s[14]),R(e,"keypress",s[22])],p=!0)},p(d,[g]){s=d,m&&m.p&&(!u||g&268435456)&&Uc(m,h,s,s[28],u?Gc(h,s[28],g,null):jc(s[28]),null),s[2]?y?y.p(s,g):(y=pc(s),y.c(),y.m(e,null)):y&&(y.d(1),y=null),(!u||g&4&&a!==(a=!!s[2]))&&f(e,"draggable",a),(!u||g&8)&&Ie(e,"over",s[3]),(!u||g&36)&&Ie(e,"active",s[2]&&s[5]===s[2]),(!u||g&4)&&Ie(e,"in-folder",!!mt.getFolder(s[2]));const I={};g&268435476&&(I.$$scope={dirty:g,ctx:s}),!n&&g&16&&(n=!0,I.open=s[4],He(()=>n=!1)),l.$set(I)},i(d){u||(E(m,d),d&&De(()=>{u&&(i&&i.end(1),r=Et(e,s[11],{fn:me,x:s[1]==="left"?-100:100,duration:500,delay:s[6]?0:s[0]}),r.start())}),E(l.$$.fragment,d),u=!0)},o(d){F(m,d),r&&r.invalidate(),d&&(i=Ct(e,me,{x:s[1]==="left"?-100:100,duration:500})),F(l.$$.fragment,d),u=!1},d(d){d&&(v(e),v(o)),m&&m.d(d),y&&y.d(),d&&i&&i.end(),ee(l,d),p=!1,be(w)}}}function Sd(s,e,t){let a,r;de(s,Yt,j=>t(5,a=j)),de(s,Xt,j=>t(6,r=j));let{$$slots:i={},$$scope:o}=e,{delay:l=0}=e,{direction:n="left"}=e,{data:u=void 0}=e,p=!1,w=!1;const h=ht(),m=j=>{if(!u){j.preventDefault();return}At.set(u)},y=()=>{const j=Ke(At);let K;u&&(K=mt.getFolder(u));const le=mt.getFolder(j);if(le&&le.remove(j),K){K.add(j),t(3,p=!1),mt.updateFolders();return}if(j instanceof wt){switch(Ke(Ut)){case vt.CLASSES:{at.addClassFolder(j);break}case vt.SKILLS:{xe.addSkillFolder(j);break}}j.parent=void 0}t(3,p=!1)},T=()=>{const j=Ke(At);u!==j&&t(3,p=!0)},C=(j,K)=>(Ke(Gr)||(K.delay=0),K.fn(j,K)),d=j=>{j&&(j instanceof yt?at.cloneClass(j):j instanceof ot?xe.cloneSkill(j):j instanceof Kp&&Tt.cloneAttribute(j))};function g(j){Yc.call(this,s,j)}const I=()=>zu(u),N=j=>{(j==null?void 0:j.key)==="Enter"&&zu(u)},O=()=>d(u),X=j=>{(j==null?void 0:j.key)==="Enter"&&d(u)},x=j=>{if(j!=null&&j.shiftKey){Wt(u);return}t(4,w=!0)},q=j=>{if((j==null?void 0:j.key)==="Enter"){if(j!=null&&j.shiftKey){Wt(u);return}t(4,w=!0)}},H=()=>t(3,p=!1),se=j=>{j.key==="Enter"&&h("click")},Y=()=>t(4,w=!1),oe=j=>{(j==null?void 0:j.key)==="Enter"&&t(4,w=!1)},ke=()=>Wt(u),Ne=j=>{(j==null?void 0:j.key)==="Enter"&&Wt(u)};function Se(j){w=j,t(4,w)}return s.$$set=j=>{"delay"in j&&t(0,l=j.delay),"direction"in j&&t(1,n=j.direction),"data"in j&&t(2,u=j.data),"$$scope"in j&&t(28,o=j.$$scope)},[l,n,u,p,w,a,r,h,m,y,T,C,d,i,g,I,N,O,X,x,q,H,se,Y,oe,ke,Ne,Se,o]}class gt extends Fe{constructor(e){super(),Oe(this,e,Sd,Dd,$e,{delay:0,direction:1,data:2})}}function dc(s,e,t){const a=s.slice();return a[21]=e[t],a}function mc(s){let e,t=[],a=new Map,r,i,o=Pe(s[0].data);const l=n=>{var u;return(u=n[21])==null?void 0:u.key};for(let n=0;n<o.length;n+=1){let u=dc(s,o,n),p=l(u);a.set(p,t[n]=fc(p,u))}return{c(){e=S("div");for(let n=0;n<t.length;n+=1)t[n].c();this.h()},l(n){e=A(n,"DIV",{class:!0});var u=Z(e);for(let p=0;p<t.length;p+=1)t[p].l(u);u.forEach(v),this.h()},h(){f(e,"class","folder-content svelte-jmliow")},m(n,u){P(n,e,u);for(let p=0;p<t.length;p+=1)t[p]&&t[p].m(e,null);i=!0},p(n,u){u&1&&(o=Pe(n[0].data),Te(),t=Rt(t,u,l,1,n,o,a,e,Sr,fc,null,dc),ve())},i(n){if(!i){for(let u=0;u<o.length;u+=1)E(t[u]);n&&De(()=>{i&&(r||(r=ye(e,Kt,{},!0)),r.run(1))}),i=!0}},o(n){for(let u=0;u<t.length;u+=1)F(t[u]);n&&(r||(r=ye(e,Kt,{},!1)),r.run(0)),i=!1},d(n){n&&v(e);for(let u=0;u<t.length;u+=1)t[u].d();n&&r&&r.end()}}}function Ad(s){let e,t;function a(){return s[20](s[21])}return e=new gt({props:{data:s[21],$$slots:{default:[qd]},$$scope:{ctx:s}}}),e.$on("click",a),{c(){J(e.$$.fragment)},l(r){ae(e.$$.fragment,r)},m(r,i){Q(e,r,i),t=!0},p(r,i){s=r;const o={};i&1&&(o.data=s[21]),i&16777217&&(o.$$scope={dirty:i,ctx:s}),e.$set(o)},i(r){t||(E(e.$$.fragment,r),t=!0)},o(r){F(e.$$.fragment,r),t=!1},d(r){ee(e,r)}}}function Vd(s){let e,t;return e=new Pu({props:{folder:s[21]}}),{c(){J(e.$$.fragment)},l(a){ae(e.$$.fragment,a)},m(a,r){Q(e,a,r),t=!0},p(a,r){const i={};r&1&&(i.folder=a[21]),e.$set(i)},i(a){t||(E(e.$$.fragment,a),t=!0)},o(a){F(e.$$.fragment,a),t=!1},d(a){ee(e,a)}}}function qd(s){let e=s[21].name+"",t,a=s[21].location==="server"?"*":"",r,i;return{c(){t=pe(e),r=pe(a),i=W()},l(o){t=he(o,e),r=he(o,a),i=U(o)},m(o,l){P(o,t,l),P(o,r,l),P(o,i,l)},p(o,l){l&1&&e!==(e=o[21].name+"")&&Le(t,e),l&1&&a!==(a=o[21].location==="server"?"*":"")&&Le(r,a)},d(o){o&&(v(t),v(r),v(i))}}}function fc(s,e){let t,a,r,i,o;const l=[Vd,Ad],n=[];function u(p,w){return p[21]instanceof wt?0:1}return a=u(e),r=n[a]=l[a](e),{key:s,first:null,c(){t=Ce(),r.c(),i=Ce(),this.h()},l(p){t=Ce(),r.l(p),i=Ce(),this.h()},h(){this.first=t},m(p,w){P(p,t,w),n[a].m(p,w),P(p,i,w),o=!0},p(p,w){e=p;let h=a;a=u(e),a===h?n[a].p(e,w):(Te(),F(n[h],1,1,()=>{n[h]=null}),ve(),r=n[a],r?r.p(e,w):(r=n[a]=l[a](e),r.c()),E(r,1),r.m(i.parentNode,i))},i(p){o||(E(r),o=!0)},o(p){F(r),o=!1},d(p){p&&(v(t),v(i)),n[a].d(p)}}}function Ed(s){let e,t,a="folder",r,i,o,l,n,u='<span class="material-symbols-rounded">add</span>',p,w,h='<span class="material-symbols-rounded">edit</span>',m,y,T='<span class="material-symbols-rounded">delete</span>',C,d,g,I,N,O,X,x=s[0].open&&mc(s);return{c(){e=S("div"),t=S("span"),t.textContent=a,r=W(),i=S("span"),o=W(),l=S("div"),n=S("div"),n.innerHTML=u,p=W(),w=S("div"),w.innerHTML=h,m=W(),y=S("div"),y.innerHTML=T,g=W(),x&&x.c(),I=Ce(),this.h()},l(q){e=A(q,"DIV",{class:!0,draggable:!0,tabindex:!0,role:!0});var H=Z(e);t=A(H,"SPAN",{class:!0,"data-svelte-h":!0}),re(t)!=="svelte-1ic1ary"&&(t.textContent=a),r=U(H),i=A(H,"SPAN",{class:!0,contenteditable:!0,tabindex:!0,role:!0}),Z(i).forEach(v),o=U(H),l=A(H,"DIV",{class:!0});var se=Z(l);n=A(se,"DIV",{class:!0,title:!0,tabindex:!0,role:!0,"data-svelte-h":!0}),re(n)!=="svelte-6hjmfl"&&(n.innerHTML=u),p=U(se),w=A(se,"DIV",{class:!0,title:!0,tabindex:!0,role:!0,"data-svelte-h":!0}),re(w)!=="svelte-156gx0"&&(w.innerHTML=h),m=U(se),y=A(se,"DIV",{class:!0,title:!0,tabindex:!0,role:!0,"data-svelte-h":!0}),re(y)!=="svelte-1hdl3cj"&&(y.innerHTML=T),se.forEach(v),H.forEach(v),g=U(q),x&&x.l(q),I=Ce(),this.h()},h(){f(t,"class","material-symbols-rounded folder-icon svelte-jmliow"),f(i,"class","name svelte-jmliow"),f(i,"contenteditable","false"),f(i,"tabindex","0"),f(i,"role","textbox"),s[0].name===void 0&&De(()=>s[13].call(i)),Ie(i,"server",s[0].location==="server"),f(n,"class","icon add svelte-jmliow"),f(n,"title","Add Folder"),f(n,"tabindex","0"),f(n,"role","button"),f(w,"class","icon svelte-jmliow"),f(w,"title","Rename"),f(w,"tabindex","0"),f(w,"role","button"),f(y,"class","icon delete svelte-jmliow"),f(y,"title","Delete Folder"),f(y,"tabindex","0"),f(y,"role","button"),f(l,"class","buttons svelte-jmliow"),f(e,"class","folder svelte-jmliow"),f(e,"draggable","true"),f(e,"tabindex","0"),f(e,"role","menuitem"),Ie(e,"over",s[2])},m(q,H){P(q,e,H),D(e,t),D(e,r),D(e,i),s[11](i),s[0].name!==void 0&&(i.textContent=s[0].name),D(e,o),D(e,l),D(l,n),D(l,p),D(l,w),D(l,m),D(l,y),P(q,g,H),x&&x.m(q,H),P(q,I,H),N=!0,O||(X=[R(i,"blur",s[12]),R(i,"input",s[13]),R(i,"keydown",s[5]),R(n,"click",Xe(s[7])),R(n,"keypress",s[14]),R(w,"click",Xe(s[4])),R(w,"keypress",s[15]),R(y,"click",Xe(s[6])),R(y,"keypress",s[16]),R(e,"dragstart",s[8]),R(e,"drop",Xe(pt(s[9]))),R(e,"dragover",pt(s[10])),R(e,"dragleave",s[17]),R(e,"click",s[18]),R(e,"keypress",s[19])],O=!0)},p(q,[H]){s=q,H&1&&s[0].name!==i.textContent&&(i.textContent=s[0].name),(!N||H&1)&&Ie(i,"server",s[0].location==="server"),(!N||H&4)&&Ie(e,"over",s[2]),s[0].open?x?(x.p(s,H),H&1&&E(x,1)):(x=mc(s),x.c(),E(x,1),x.m(I.parentNode,I)):x&&(Te(),F(x,1,1,()=>{x=null}),ve())},i(q){N||(q&&De(()=>{N&&(d&&d.end(1),C=Et(e,Kt,{duration:s[3]?0:400}),C.start())}),E(x),N=!0)},o(q){C&&C.invalidate(),q&&(d=Ct(e,Kt,{})),F(x),N=!1},d(q){q&&(v(e),v(g),v(I)),s[11](null),q&&d&&d.end(),x&&x.d(q),O=!1,be(X)}}}function Cd(s,e,t){let a;de(s,Xt,q=>t(3,a=q));let{folder:r}=e,i,o=()=>{t(1,i.contentEditable="true",i),i.focus(),setTimeout(()=>{const q=document.createRange();q.setStart(i,0),q.setEnd(i,1);const H=window.getSelection();H==null||H.removeAllRanges(),H==null||H.addRange(q)},1)};const l=q=>{q.key=="Enter"&&(q.preventDefault(),q.stopPropagation(),i.blur())},n=()=>{mt.deleteFolder(r)},u=()=>{r.createFolder(),t(0,r.open=!0,r),mt.updateFolders()};let p=!1;const w=()=>{At.set(r)},h=()=>{t(2,p=!1);const q=Ke(At);if(!q||r.data.includes(q))return;const H=mt.getFolder(q);H&&H.remove(q),q instanceof wt&&(mt.removeFolder(q),q.parent=r),r.add(q)},m=()=>{r!==Ke(At)&&t(2,p=!0)};function y(q){Re[q?"unshift":"push"](()=>{i=q,t(1,i)})}const T=()=>t(1,i.contentEditable="false",i);function C(){r.name=this.textContent,t(0,r)}const d=q=>{q.key==="Enter"&&(q.stopPropagation(),u())},g=q=>{q.key==="Enter"&&(q.stopPropagation(),o())},I=q=>{q.key==="Enter"&&(q.stopPropagation(),n())},N=()=>t(2,p=!1),O=()=>t(0,r.open=!r.open,r),X=q=>{q.key==="Enter"&&(q.stopPropagation(),t(0,r.open=!r.open,r))},x=q=>St(`${ft}/${q.dataType==="class"?"class":"skill"}/${q.name}${q.dataType==="class"?"/edit":""}`);return s.$$set=q=>{"folder"in q&&t(0,r=q.folder)},[r,i,p,a,o,l,n,u,w,h,m,y,T,C,d,g,I,N,O,X,x]}class Pu extends Fe{constructor(e){super(),Oe(this,e,Cd,Ed,$e,{folder:0})}}function gc(s,e,t){const a=s.slice();return a[6]=e[t],a[8]=t,a}function wc(s){let e,t=s[6]+"",a,r,i,o;function l(){return s[4](s[8])}function n(...u){return s[5](s[8],...u)}return{c(){e=S("div"),a=pe(t),this.h()},l(u){e=A(u,"DIV",{tabindex:!0,role:!0,"aria-checked":!0,class:!0});var p=Z(e);a=he(p,t),p.forEach(v),this.h()},h(){f(e,"tabindex","0"),f(e,"role","radio"),f(e,"aria-checked",r=s[0]==s[8]),f(e,"class","svelte-t61ag2")},m(u,p){P(u,e,p),D(e,a),i||(o=[R(e,"click",l),R(e,"keypress",n)],i=!0)},p(u,p){s=u,p&2&&t!==(t=s[6]+"")&&Le(a,t),p&1&&r!==(r=s[0]==s[8])&&f(e,"aria-checked",r)},d(u){u&&v(e),i=!1,be(o)}}}function Pd(s){let e,t=Pe(s[1]),a=[];for(let r=0;r<t.length;r+=1)a[r]=wc(gc(s,t,r));return{c(){e=S("div");for(let r=0;r<a.length;r+=1)a[r].c();this.h()},l(r){e=A(r,"DIV",{class:!0});var i=Z(e);for(let o=0;o<a.length;o+=1)a[o].l(i);i.forEach(v),this.h()},h(){f(e,"class","tabs svelte-t61ag2"),Ie(e,"selected",s[0]),Ie(e,"inline",s[3]),ne(e,"--color",s[2]),ne(e,"--count",s[1].length),ne(e,"--selected",s[0])},m(r,i){P(r,e,i);for(let o=0;o<a.length;o+=1)a[o]&&a[o].m(e,null)},p(r,[i]){if(i&3){t=Pe(r[1]);let o;for(o=0;o<t.length;o+=1){const l=gc(r,t,o);a[o]?a[o].p(l,i):(a[o]=wc(l),a[o].c(),a[o].m(e,null))}for(;o<a.length;o+=1)a[o].d(1);a.length=t.length}i&1&&Ie(e,"selected",r[0]),i&8&&Ie(e,"inline",r[3]),i&4&&ne(e,"--color",r[2]),i&2&&ne(e,"--count",r[1].length),i&1&&ne(e,"--selected",r[0])},i:fe,o:fe,d(r){r&&v(e),bt(a,r)}}}function $d(s,e,t){let{selectedTab:a}=e,{data:r=["True","False"]}=e,{color:i="#222"}=e,{inline:o=!0}=e;const l=u=>t(0,a=u),n=(u,p)=>{p.key==="Enter"&&t(0,a=u)};return s.$$set=u=>{"selectedTab"in u&&t(0,a=u.selectedTab),"data"in u&&t(1,r=u.data),"color"in u&&t(2,i=u.color),"inline"in u&&t(3,o=u.inline)},[a,r,i,o,l,n]}class Fd extends Fe{constructor(e){super(),Oe(this,e,$d,Pd,$e,{selectedTab:0,data:1,color:2,inline:3})}}function Od(s){let e;return{c(){e=S("div"),this.h()},l(t){e=A(t,"DIV",{class:!0,style:!0}),Z(e).forEach(v),this.h()},h(){f(e,"class","circle svelte-dqjlks"),ne(e,"--size",s[3]+s[1]),ne(e,"--color",s[0]),ne(e,"--duration",s[2]),Ie(e,"pause-animation",s[4])},m(t,a){P(t,e,a)},p(t,[a]){a&10&&ne(e,"--size",t[3]+t[1]),a&1&&ne(e,"--color",t[0]),a&4&&ne(e,"--duration",t[2]),a&16&&Ie(e,"pause-animation",t[4])},i:fe,o:fe,d(t){t&&v(e)}}}function Rd(s,e,t){let{color:a="#FF3E00"}=e,{unit:r="px"}=e,{duration:i="0.75s"}=e,{size:o="60"}=e,{pause:l=!1}=e;return s.$$set=n=>{"color"in n&&t(0,a=n.color),"unit"in n&&t(1,r=n.unit),"duration"in n&&t(2,i=n.duration),"size"in n&&t(3,o=n.size),"pause"in n&&t(4,l=n.pause)},[a,r,i,o,l]}class ip extends Fe{constructor(e){super(),Oe(this,e,Rd,Od,$e,{color:0,unit:1,duration:2,size:3,pause:4})}}function yc(s,e,t){const a=s.slice();return a[64]=e[t],a}function Tc(s,e,t){const a=s.slice();return a[64]=e[t],a}function vc(s,e,t){const a=s.slice();return a[79]=e[t],a[71]=t,a}function bc(s,e,t){const a=s.slice();return a[75]=e[t],a[71]=t,a}function kc(s,e,t){const a=s.slice();return a[75]=e[t],a}function _c(s,e,t){const a=s.slice();return a[69]=e[t],a[71]=t,a}function Ic(s,e,t){const a=s.slice();return a[72]=e[t],a}function Nd(s){let e,t=[],a=new Map,r,i,o,l,n,u=Pe(s[14]);const p=w=>w[79].name;for(let w=0;w<u.length;w+=1){let h=vc(s,u,w),m=p(h);a.set(m,t[w]=Dc(m,h))}return i=new gt({props:{delay:200+100*(s[14].length+1),direction:"right",$$slots:{default:[Bd]},$$scope:{ctx:s}}}),{c(){e=S("div");for(let w=0;w<t.length;w+=1)t[w].c();r=W(),J(i.$$.fragment),this.h()},l(w){e=A(w,"DIV",{class:!0});var h=Z(e);for(let m=0;m<t.length;m+=1)t[m].l(h);r=U(h),ae(i.$$.fragment,h),h.forEach(v),this.h()},h(){f(e,"class","items svelte-1utzp87")},m(w,h){P(w,e,h);for(let m=0;m<t.length;m+=1)t[m]&&t[m].m(e,null);D(e,r),Q(i,e,null),n=!0},p(w,h){h[0]&16384&&(u=Pe(w[14]),Te(),t=Rt(t,h,p,1,w,u,a,e,Sr,Dc,r,vc),ve());const m={};h[0]&16384&&(m.delay=200+100*(w[14].length+1)),h[2]&524288&&(m.$$scope={dirty:h,ctx:w}),i.$set(m)},i(w){if(!n){for(let h=0;h<u.length;h+=1)E(t[h]);E(i.$$.fragment,w),w&&De(()=>{n&&(l&&l.end(1),o=Et(e,me,{x:100}),o.start())}),n=!0}},o(w){for(let h=0;h<t.length;h+=1)F(t[h]);F(i.$$.fragment,w),o&&o.invalidate(),w&&(l=Ct(e,me,{x:100})),n=!1},d(w){w&&v(e);for(let h=0;h<t.length;h+=1)t[h].d();ee(i),w&&l&&l.end()}}}function Ld(s){let e,t,a=[],r=new Map,i,o,l,n,u,p,w,h=Pe(s[12]),m=[];for(let d=0;d<h.length;d+=1)m[d]=Sc(kc(s,h,d));const y=d=>F(m[d],1,1,()=>{m[d]=null});let T=Pe(s[13].filter(s[38]));const C=d=>d[75].key;for(let d=0;d<T.length;d+=1){let g=bc(s,T,d),I=C(g);r.set(I,a[d]=Ac(I,g))}return o=new gt({props:{delay:200+100*(s[13].length+1),direction:"right",$$slots:{default:[Wd]},$$scope:{ctx:s}}}),n=new gt({props:{delay:200+100*(s[11].length+2),direction:"right",$$slots:{default:[Ud]},$$scope:{ctx:s}}}),{c(){e=S("div");for(let d=0;d<m.length;d+=1)m[d].c();t=W();for(let d=0;d<a.length;d+=1)a[d].c();i=W(),J(o.$$.fragment),l=W(),J(n.$$.fragment),this.h()},l(d){e=A(d,"DIV",{class:!0});var g=Z(e);for(let I=0;I<m.length;I+=1)m[I].l(g);t=U(g);for(let I=0;I<a.length;I+=1)a[I].l(g);i=U(g),ae(o.$$.fragment,g),l=U(g),ae(n.$$.fragment,g),g.forEach(v),this.h()},h(){f(e,"class","items svelte-1utzp87")},m(d,g){P(d,e,g);for(let I=0;I<m.length;I+=1)m[I]&&m[I].m(e,null);D(e,t);for(let I=0;I<a.length;I+=1)a[I]&&a[I].m(e,null);D(e,i),Q(o,e,null),D(e,l),Q(n,e,null),w=!0},p(d,g){if(g[0]&4096){h=Pe(d[12]);let O;for(O=0;O<h.length;O+=1){const X=kc(d,h,O);m[O]?(m[O].p(X,g),E(m[O],1)):(m[O]=Sc(X),m[O].c(),E(m[O],1),m[O].m(e,t))}for(Te(),O=h.length;O<m.length;O+=1)y(O);ve()}g[0]&8194&&(T=Pe(d[13].filter(d[38])),Te(),a=Rt(a,g,C,1,d,T,r,e,Sr,Ac,i,bc),ve());const I={};g[0]&8192&&(I.delay=200+100*(d[13].length+1)),g[2]&524288&&(I.$$scope={dirty:g,ctx:d}),o.$set(I);const N={};g[0]&2048&&(N.delay=200+100*(d[11].length+2)),g[2]&524288&&(N.$$scope={dirty:g,ctx:d}),n.$set(N)},i(d){if(!w){for(let g=0;g<h.length;g+=1)E(m[g]);for(let g=0;g<T.length;g+=1)E(a[g]);E(o.$$.fragment,d),E(n.$$.fragment,d),d&&De(()=>{w&&(p&&p.end(1),u=Et(e,me,{x:100}),u.start())}),w=!0}},o(d){m=m.filter(Boolean);for(let g=0;g<m.length;g+=1)F(m[g]);for(let g=0;g<a.length;g+=1)F(a[g]);F(o.$$.fragment,d),F(n.$$.fragment,d),u&&u.invalidate(),d&&(p=Ct(e,me,{x:100})),w=!1},d(d){d&&v(e),bt(m,d);for(let g=0;g<a.length;g+=1)a[g].d();ee(o),ee(n),d&&p&&p.end()}}}function xd(s){let e,t,a=[],r=new Map,i,o,l,n,u,p,w,h=Pe(s[10]),m=[];for(let d=0;d<h.length;d+=1)m[d]=Vc(Ic(s,h,d));const y=d=>F(m[d],1,1,()=>{m[d]=null});let T=Pe(s[11].filter(s[28]));const C=d=>d[69].key;for(let d=0;d<T.length;d+=1){let g=_c(s,T,d),I=C(g);r.set(I,a[d]=qc(I,g))}return o=new gt({props:{delay:200+100*(s[11].length+1),$$slots:{default:[Gd]},$$scope:{ctx:s}}}),n=new gt({props:{delay:200+100*(s[11].length+2),$$slots:{default:[Yd]},$$scope:{ctx:s}}}),{c(){e=S("div");for(let d=0;d<m.length;d+=1)m[d].c();t=W();for(let d=0;d<a.length;d+=1)a[d].c();i=W(),J(o.$$.fragment),l=W(),J(n.$$.fragment),this.h()},l(d){e=A(d,"DIV",{class:!0});var g=Z(e);for(let I=0;I<m.length;I+=1)m[I].l(g);t=U(g);for(let I=0;I<a.length;I+=1)a[I].l(g);i=U(g),ae(o.$$.fragment,g),l=U(g),ae(n.$$.fragment,g),g.forEach(v),this.h()},h(){f(e,"class","items svelte-1utzp87")},m(d,g){P(d,e,g);for(let I=0;I<m.length;I+=1)m[I]&&m[I].m(e,null);D(e,t);for(let I=0;I<a.length;I+=1)a[I]&&a[I].m(e,null);D(e,i),Q(o,e,null),D(e,l),Q(n,e,null),w=!0},p(d,g){if(g[0]&1024){h=Pe(d[10]);let O;for(O=0;O<h.length;O+=1){const X=Ic(d,h,O);m[O]?(m[O].p(X,g),E(m[O],1)):(m[O]=Vc(X),m[O].c(),E(m[O],1),m[O].m(e,t))}for(Te(),O=h.length;O<m.length;O+=1)y(O);ve()}g[0]&2049&&(T=Pe(d[11].filter(d[28])),Te(),a=Rt(a,g,C,1,d,T,r,e,Sr,qc,i,_c),ve());const I={};g[0]&2048&&(I.delay=200+100*(d[11].length+1)),g[2]&524288&&(I.$$scope={dirty:g,ctx:d}),o.$set(I);const N={};g[0]&2048&&(N.delay=200+100*(d[11].length+2)),g[2]&524288&&(N.$$scope={dirty:g,ctx:d}),n.$set(N)},i(d){if(!w){for(let g=0;g<h.length;g+=1)E(m[g]);for(let g=0;g<T.length;g+=1)E(a[g]);E(o.$$.fragment,d),E(n.$$.fragment,d),d&&De(()=>{w&&(p&&p.end(1),u=Et(e,me,{x:-100}),u.start())}),w=!0}},o(d){m=m.filter(Boolean);for(let g=0;g<m.length;g+=1)F(m[g]);for(let g=0;g<a.length;g+=1)F(a[g]);F(o.$$.fragment,d),F(n.$$.fragment,d),u&&u.invalidate(),d&&(p=Ct(e,me,{x:-100})),w=!1},d(d){d&&v(e),bt(m,d);for(let g=0;g<a.length;g+=1)a[g].d();ee(o),ee(n),d&&p&&p.end()}}}function Hd(s){let e=s[79].name+"",t,a=s[79].location==="server"?"*":"",r;return{c(){t=pe(e),r=pe(a)},l(i){t=he(i,e),r=he(i,a)},m(i,o){P(i,t,o),P(i,r,o)},p(i,o){o[0]&16384&&e!==(e=i[79].name+"")&&Le(t,e),o[0]&16384&&a!==(a=i[79].location==="server"?"*":"")&&Le(r,a)},d(i){i&&(v(t),v(r))}}}function Dc(s,e){let t,a,r;function i(){return e[48](e[79])}return a=new gt({props:{data:e[79],direction:"right",delay:200+100*e[71],$$slots:{default:[Hd]},$$scope:{ctx:e}}}),a.$on("click",i),{key:s,first:null,c(){t=Ce(),J(a.$$.fragment),this.h()},l(o){t=Ce(),ae(a.$$.fragment,o),this.h()},h(){this.first=t},m(o,l){P(o,t,l),Q(a,o,l),r=!0},p(o,l){e=o;const n={};l[0]&16384&&(n.data=e[79]),l[0]&16384&&(n.delay=200+100*e[71]),l[0]&16384|l[2]&524288&&(n.$$scope={dirty:l,ctx:e}),a.$set(n)},i(o){r||(E(a.$$.fragment,o),r=!0)},o(o){F(a.$$.fragment,o),r=!1},d(o){o&&v(t),ee(a,o)}}}function Bd(s){let e,t,a="New Attribute",r,i;return{c(){e=S("div"),t=S("span"),t.textContent=a,this.h()},l(o){e=A(o,"DIV",{class:!0});var l=Z(e);t=A(l,"SPAN",{tabindex:!0,role:!0,class:!0,"data-svelte-h":!0}),re(t)!=="svelte-nmorth"&&(t.textContent=a),l.forEach(v),this.h()},h(){f(t,"tabindex","0"),f(t,"role","button"),f(t,"class","svelte-1utzp87"),f(e,"class","new svelte-1utzp87")},m(o,l){P(o,e,l),D(e,t),r||(i=[R(t,"click",s[49]),R(t,"keypress",s[50])],r=!0)},p:fe,d(o){o&&v(e),r=!1,be(i)}}}function Sc(s){let e,t;return e=new Pu({props:{folder:s[75]}}),{c(){J(e.$$.fragment)},l(a){ae(e.$$.fragment,a)},m(a,r){Q(e,a,r),t=!0},p(a,r){const i={};r[0]&4096&&(i.folder=a[75]),e.$set(i)},i(a){t||(E(e.$$.fragment,a),t=!0)},o(a){F(e.$$.fragment,a),t=!1},d(a){ee(e,a)}}}function zd(s){let e=s[75].name+"",t,a=s[75].location==="server"?"*":"",r;return{c(){t=pe(e),r=pe(a)},l(i){t=he(i,e),r=he(i,a)},m(i,o){P(i,t,o),P(i,r,o)},p(i,o){o[0]&8194&&e!==(e=i[75].name+"")&&Le(t,e),o[0]&8194&&a!==(a=i[75].location==="server"?"*":"")&&Le(r,a)},d(i){i&&(v(t),v(r))}}}function Ac(s,e){let t,a,r;function i(){return e[39](e[75])}return a=new gt({props:{data:e[75],direction:"right",delay:200+100*e[71],$$slots:{default:[zd]},$$scope:{ctx:e}}}),a.$on("click",i),{key:s,first:null,c(){t=Ce(),J(a.$$.fragment),this.h()},l(o){t=Ce(),ae(a.$$.fragment,o),this.h()},h(){this.first=t},m(o,l){P(o,t,l),Q(a,o,l),r=!0},p(o,l){e=o;const n={};l[0]&8194&&(n.data=e[75]),l[0]&8194&&(n.delay=200+100*e[71]),l[0]&8194|l[2]&524288&&(n.$$scope={dirty:l,ctx:e}),a.$set(n)},i(o){r||(E(a.$$.fragment,o),r=!0)},o(o){F(a.$$.fragment,o),r=!1},d(o){o&&v(t),ee(a,o)}}}function Wd(s){let e,t,a="New Skill",r,i,o="New Folder",l,n;return{c(){e=S("div"),t=S("span"),t.textContent=a,r=W(),i=S("span"),i.textContent=o,this.h()},l(u){e=A(u,"DIV",{class:!0});var p=Z(e);t=A(p,"SPAN",{tabindex:!0,role:!0,class:!0,"data-svelte-h":!0}),re(t)!=="svelte-gtczqq"&&(t.textContent=a),r=U(p),i=A(p,"SPAN",{class:!0,tabindex:!0,role:!0,"data-svelte-h":!0}),re(i)!=="svelte-zpm3y3"&&(i.textContent=o),p.forEach(v),this.h()},h(){f(t,"tabindex","0"),f(t,"role","button"),f(t,"class","svelte-1utzp87"),f(i,"class","new-folder svelte-1utzp87"),f(i,"tabindex","0"),f(i,"role","button"),f(e,"class","new svelte-1utzp87")},m(u,p){P(u,e,p),D(e,t),D(e,r),D(e,i),l||(n=[R(t,"click",s[40]),R(t,"keypress",s[41]),R(i,"click",s[42]),R(i,"keypress",s[43])],l=!0)},p:fe,d(u){u&&v(e),l=!1,be(n)}}}function Ud(s){let e,t,a="匯入技能",r,i,o="重新整理",l,n;return{c(){e=S("div"),t=S("span"),t.textContent=a,r=W(),i=S("span"),i.textContent=o,this.h()},l(u){e=A(u,"DIV",{class:!0});var p=Z(e);t=A(p,"SPAN",{tabindex:!0,role:!0,class:!0,"data-svelte-h":!0}),re(t)!=="svelte-hrag7r"&&(t.textContent=a),r=U(p),i=A(p,"SPAN",{tabindex:!0,role:!0,class:!0,"data-svelte-h":!0}),re(i)!=="svelte-1j6eeks"&&(i.textContent=o),p.forEach(v),this.h()},h(){f(t,"tabindex","0"),f(t,"role","button"),f(t,"class","svelte-1utzp87"),f(i,"tabindex","0"),f(i,"role","button"),f(i,"class","svelte-1utzp87"),f(e,"class","new svelte-1utzp87")},m(u,p){P(u,e,p),D(e,t),D(e,r),D(e,i),l||(n=[R(t,"click",s[44]),R(t,"keypress",s[45]),R(i,"click",s[46]),R(i,"keypress",s[47])],l=!0)},p:fe,d(u){u&&v(e),l=!1,be(n)}}}function Vc(s){let e,t;return e=new Pu({props:{folder:s[72]}}),{c(){J(e.$$.fragment)},l(a){ae(e.$$.fragment,a)},m(a,r){Q(e,a,r),t=!0},p(a,r){const i={};r[0]&1024&&(i.folder=a[72]),e.$set(i)},i(a){t||(E(e.$$.fragment,a),t=!0)},o(a){F(e.$$.fragment,a),t=!1},d(a){ee(e,a)}}}function jd(s){let e=s[69].name+"",t,a=s[69].location==="server"?"*":"",r;return{c(){t=pe(e),r=pe(a)},l(i){t=he(i,e),r=he(i,a)},m(i,o){P(i,t,o),P(i,r,o)},p(i,o){o[0]&2049&&e!==(e=i[69].name+"")&&Le(t,e),o[0]&2049&&a!==(a=i[69].location==="server"?"*":"")&&Le(r,a)},d(i){i&&(v(t),v(r))}}}function qc(s,e){let t,a,r;function i(){return e[29](e[69])}return a=new gt({props:{data:e[69],delay:200+100*e[71],$$slots:{default:[jd]},$$scope:{ctx:e}}}),a.$on("click",i),{key:s,first:null,c(){t=Ce(),J(a.$$.fragment),this.h()},l(o){t=Ce(),ae(a.$$.fragment,o),this.h()},h(){this.first=t},m(o,l){P(o,t,l),Q(a,o,l),r=!0},p(o,l){e=o;const n={};l[0]&2049&&(n.data=e[69]),l[0]&2049&&(n.delay=200+100*e[71]),l[0]&2049|l[2]&524288&&(n.$$scope={dirty:l,ctx:e}),a.$set(n)},i(o){r||(E(a.$$.fragment,o),r=!0)},o(o){F(a.$$.fragment,o),r=!1},d(o){o&&v(t),ee(a,o)}}}function Gd(s){let e,t,a="New Class",r,i,o="New Folder",l,n;return{c(){e=S("div"),t=S("span"),t.textContent=a,r=W(),i=S("span"),i.textContent=o,this.h()},l(u){e=A(u,"DIV",{class:!0});var p=Z(e);t=A(p,"SPAN",{tabindex:!0,role:!0,class:!0,"data-svelte-h":!0}),re(t)!=="svelte-1av437t"&&(t.textContent=a),r=U(p),i=A(p,"SPAN",{class:!0,tabindex:!0,role:!0,"data-svelte-h":!0}),re(i)!=="svelte-19k87vn"&&(i.textContent=o),p.forEach(v),this.h()},h(){f(t,"tabindex","0"),f(t,"role","button"),f(t,"class","svelte-1utzp87"),f(i,"class","new-folder svelte-1utzp87"),f(i,"tabindex","0"),f(i,"role","button"),f(e,"class","new svelte-1utzp87")},m(u,p){P(u,e,p),D(e,t),D(e,r),D(e,i),l||(n=[R(t,"click",s[30]),R(t,"keypress",s[31]),R(i,"click",s[32]),R(i,"keypress",s[33])],l=!0)},p:fe,d(u){u&&v(e),l=!1,be(n)}}}function Yd(s){let e,t,a="匯入信仰",r,i,o="重新整理",l,n;return{c(){e=S("div"),t=S("span"),t.textContent=a,r=W(),i=S("span"),i.textContent=o,this.h()},l(u){e=A(u,"DIV",{class:!0});var p=Z(e);t=A(p,"SPAN",{tabindex:!0,role:!0,style:!0,class:!0,"data-svelte-h":!0}),re(t)!=="svelte-kfcoo5"&&(t.textContent=a),r=U(p),i=A(p,"SPAN",{tabindex:!0,role:!0,class:!0,"data-svelte-h":!0}),re(i)!=="svelte-8fp9n2"&&(i.textContent=o),p.forEach(v),this.h()},h(){f(t,"tabindex","0"),f(t,"role","button"),ne(t,"font-size","14.9px"),f(t,"class","svelte-1utzp87"),f(i,"tabindex","0"),f(i,"role","button"),f(i,"class","svelte-1utzp87"),f(e,"class","new svelte-1utzp87")},m(u,p){P(u,e,p),D(e,t),D(e,r),D(e,i),l||(n=[R(t,"click",s[34]),R(t,"keypress",s[35]),R(i,"click",s[36]),R(i,"keypress",s[37])],l=!0)},p:fe,d(u){u&&v(e),l=!1,be(n)}}}function Xd(s){let e,t,a,r=Pe(s[6].classes),i=[];for(let o=0;o<r.length;o+=1)i[o]=Ec(Tc(s,r,o));return{c(){e=S("select");for(let o=0;o<i.length;o+=1)i[o].c();this.h()},l(o){e=A(o,"SELECT",{});var l=Z(e);for(let n=0;n<i.length;n+=1)i[n].l(l);l.forEach(v),this.h()},h(){s[7]===void 0&&De(()=>s[53].call(e))},m(o,l){P(o,e,l);for(let n=0;n<i.length;n+=1)i[n]&&i[n].m(e,null);qt(e,s[7],!0),t||(a=R(e,"change",s[53]),t=!0)},p(o,l){if(l[0]&64){r=Pe(o[6].classes);let n;for(n=0;n<r.length;n+=1){const u=Tc(o,r,n);i[n]?i[n].p(u,l):(i[n]=Ec(u),i[n].c(),i[n].m(e,null))}for(;n<i.length;n+=1)i[n].d(1);i.length=r.length}l[0]&192&&qt(e,o[7])},i:fe,o:fe,d(o){o&&v(e),bt(i,o),t=!1,a()}}}function Kd(s){let e,t;return e=new ip({props:{size:"25",color:"#0083ef"}}),{c(){J(e.$$.fragment)},l(a){ae(e.$$.fragment,a)},m(a,r){Q(e,a,r),t=!0},p:fe,i(a){t||(E(e.$$.fragment,a),t=!0)},o(a){F(e.$$.fragment,a),t=!1},d(a){ee(e,a)}}}function Ec(s){let e,t=s[64]+"",a,r;return{c(){e=S("option"),a=pe(t),this.h()},l(i){e=A(i,"OPTION",{});var o=Z(e);a=he(o,t),o.forEach(v),this.h()},h(){e.__value=r=s[64],it(e,e.__value)},m(i,o){P(i,e,o),D(e,a)},p(i,o){o[0]&64&&t!==(t=i[64]+"")&&Le(a,t),o[0]&64&&r!==(r=i[64])&&(e.__value=r,it(e,e.__value))},d(i){i&&v(e)}}}function Zd(s){let e,t,a,r;const i=[Kd,Xd],o=[];function l(n,u){return n[8]?0:1}return e=l(s),t=o[e]=i[e](s),{c(){t.c(),a=Ce()},l(n){t.l(n),a=Ce()},m(n,u){o[e].m(n,u),P(n,a,u),r=!0},p(n,u){let p=e;e=l(n),e===p?o[e].p(n,u):(Te(),F(o[p],1,1,()=>{o[p]=null}),ve(),t=o[e],t?t.p(n,u):(t=o[e]=i[e](n),t.c()),E(t,1),t.m(a.parentNode,a))},i(n){r||(E(t),r=!0)},o(n){F(t),r=!1},d(n){n&&v(a),o[e].d(n)}}}function Md(s){let e,t="匯入信仰",a,r,i,o,l,n,u,p="確認匯入",w,h,m;return l=new je({props:{label:"信仰 ID",tooltip:"要匯入的信仰 ID",$$slots:{default:[Zd]},$$scope:{ctx:s}}}),{c(){e=S("h2"),e.textContent=t,a=W(),r=S("hr"),i=W(),o=S("div"),J(l.$$.fragment),n=W(),u=S("button"),u.textContent=p,this.h()},l(y){e=A(y,"H2",{"data-svelte-h":!0}),re(e)!=="svelte-7hcei3"&&(e.textContent=t),a=U(y),r=A(y,"HR",{class:!0}),i=U(y),o=A(y,"DIV",{class:!0});var T=Z(o);ae(l.$$.fragment,T),n=U(T),u=A(T,"BUTTON",{class:!0,style:!0,tabindex:!0,"data-svelte-h":!0}),re(u)!=="svelte-hi39nh"&&(u.textContent=p),T.forEach(v),this.h()},h(){f(r,"class","svelte-1utzp87"),f(u,"class","button"),ne(u,"grid-column","1 / span 2"),f(u,"tabindex","0"),f(o,"class","import-container svelte-1utzp87")},m(y,T){P(y,e,T),P(y,a,T),P(y,r,T),P(y,i,T),P(y,o,T),Q(l,o,null),D(o,n),D(o,u),w=!0,h||(m=[R(u,"click",s[54]),R(u,"keypress",s[55])],h=!0)},p(y,T){const C={};T[0]&448|T[2]&524288&&(C.$$scope={dirty:T,ctx:y}),l.$set(C)},i(y){w||(E(l.$$.fragment,y),w=!0)},o(y){F(l.$$.fragment,y),w=!1},d(y){y&&(v(e),v(a),v(r),v(i),v(o)),ee(l),h=!1,be(m)}}}function Jd(s){let e,t,a,r=Pe(s[6].skills),i=[];for(let o=0;o<r.length;o+=1)i[o]=Cc(yc(s,r,o));return{c(){e=S("select");for(let o=0;o<i.length;o+=1)i[o].c();this.h()},l(o){e=A(o,"SELECT",{});var l=Z(e);for(let n=0;n<i.length;n+=1)i[n].l(l);l.forEach(v),this.h()},h(){s[7]===void 0&&De(()=>s[56].call(e))},m(o,l){P(o,e,l);for(let n=0;n<i.length;n+=1)i[n]&&i[n].m(e,null);qt(e,s[7],!0),t||(a=R(e,"change",s[56]),t=!0)},p(o,l){if(l[0]&64){r=Pe(o[6].skills);let n;for(n=0;n<r.length;n+=1){const u=yc(o,r,n);i[n]?i[n].p(u,l):(i[n]=Cc(u),i[n].c(),i[n].m(e,null))}for(;n<i.length;n+=1)i[n].d(1);i.length=r.length}l[0]&192&&qt(e,o[7])},i:fe,o:fe,d(o){o&&v(e),bt(i,o),t=!1,a()}}}function Qd(s){let e,t;return e=new ip({props:{size:"25",color:"#0083ef"}}),{c(){J(e.$$.fragment)},l(a){ae(e.$$.fragment,a)},m(a,r){Q(e,a,r),t=!0},p:fe,i(a){t||(E(e.$$.fragment,a),t=!0)},o(a){F(e.$$.fragment,a),t=!1},d(a){ee(e,a)}}}function Cc(s){let e,t=s[64]+"",a,r;return{c(){e=S("option"),a=pe(t),this.h()},l(i){e=A(i,"OPTION",{});var o=Z(e);a=he(o,t),o.forEach(v),this.h()},h(){e.__value=r=s[64],it(e,e.__value)},m(i,o){P(i,e,o),D(e,a)},p(i,o){o[0]&64&&t!==(t=i[64]+"")&&Le(a,t),o[0]&64&&r!==(r=i[64])&&(e.__value=r,it(e,e.__value))},d(i){i&&v(e)}}}function em(s){let e,t,a,r;const i=[Qd,Jd],o=[];function l(n,u){return n[8]?0:1}return e=l(s),t=o[e]=i[e](s),{c(){t.c(),a=Ce()},l(n){t.l(n),a=Ce()},m(n,u){o[e].m(n,u),P(n,a,u),r=!0},p(n,u){let p=e;e=l(n),e===p?o[e].p(n,u):(Te(),F(o[p],1,1,()=>{o[p]=null}),ve(),t=o[e],t?t.p(n,u):(t=o[e]=i[e](n),t.c()),E(t,1),t.m(a.parentNode,a))},i(n){r||(E(t),r=!0)},o(n){F(t),r=!1},d(n){n&&v(a),o[e].d(n)}}}function tm(s){let e,t="匯入技能",a,r,i,o,l,n,u,p="確認匯入",w,h,m;return l=new je({props:{label:"技能 ID",tooltip:"要匯入的技能 ID",$$slots:{default:[em]},$$scope:{ctx:s}}}),{c(){e=S("h2"),e.textContent=t,a=W(),r=S("hr"),i=W(),o=S("div"),J(l.$$.fragment),n=W(),u=S("button"),u.textContent=p,this.h()},l(y){e=A(y,"H2",{"data-svelte-h":!0}),re(e)!=="svelte-1xduf6p"&&(e.textContent=t),a=U(y),r=A(y,"HR",{class:!0}),i=U(y),o=A(y,"DIV",{class:!0});var T=Z(o);ae(l.$$.fragment,T),n=U(T),u=A(T,"BUTTON",{class:!0,style:!0,tabindex:!0,"data-svelte-h":!0}),re(u)!=="svelte-g69zbn"&&(u.textContent=p),T.forEach(v),this.h()},h(){f(r,"class","svelte-1utzp87"),f(u,"class","button"),ne(u,"grid-column","1 / span 2"),f(u,"tabindex","0"),f(o,"class","import-container svelte-1utzp87")},m(y,T){P(y,e,T),P(y,a,T),P(y,r,T),P(y,i,T),P(y,o,T),Q(l,o,null),D(o,n),D(o,u),w=!0,h||(m=[R(u,"click",s[57]),R(u,"keypress",s[58])],h=!0)},p(y,T){const C={};T[0]&448|T[2]&524288&&(C.$$scope={dirty:T,ctx:y}),l.$set(C)},i(y){w||(E(l.$$.fragment,y),w=!0)},o(y){F(l.$$.fragment,y),w=!1},d(y){y&&(v(e),v(a),v(r),v(i),v(o)),ee(l),h=!1,be(m)}}}function am(s){let e=!1,t=()=>{e=!1},a,r,i,o,l,n,u,p,w,h,m,y=`calc(${s[3]}px - 6rem + min(3rem, ${s[4]}px))`,T,C,d,g,I,N,O;De(s[25]),De(s[26]);function X(Y){s[27](Y)}let x={color:"#111",data:["Classes","Skills","Attributes"],inline:!1};s[9]!==void 0&&(x.selectedTab=s[9]),o=new Fd({props:x}),Re.push(()=>Be(o,"selectedTab",X));const q=[xd,Ld,Nd],H=[];function se(Y,oe){return Y[9]===vt.CLASSES?0:Y[9]===vt.SKILLS?1:Y[9]===vt.ATTRIBUTES?2:-1}return~(w=se(s))&&(h=H[w]=q[w](s)),C=new Vt({props:{open:s[5]==="class",width:"300px",$$slots:{default:[Md]},$$scope:{ctx:s}}}),C.$on("close",s[23]),g=new Vt({props:{open:s[5]==="skill",width:"500px",$$slots:{default:[tm]},$$scope:{ctx:s}}}),g.$on("close",s[23]),{c(){r=S("div"),i=S("div"),J(o.$$.fragment),n=W(),u=S("hr"),p=W(),h&&h.c(),T=W(),J(C.$$.fragment),d=W(),J(g.$$.fragment),this.h()},l(Y){r=A(Y,"DIV",{id:!0,class:!0});var oe=Z(r);i=A(oe,"DIV",{class:!0});var ke=Z(i);ae(o.$$.fragment,ke),n=U(ke),u=A(ke,"HR",{class:!0}),ke.forEach(v),p=U(oe),h&&h.l(oe),oe.forEach(v),T=U(Y),ae(C.$$.fragment,Y),d=U(Y),ae(g.$$.fragment,Y),this.h()},h(){f(u,"class","svelte-1utzp87"),f(i,"class","type-wrap svelte-1utzp87"),f(r,"id","sidebar"),f(r,"class","svelte-1utzp87"),ne(r,"--height",y)},m(Y,oe){P(Y,r,oe),D(r,i),Q(o,i,null),D(i,n),D(i,u),D(r,p),~w&&H[w].m(r,null),P(Y,T,oe),Q(C,Y,oe),P(Y,d,oe),Q(g,Y,oe),I=!0,N||(O=[R(window,"beforeunload",s[24]),R(window,"resize",s[25]),R(window,"scroll",()=>{e=!0,clearTimeout(a),a=setTimeout(t,100),s[26]()}),R(r,"introend",s[51]),R(r,"outroend",s[52]),yp(Ap.call(null,r,s[22]))],N=!0)},p(Y,oe){oe[0]&16&&!e&&(e=!0,clearTimeout(a),scrollTo(window.pageXOffset,Y[4]),a=setTimeout(t,100));const ke={};!l&&oe[0]&512&&(l=!0,ke.selectedTab=Y[9],He(()=>l=!1)),o.$set(ke);let Ne=w;w=se(Y),w===Ne?~w&&H[w].p(Y,oe):(h&&(Te(),F(H[Ne],1,1,()=>{H[Ne]=null}),ve()),~w?(h=H[w],h?h.p(Y,oe):(h=H[w]=q[w](Y),h.c()),E(h,1),h.m(r,null)):h=null),oe[0]&24&&y!==(y=`calc(${Y[3]}px - 6rem + min(3rem, ${Y[4]}px))`)&&ne(r,"--height",y);const Se={};oe[0]&32&&(Se.open=Y[5]==="class"),oe[0]&448|oe[2]&524288&&(Se.$$scope={dirty:oe,ctx:Y}),C.$set(Se);const j={};oe[0]&32&&(j.open=Y[5]==="skill"),oe[0]&448|oe[2]&524288&&(j.$$scope={dirty:oe,ctx:Y}),g.$set(j)},i(Y){I||(E(o.$$.fragment,Y),E(h),Y&&De(()=>{I&&(m||(m=ye(r,$u,{},!0)),m.run(1))}),E(C.$$.fragment,Y),E(g.$$.fragment,Y),I=!0)},o(Y){F(o.$$.fragment,Y),F(h),Y&&(m||(m=ye(r,$u,{},!1)),m.run(0)),F(C.$$.fragment,Y),F(g.$$.fragment,Y),I=!1},d(Y){Y&&(v(r),v(T),v(d)),ee(o),~w&&H[w].d(),Y&&m&&m.end(),ee(C,Y),ee(g,Y),N=!1,be(O)}}}function sm(s,e,t){let a,r,i,o,l,n;de(s,Ut,M=>t(9,a=M));let u=[],p,w,h=[],m=[],y,T,C,d="none",g={classes:[],skills:[]},I="",N=!1;const O=xe.skills;de(s,O,M=>t(13,l=M));const X=xe.skillFolders;de(s,X,M=>t(12,o=M));const x=at.classes;de(s,x,M=>t(11,i=M));const q=at.classFolders;de(s,q,M=>t(10,r=M));const H=Tt.attributes;de(s,H,M=>t(14,n=M));const se=(M,Hr)=>{M instanceof Array&&M.forEach(up=>se(up,Hr)),M instanceof wt?se(M.data,Hr):(M instanceof yt||M instanceof ot)&&Hr.push(M)},Y=M=>{switch(Ke(Ut)){case vt.CLASSES:{u=M||Ke(q),t(0,h=[]),se(u,h);break}case vt.SKILLS:{u=M||Ke(xe.skillFolders),t(1,m=[]),se(u,m);break}}},oe=()=>{t(5,d="class"),t(8,N=!0),rh().then(M=>{t(6,g.classes=M,g)}).finally(()=>{t(8,N=!1)})},ke=()=>{t(5,d="skill"),t(8,N=!0),nh().then(M=>{t(6,g.skills=M,g)}).finally(()=>{t(8,N=!1)})};Su(()=>{p=q.subscribe(Y),w=xe.skillFolders.subscribe(Y)}),Tp(Y),Au(()=>{p&&p(),w&&w()});const Ne=M=>{y<500&&(M.stopPropagation(),Zp())},Se=()=>{t(5,d="none")},j=()=>Ot.disconnect();function K(){t(2,y=window.innerWidth),t(3,T=window.innerHeight)}function le(){t(4,C=window.pageYOffset)}function Ze(M){a=M,Ut.set(a)}const tt=M=>!h.includes(M),ge=M=>St(`${ft}/class/${M.name}/edit`),dt=()=>at.addClass(),We=M=>M.key==="Enter"&&at.addClass(),_e=()=>at.addClassFolder(new wt),Ae=M=>M.key==="Enter"&&at.addClassFolder(new wt),Ve=()=>oe(),nt=M=>M.key==="Enter"&&oe(),_t=()=>Yu(),qe=M=>M.key==="Enter"&&Yu(),ze=M=>!m.includes(M),Ee=M=>St(`${ft}/skill/${M.name}`),$=()=>xe.addSkill(),te=M=>M.key==="Enter"&&xe.addSkill(),ct=()=>xe.addSkillFolder(new wt),Ue=M=>M.key==="Enter"&&xe.addSkillFolder(new wt),$r=()=>ke(),Fr=M=>M.key==="Enter"&&ke(),Or=()=>Xu(),Rr=M=>M.key==="Enter"&&Xu(),Nr=M=>St(`${ft}/attribute/${M.name}/edit`),Lr=()=>Tt.addAttribute(),z=M=>M.key==="Enter"&&Tt.addAttribute(),Ye=()=>Xt.set(!0),st=()=>Xt.set(!1);function It(){I=Wr(this),t(7,I),t(6,g)}const xr=()=>Ku(I),Bt=M=>M.key==="Enter"&&Ku(I);function lp(){I=Wr(this),t(7,I),t(6,g)}return[h,m,y,T,C,d,g,I,N,a,r,i,o,l,n,O,X,x,q,H,oe,ke,Ne,Se,j,K,le,Ze,tt,ge,dt,We,_e,Ae,Ve,nt,_t,qe,ze,Ee,$,te,ct,Ue,$r,Fr,Or,Rr,Nr,Lr,z,Ye,st,It,xr,Bt,lp,()=>Zu(I),M=>M.key==="Enter"&&Zu(I)]}class om extends Fe{constructor(e){super(),Oe(this,e,sm,am,$e,{},null,[-1,-1,-1])}}function Pc(s,e,t){const a=s.slice();return a[12]=e[t],a}function $c(s){let e,t,a=s[12]+"",r;return{c(){e=S("option"),t=pe("1."),r=pe(a),this.h()},l(i){e=A(i,"OPTION",{});var o=Z(e);t=he(o,"1."),r=he(o,a),o.forEach(v),this.h()},h(){e.__value=s[12],it(e,e.__value)},m(i,o){P(i,e,o),D(e,t),D(e,r)},p:fe,d(i){i&&v(e)}}}function rm(s){let e,t,a,r=Pe(Object.keys(Hu).reverse()),i=[];for(let o=0;o<r.length;o+=1)i[o]=$c(Pc(s,r,o));return{c(){e=S("select");for(let o=0;o<i.length;o+=1)i[o].c();this.h()},l(o){e=A(o,"SELECT",{});var l=Z(e);for(let n=0;n<i.length;n+=1)i[n].l(l);l.forEach(v),this.h()},h(){s[1]===void 0&&De(()=>s[6].call(e))},m(o,l){P(o,e,l);for(let n=0;n<i.length;n+=1)i[n]&&i[n].m(e,null);qt(e,s[1],!0),t||(a=R(e,"change",s[6]),t=!0)},p(o,l){if(l&0){r=Pe(Object.keys(Hu).reverse());let n;for(n=0;n<r.length;n+=1){const u=Pc(o,r,n);i[n]?i[n].p(u,l):(i[n]=$c(u),i[n].c(),i[n].m(e,null))}for(;n<i.length;n+=1)i[n].d(1);i.length=r.length}l&2&&qt(e,o[1])},d(o){o&&v(e),bt(i,o),t=!1,a()}}}function nm(s){let e,t,a;function r(o){s[7](o)}let i={left:"Symbols",right:"Text"};return s[2]!==void 0&&(i.data=s[2]),e=new Vu({props:i}),Re.push(()=>Be(e,"data",r)),{c(){J(e.$$.fragment)},l(o){ae(e.$$.fragment,o)},m(o,l){Q(e,o,l),a=!0},p(o,l){const n={};!t&&l&4&&(t=!0,n.data=o[2],He(()=>t=!1)),e.$set(n)},i(o){a||(E(e.$$.fragment,o),a=!0)},o(o){F(e.$$.fragment,o),a=!1},d(o){ee(e,o)}}}function im(s){let e,t,a;function r(o){s[8](o)}let i={left:"True",right:"False"};return s[3]!==void 0&&(i.data=s[3]),e=new Vu({props:i}),Re.push(()=>Be(e,"data",r)),{c(){J(e.$$.fragment)},l(o){ae(e.$$.fragment,o)},m(o,l){Q(e,o,l),a=!0},p(o,l){const n={};!t&&l&8&&(t=!0,n.data=o[3],He(()=>t=!1)),e.$set(n)},i(o){a||(E(e.$$.fragment,o),a=!0)},o(o){F(e.$$.fragment,o),a=!1},d(o){ee(e,o)}}}function lm(s){let e,t,a;function r(o){s[9](o)}let i={};return s[4]!==void 0&&(i.data=s[4]),e=new Vu({props:i}),Re.push(()=>Be(e,"data",r)),{c(){J(e.$$.fragment)},l(o){ae(e.$$.fragment,o)},m(o,l){Q(e,o,l),a=!0},p(o,l){const n={};!t&&l&16&&(t=!0,n.data=o[4],He(()=>t=!1)),e.$set(n)},i(o){a||(E(e.$$.fragment,o),a=!0)},o(o){F(e.$$.fragment,o),a=!1},d(o){ee(e,o)}}}function um(s){let e,t="Settings",a,r,i,o,l,n,u,p,w,h,m,y,T,C,d,g="Clear Data",I,N,O;return l=new je({props:{label:"Server",tooltip:"This should match your target Spigot server version",$$slots:{default:[rm]},$$scope:{ctx:s}}}),u=new je({props:{label:"Use Symbols",tooltip:"If skill components should use symbols instead of text",$$slots:{default:[nm]},$$scope:{ctx:s}}}),w=new je({props:{label:"Show Summary Items",tooltip:"If skill components should show a simplified summary on the element",$$slots:{default:[im]},$$scope:{ctx:s}}}),m=new je({props:{label:"Waterfall Animation",tooltip:"If the waterfall animation should play in the sidebar",$$slots:{default:[lm]},$$scope:{ctx:s}}}),{c(){e=S("h1"),e.textContent=t,a=W(),r=S("hr"),i=W(),o=S("div"),J(l.$$.fragment),n=W(),J(u.$$.fragment),p=W(),J(w.$$.fragment),h=W(),J(m.$$.fragment),y=W(),T=S("hr"),C=W(),d=S("button"),d.textContent=g,this.h()},l(X){e=A(X,"H1",{"data-svelte-h":!0}),re(e)!=="svelte-171lafx"&&(e.textContent=t),a=U(X),r=A(X,"HR",{}),i=U(X),o=A(X,"DIV",{class:!0});var x=Z(o);ae(l.$$.fragment,x),n=U(x),ae(u.$$.fragment,x),p=U(x),ae(w.$$.fragment,x),h=U(x),ae(m.$$.fragment,x),y=U(x),T=A(x,"HR",{class:!0}),C=U(x),d=A(x,"BUTTON",{class:!0,"data-svelte-h":!0}),re(d)!=="svelte-mz4zjt"&&(d.textContent=g),x.forEach(v),this.h()},h(){f(T,"class","span svelte-1wp1eds"),f(d,"class","button btn-danger span svelte-1wp1eds"),f(o,"class","settings-container svelte-1wp1eds")},m(X,x){P(X,e,x),P(X,a,x),P(X,r,x),P(X,i,x),P(X,o,x),Q(l,o,null),D(o,n),Q(u,o,null),D(o,p),Q(w,o,null),D(o,h),Q(m,o,null),D(o,y),D(o,T),D(o,C),D(o,d),I=!0,N||(O=R(d,"click",s[5]),N=!0)},p(X,x){const q={};x&32770&&(q.$$scope={dirty:x,ctx:X}),l.$set(q);const H={};x&32772&&(H.$$scope={dirty:x,ctx:X}),u.$set(H);const se={};x&32776&&(se.$$scope={dirty:x,ctx:X}),w.$set(se);const Y={};x&32784&&(Y.$$scope={dirty:x,ctx:X}),m.$set(Y)},i(X){I||(E(l.$$.fragment,X),E(u.$$.fragment,X),E(w.$$.fragment,X),E(m.$$.fragment,X),I=!0)},o(X){F(l.$$.fragment,X),F(u.$$.fragment,X),F(w.$$.fragment,X),F(m.$$.fragment,X),I=!1},d(X){X&&(v(e),v(a),v(r),v(i),v(o)),ee(l),ee(u),ee(w),ee(m),N=!1,O()}}}function cm(s){let e,t,a;function r(o){s[10](o)}let i={width:"50rem",$$slots:{default:[um]},$$scope:{ctx:s}};return s[0]!==void 0&&(i.open=s[0]),e=new Vt({props:i}),Re.push(()=>Be(e,"open",r)),e.$on("close",s[11]),{c(){J(e.$$.fragment)},l(o){ae(e.$$.fragment,o)},m(o,l){Q(e,o,l),a=!0},p(o,[l]){const n={};l&32798&&(n.$$scope={dirty:l,ctx:o}),!t&&l&1&&(t=!0,n.open=o[0],He(()=>t=!1)),e.$set(n)},i(o){a||(E(e.$$.fragment,o),a=!0)},o(o){F(e.$$.fragment,o),a=!1},d(o){ee(e,o)}}}function pm(s,e,t){let a,r,i,o;de(s,xu,T=>t(1,a=T)),de(s,Wu,T=>t(2,r=T)),de(s,Uu,T=>t(3,i=T)),de(s,Gr,T=>t(4,o=T));let l=!0;const n=()=>{confirm("Are you sure you want to clear all data?")&&(at.classes.set([]),at.classFolders.set([]),xe.skills.set([]),xe.skillFolders.set([]),Tt.attributes.set([]))};function u(){a=Wr(this),xu.set(a)}function p(T){r=T,Wu.set(r)}function w(T){i=T,Uu.set(i)}function h(T){o=T,Gr.set(o)}function m(T){l=T,t(0,l)}function y(T){Yc.call(this,s,T)}return[l,a,r,i,o,n,u,p,w,h,m,y]}class Fc extends Fe{constructor(e){super(),Oe(this,e,pm,cm,$e,{})}}function Oc(s){let e,t;return e=new om({}),{c(){J(e.$$.fragment)},l(a){ae(e.$$.fragment,a)},m(a,r){Q(e,a,r),t=!0},i(a){t||(E(e.$$.fragment,a),t=!0)},o(a){F(e.$$.fragment,a),t=!1},d(a){ee(e,a)}}}function Rc(s){let e,t,a,r,i=`${s[8]*5}deg`,o=`${s[9]}rem`,l,n,u,p,w,h=`${s[8]*7}deg`,m=`${s[9]}rem`,y,T,C,d,g,I=`${s[8]*9}deg`,N=`${s[9]}rem`,O,X,x;const q=[dm,hm],H=[];function se(K,le){return K[2]==="save"&&K[3]!=="NONE"?0:1}t=se(s),a=H[t]=q[t](s);const Y=[fm,mm],oe=[];function ke(K,le){return K[2]==="export"&&K[3]!=="NONE"?0:1}u=ke(s),p=oe[u]=Y[u](s);const Ne=[wm,gm],Se=[];function j(K,le){return K[2]==="reload"&&K[3]!=="NONE"?0:1}return C=j(s),d=Se[C]=Ne[C](s),{c(){e=S("div"),a.c(),l=W(),n=S("div"),p.c(),y=W(),T=S("div"),d.c(),this.h()},l(K){e=A(K,"DIV",{class:!0,title:!0,tabindex:!0,role:!0});var le=Z(e);a.l(le),le.forEach(v),l=U(K),n=A(K,"DIV",{class:!0,title:!0,tabindex:!0,role:!0});var Ze=Z(n);p.l(Ze),Ze.forEach(v),y=U(K),T=A(K,"DIV",{class:!0,title:!0,tabindex:!0,role:!0});var tt=Z(T);d.l(tt),tt.forEach(v),this.h()},h(){f(e,"class","button socket-upload svelte-10061vz"),f(e,"title","Save to Server"),f(e,"tabindex","0"),f(e,"role","button"),ne(e,"--rotation",i),ne(e,"--distance",o),f(n,"class","button socket-all svelte-10061vz"),f(n,"title","Upload All to Server"),f(n,"tabindex","0"),f(n,"role","button"),ne(n,"--rotation",h),ne(n,"--distance",m),f(T,"class","button socket-reload svelte-10061vz"),f(T,"title","Reload ProSkillAPI"),f(T,"tabindex","0"),f(T,"role","button"),ne(T,"--rotation",I),ne(T,"--distance",N)},m(K,le){P(K,e,le),H[t].m(e,null),P(K,l,le),P(K,n,le),oe[u].m(n,null),P(K,y,le),P(K,T,le),Se[C].m(T,null),O=!0,X||(x=[R(e,"click",s[36]),R(e,"keypress",s[37]),R(n,"click",s[38]),R(n,"keypress",s[39]),R(T,"click",s[40]),R(T,"keypress",s[41])],X=!0)},p(K,le){let Ze=t;t=se(K),t===Ze?H[t].p(K,le):(Te(),F(H[Ze],1,1,()=>{H[Ze]=null}),ve(),a=H[t],a?a.p(K,le):(a=H[t]=q[t](K),a.c()),E(a,1),a.m(e,null)),le[0]&256&&i!==(i=`${K[8]*5}deg`)&&ne(e,"--rotation",i),le[0]&512&&o!==(o=`${K[9]}rem`)&&ne(e,"--distance",o);let tt=u;u=ke(K),u===tt?oe[u].p(K,le):(Te(),F(oe[tt],1,1,()=>{oe[tt]=null}),ve(),p=oe[u],p?p.p(K,le):(p=oe[u]=Y[u](K),p.c()),E(p,1),p.m(n,null)),le[0]&256&&h!==(h=`${K[8]*7}deg`)&&ne(n,"--rotation",h),le[0]&512&&m!==(m=`${K[9]}rem`)&&ne(n,"--distance",m);let ge=C;C=j(K),C===ge?Se[C].p(K,le):(Te(),F(Se[ge],1,1,()=>{Se[ge]=null}),ve(),d=Se[C],d?d.p(K,le):(d=Se[C]=Ne[C](K),d.c()),E(d,1),d.m(T,null)),le[0]&256&&I!==(I=`${K[8]*9}deg`)&&ne(T,"--rotation",I),le[0]&512&&N!==(N=`${K[9]}rem`)&&ne(T,"--distance",N)},i(K){O||(E(a),K&&De(()=>{O&&(r||(r=ye(e,me,{x:100,easing:Dt},!0)),r.run(1))}),E(p),K&&De(()=>{O&&(w||(w=ye(n,me,{x:100,easing:Dt},!0)),w.run(1))}),E(d),K&&De(()=>{O&&(g||(g=ye(T,me,{x:100,easing:Dt},!0)),g.run(1))}),O=!0)},o(K){F(a),K&&(r||(r=ye(e,me,{x:100,easing:Dt},!1)),r.run(0)),F(p),K&&(w||(w=ye(n,me,{x:100,easing:Dt},!1)),w.run(0)),F(d),K&&(g||(g=ye(T,me,{x:100,easing:Dt},!1)),g.run(0)),O=!1},d(K){K&&(v(e),v(l),v(n),v(y),v(T)),H[t].d(),K&&r&&r.end(),oe[u].d(),K&&w&&w.end(),Se[C].d(),K&&g&&g.end(),X=!1,be(x)}}}function hm(s){let e,t="upload_file",a,r;return{c(){e=S("span"),e.textContent=t,this.h()},l(i){e=A(i,"SPAN",{class:!0,"data-svelte-h":!0}),re(e)!=="svelte-1st114i"&&(e.textContent=t),this.h()},h(){f(e,"class","material-symbols-rounded svelte-10061vz")},m(i,o){P(i,e,o),r=!0},p:fe,i(i){r||(i&&De(()=>{r&&(a||(a=ye(e,me,{y:20},!0)),a.run(1))}),r=!0)},o(i){i&&(a||(a=ye(e,me,{y:20},!1)),a.run(0)),r=!1},d(i){i&&v(e),i&&a&&a.end()}}}function dm(s){let e,t=s[20][s[3]]+"",a,r,i;return{c(){e=S("span"),a=pe(t),this.h()},l(o){e=A(o,"SPAN",{class:!0});var l=Z(e);a=he(l,t),l.forEach(v),this.h()},h(){f(e,"class","material-symbols-rounded svelte-10061vz")},m(o,l){P(o,e,l),D(e,a),i=!0},p(o,l){(!i||l[0]&8)&&t!==(t=o[20][o[3]]+"")&&Le(a,t)},i(o){i||(o&&De(()=>{i&&(r||(r=ye(e,me,{y:-20},!0)),r.run(1))}),i=!0)},o(o){o&&(r||(r=ye(e,me,{y:-20},!1)),r.run(0)),i=!1},d(o){o&&v(e),o&&r&&r.end()}}}function mm(s){let e,t="cloud_upload",a,r;return{c(){e=S("span"),e.textContent=t,this.h()},l(i){e=A(i,"SPAN",{class:!0,"data-svelte-h":!0}),re(e)!=="svelte-12qjsy9"&&(e.textContent=t),this.h()},h(){f(e,"class","material-symbols-rounded svelte-10061vz")},m(i,o){P(i,e,o),r=!0},p:fe,i(i){r||(i&&De(()=>{r&&(a||(a=ye(e,me,{y:20},!0)),a.run(1))}),r=!0)},o(i){i&&(a||(a=ye(e,me,{y:20},!1)),a.run(0)),r=!1},d(i){i&&v(e),i&&a&&a.end()}}}function fm(s){let e,t=s[20][s[3]]+"",a,r,i;return{c(){e=S("span"),a=pe(t),this.h()},l(o){e=A(o,"SPAN",{class:!0});var l=Z(e);a=he(l,t),l.forEach(v),this.h()},h(){f(e,"class","material-symbols-rounded svelte-10061vz")},m(o,l){P(o,e,l),D(e,a),i=!0},p(o,l){(!i||l[0]&8)&&t!==(t=o[20][o[3]]+"")&&Le(a,t)},i(o){i||(o&&De(()=>{i&&(r||(r=ye(e,me,{y:-20},!0)),r.run(1))}),i=!0)},o(o){o&&(r||(r=ye(e,me,{y:-20},!1)),r.run(0)),i=!1},d(o){o&&v(e),o&&r&&r.end()}}}function gm(s){let e,t="sync",a,r;return{c(){e=S("span"),e.textContent=t,this.h()},l(i){e=A(i,"SPAN",{class:!0,"data-svelte-h":!0}),re(e)!=="svelte-6ct6vh"&&(e.textContent=t),this.h()},h(){f(e,"class","material-symbols-rounded svelte-10061vz")},m(i,o){P(i,e,o),r=!0},p:fe,i(i){r||(i&&De(()=>{r&&(a||(a=ye(e,me,{y:20},!0)),a.run(1))}),r=!0)},o(i){i&&(a||(a=ye(e,me,{y:20},!1)),a.run(0)),r=!1},d(i){i&&v(e),i&&a&&a.end()}}}function wm(s){let e,t=s[20][s[3]]+"",a,r,i;return{c(){e=S("span"),a=pe(t),this.h()},l(o){e=A(o,"SPAN",{class:!0});var l=Z(e);a=he(l,t),l.forEach(v),this.h()},h(){f(e,"class","material-symbols-rounded svelte-10061vz")},m(o,l){P(o,e,l),D(e,a),i=!0},p(o,l){(!i||l[0]&8)&&t!==(t=o[20][o[3]]+"")&&Le(a,t)},i(o){i||(o&&De(()=>{i&&(r||(r=ye(e,me,{y:-20},!0)),r.run(1))}),i=!0)},o(o){o&&(r||(r=ye(e,me,{y:-20},!1)),r.run(0)),i=!1},d(o){o&&v(e),o&&r&&r.end()}}}function Nc(s){let e,t;return e=new wd({}),{c(){J(e.$$.fragment)},l(a){ae(e.$$.fragment,a)},m(a,r){Q(e,a,r),t=!0},i(a){t||(E(e.$$.fragment,a),t=!0)},o(a){F(e.$$.fragment,a),t=!1},d(a){ee(e,a)}}}function Lc(s){let e,t,a,r=s[12].name+"",i,o,l,n,u="We can keep it in memory for you to use, but will be unable to persist it to your browser's storage.",p,w,h="Closing/Refreshing the page will cause you to lose this data.",m,y,T="You'll need to export it and re-import later if you want to keep working with this.",C,d,g="I Understand",I,N,O,X;return{c(){e=S("div"),t=S("strong"),a=pe("Failed to save "),i=pe(r),o=pe(" - Data is too large."),l=W(),n=S("div"),n.textContent=u,p=W(),w=S("div"),w.textContent=h,m=W(),y=S("div"),y.textContent=T,C=W(),d=S("div"),d.textContent=g,this.h()},l(x){e=A(x,"DIV",{class:!0});var q=Z(e);t=A(q,"STRONG",{});var H=Z(t);a=he(H,"Failed to save "),i=he(H,r),o=he(H," - Data is too large."),H.forEach(v),l=U(q),n=A(q,"DIV",{"data-svelte-h":!0}),re(n)!=="svelte-1h0k73e"&&(n.textContent=u),p=U(q),w=A(q,"DIV",{"data-svelte-h":!0}),re(w)!=="svelte-w2jdnb"&&(w.textContent=h),m=U(q),y=A(q,"DIV",{"data-svelte-h":!0}),re(y)!=="svelte-facved"&&(y.textContent=T),C=U(q),d=A(q,"DIV",{class:!0,tabindex:!0,role:!0,"data-svelte-h":!0}),re(d)!=="svelte-d89sv5"&&(d.textContent=g),q.forEach(v),this.h()},h(){f(d,"class","acknowledge button"),f(d,"tabindex","0"),f(d,"role","button"),f(e,"class","save-error svelte-10061vz")},m(x,q){P(x,e,q),D(e,t),D(t,a),D(t,i),D(t,o),D(e,l),D(e,n),D(e,p),D(e,w),D(e,m),D(e,y),D(e,C),D(e,d),N=!0,O||(X=[R(d,"click",s[44]),R(d,"keypress",s[45])],O=!0)},p(x,q){(!N||q[0]&4096)&&r!==(r=x[12].name+"")&&Le(i,r)},i(x){N||(x&&De(()=>{N&&(I||(I=ye(e,me,{y:-20},!0)),I.run(1))}),N=!0)},o(x){x&&(I||(I=ye(e,me,{y:-20},!1)),I.run(0)),N=!1},d(x){x&&v(e),x&&I&&I.end(),O=!1,be(X)}}}function xc(s){let e,t=s[15]?"Saving...":"Saved!",a,r,i;return{c(){e=S("div"),a=pe(t),this.h()},l(o){e=A(o,"DIV",{class:!0});var l=Z(e);a=he(l,t),l.forEach(v),this.h()},h(){f(e,"class","saving svelte-10061vz")},m(o,l){P(o,e,l),D(e,a),i=!0},p(o,l){(!i||l[0]&32768)&&t!==(t=o[15]?"Saving...":"Saved!")&&Le(a,t)},i(o){i||(o&&De(()=>{i&&(r||(r=ye(e,me,{y:-20},!0)),r.run(1))}),i=!0)},o(o){o&&(r||(r=ye(e,me,{y:-20},!1)),r.run(0)),i=!1},d(o){o&&v(e),o&&r&&r.end()}}}function Hc(s){let e,t="Drop to Import",a,r;return{c(){e=S("div"),e.textContent=t,this.h()},l(i){e=A(i,"DIV",{class:!0,role:!0,"data-svelte-h":!0}),re(e)!=="svelte-1h6jzl1"&&(e.textContent=t),this.h()},h(){f(e,"class","dragging svelte-10061vz"),f(e,"role","form")},m(i,o){P(i,e,o),a||(r=R(e,"dragleave",s[25]),a=!0)},p:fe,d(i){i&&v(e),a=!1,r()}}}function ym(s){let e,t="Untrusted Connection to Server",a,r,i,o,l,n,u,p,w;return{c(){e=S("h3"),e.textContent=t,a=W(),r=S("div"),i=pe(`Server is not trusted. Please run
		`),o=S("div"),l=pe("/synth trust "),n=pe(s[5]),u=pe(`
		from the server`),this.h()},l(h){e=A(h,"H3",{"data-svelte-h":!0}),re(e)!=="svelte-1hlo2oy"&&(e.textContent=t),a=U(h),r=A(h,"DIV",{});var m=Z(r);i=he(m,`Server is not trusted. Please run
		`),o=A(m,"DIV",{class:!0,tabindex:!0,role:!0});var y=Z(o);l=he(y,"/synth trust "),n=he(y,s[5]),y.forEach(v),u=he(m,`
		from the server`),m.forEach(v),this.h()},h(){f(o,"class","code svelte-10061vz"),f(o,"tabindex","0"),f(o,"role","button"),Ie(o,"copied",s[4])},m(h,m){P(h,e,m),P(h,a,m),P(h,r,m),D(r,i),D(r,o),D(o,l),D(o,n),D(r,u),p||(w=[R(o,"click",s[31]),R(o,"keypress",s[46])],p=!0)},p(h,m){m[0]&32&&Le(n,h[5]),m[0]&16&&Ie(o,"copied",h[4])},d(h){h&&(v(e),v(a),v(r)),p=!1,be(w)}}}function Bc(s){let e,t,a,r,i,o,l,n="Click to remain connected",u,p,w,h;return{c(){e=S("div"),t=S("strong"),a=pe("You will lose connection in "),r=pe(s[18]),i=pe(" seconds"),o=W(),l=S("div"),l.textContent=n,this.h()},l(m){e=A(m,"DIV",{class:!0});var y=Z(e);t=A(y,"STRONG",{});var T=Z(t);a=he(T,"You will lose connection in "),r=he(T,s[18]),i=he(T," seconds"),T.forEach(v),o=U(y),l=A(y,"DIV",{class:!0,tabindex:!0,role:!0,"data-svelte-h":!0}),re(l)!=="svelte-13aa7dm"&&(l.textContent=n),y.forEach(v),this.h()},h(){f(l,"class","button svelte-10061vz"),f(l,"tabindex","0"),f(l,"role","button"),f(e,"class","dc-warning svelte-10061vz")},m(m,y){P(m,e,y),D(e,t),D(t,a),D(t,r),D(t,i),D(e,o),D(e,l),p=!0,w||(h=[R(l,"click",s[47]),R(l,"keypress",s[48])],w=!0)},p(m,y){(!p||y[0]&262144)&&Le(r,m[18])},i(m){p||(m&&De(()=>{p&&(u||(u=ye(e,me,{y:-20},!0)),u.run(1))}),p=!0)},o(m){m&&(u||(u=ye(e,me,{y:-20},!1)),u.run(0)),p=!1},d(m){m&&v(e),m&&u&&u.end(),w=!1,be(h)}}}function Tm(s){let e,t,a,r,i,o,l,n,u,p,w='<span class="material-symbols-rounded svelte-10061vz">cloud_download</span>',h=`${s[8]}deg`,m=`${s[9]}rem`,y,T,C='<span class="material-symbols-rounded svelte-10061vz">upload</span>',d=`${s[8]*3}deg`,g=`${s[9]}rem`,I,N,O,X='<span class="material-symbols-rounded svelte-10061vz">settings</span>',x,q,H,se,Y,oe,ke,Ne,Se,j,K,le,Ze,tt;e=new _d({}),a=new vd({});let ge=s[7]&&Oc();const dt=s[32].default,We=Wc(dt,s,s[49],null);let _e=s[10]&&Rc(s),Ae=s[11]&&Nc(),Ve=s[12]&&Lc(s);var nt=s[13];function _t($,te){return{props:{data:$[14]}}}nt&&(se=Gt(nt,_t(s)),se.$on("close",Fu),se.$on("save",s[26]));let qe=s[1]&&xc(s),ze=s[0]&&Hc(s);Ne=new Vt({props:{open:!!s[5]&&!s[16],$$slots:{default:[ym]},$$scope:{ctx:s}}});let Ee=s[17]>0&&Bc(s);return K=new cd({}),{c(){J(e.$$.fragment),t=W(),J(a.$$.fragment),r=W(),i=S("div"),ge&&ge.c(),o=W(),l=S("div"),We&&We.c(),n=W(),u=S("div"),p=S("div"),p.innerHTML=w,y=W(),T=S("div"),T.innerHTML=C,I=W(),_e&&_e.c(),N=W(),O=S("div"),O.innerHTML=X,x=W(),Ae&&Ae.c(),q=W(),Ve&&Ve.c(),H=W(),se&&J(se.$$.fragment),Y=W(),qe&&qe.c(),oe=W(),ze&&ze.c(),ke=W(),J(Ne.$$.fragment),Se=W(),Ee&&Ee.c(),j=W(),J(K.$$.fragment),this.h()},l($){ae(e.$$.fragment,$),t=U($),ae(a.$$.fragment,$),r=U($),i=A($,"DIV",{id:!0,class:!0});var te=Z(i);ge&&ge.l(te),o=U(te),l=A(te,"DIV",{id:!0,class:!0});var ct=Z(l);We&&We.l(ct),ct.forEach(v),te.forEach(v),n=U($),u=A($,"DIV",{id:!0,class:!0});var Ue=Z(u);p=A(Ue,"DIV",{class:!0,title:!0,tabindex:!0,role:!0,"data-svelte-h":!0}),re(p)!=="svelte-1itohvq"&&(p.innerHTML=w),y=U(Ue),T=A(Ue,"DIV",{class:!0,title:!0,tabindex:!0,role:!0,"data-svelte-h":!0}),re(T)!=="svelte-6p42ky"&&(T.innerHTML=C),I=U(Ue),_e&&_e.l(Ue),N=U(Ue),O=A(Ue,"DIV",{class:!0,title:!0,tabindex:!0,role:!0,"data-svelte-h":!0}),re(O)!=="svelte-1ay6b1h"&&(O.innerHTML=X),Ue.forEach(v),x=U($),Ae&&Ae.l($),q=U($),Ve&&Ve.l($),H=U($),se&&ae(se.$$.fragment,$),Y=U($),qe&&qe.l($),oe=U($),ze&&ze.l($),ke=U($),ae(Ne.$$.fragment,$),Se=U($),Ee&&Ee.l($),j=U($),ae(K.$$.fragment,$),this.h()},h(){f(l,"id","body"),f(l,"class","svelte-10061vz"),Ie(l,"centered",!s[6]),f(i,"id","body-container"),f(i,"class","svelte-10061vz"),Ie(i,"empty",!s[6]),f(p,"class","button backup svelte-10061vz"),f(p,"title","Backup All Data"),f(p,"tabindex","0"),f(p,"role","button"),ne(p,"--rotation",h),ne(p,"--distance",m),f(T,"class","button save svelte-10061vz"),f(T,"title","Upload"),f(T,"tabindex","0"),f(T,"role","button"),ne(T,"--rotation",d),ne(T,"--distance",g),f(O,"class","button settings svelte-10061vz"),f(O,"title","Change Settings"),f(O,"tabindex","0"),f(O,"role","button"),ne(O,"--rotation","60deg"),ne(O,"--distance","1rem"),f(u,"id","floating-buttons"),f(u,"class","svelte-10061vz")},m($,te){Q(e,$,te),P($,t,te),Q(a,$,te),P($,r,te),P($,i,te),ge&&ge.m(i,null),D(i,o),D(i,l),We&&We.m(l,null),P($,n,te),P($,u,te),D(u,p),D(u,y),D(u,T),D(u,I),_e&&_e.m(u,null),D(u,N),D(u,O),P($,x,te),Ae&&Ae.m($,te),P($,q,te),Ve&&Ve.m($,te),P($,H,te),se&&Q(se,$,te),P($,Y,te),qe&&qe.m($,te),P($,oe,te),ze&&ze.m($,te),P($,ke,te),Q(Ne,$,te),P($,Se,te),Ee&&Ee.m($,te),P($,j,te),Q(K,$,te),le=!0,Ze||(tt=[R(p,"click",sp),R(p,"keypress",s[33]),R(T,"click",s[34]),R(T,"keypress",s[35]),R(O,"click",s[42]),R(O,"keypress",s[43])],Ze=!0)},p($,te){if($[7]?ge?te[0]&128&&E(ge,1):(ge=Oc(),ge.c(),E(ge,1),ge.m(i,o)):ge&&(Te(),F(ge,1,1,()=>{ge=null}),ve()),We&&We.p&&(!le||te[1]&262144)&&Uc(We,dt,$,$[49],le?Gc(dt,$[49],te,null):jc($[49]),null),(!le||te[0]&64)&&Ie(l,"centered",!$[6]),(!le||te[0]&64)&&Ie(i,"empty",!$[6]),te[0]&256&&h!==(h=`${$[8]}deg`)&&ne(p,"--rotation",h),te[0]&512&&m!==(m=`${$[9]}rem`)&&ne(p,"--distance",m),te[0]&256&&d!==(d=`${$[8]*3}deg`)&&ne(T,"--rotation",d),te[0]&512&&g!==(g=`${$[9]}rem`)&&ne(T,"--distance",g),$[10]?_e?(_e.p($,te),te[0]&1024&&E(_e,1)):(_e=Rc($),_e.c(),E(_e,1),_e.m(u,N)):_e&&(Te(),F(_e,1,1,()=>{_e=null}),ve()),$[11]?Ae?te[0]&2048&&E(Ae,1):(Ae=Nc(),Ae.c(),E(Ae,1),Ae.m(q.parentNode,q)):Ae&&(Te(),F(Ae,1,1,()=>{Ae=null}),ve()),$[12]?Ve?(Ve.p($,te),te[0]&4096&&E(Ve,1)):(Ve=Lc($),Ve.c(),E(Ve,1),Ve.m(H.parentNode,H)):Ve&&(Te(),F(Ve,1,1,()=>{Ve=null}),ve()),te[0]&8192&&nt!==(nt=$[13])){if(se){Te();const Ue=se;F(Ue.$$.fragment,1,0,()=>{ee(Ue,1)}),ve()}nt?(se=Gt(nt,_t($)),se.$on("close",Fu),se.$on("save",$[26]),J(se.$$.fragment),E(se.$$.fragment,1),Q(se,Y.parentNode,Y)):se=null}else if(nt){const Ue={};te[0]&16384&&(Ue.data=$[14]),se.$set(Ue)}$[1]?qe?(qe.p($,te),te[0]&2&&E(qe,1)):(qe=xc($),qe.c(),E(qe,1),qe.m(oe.parentNode,oe)):qe&&(Te(),F(qe,1,1,()=>{qe=null}),ve()),$[0]?ze?ze.p($,te):(ze=Hc($),ze.c(),ze.m(ke.parentNode,ke)):ze&&(ze.d(1),ze=null);const ct={};te[0]&65568&&(ct.open=!!$[5]&&!$[16]),te[0]&48|te[1]&262144&&(ct.$$scope={dirty:te,ctx:$}),Ne.$set(ct),$[17]>0?Ee?(Ee.p($,te),te[0]&131072&&E(Ee,1)):(Ee=Bc($),Ee.c(),E(Ee,1),Ee.m(j.parentNode,j)):Ee&&(Te(),F(Ee,1,1,()=>{Ee=null}),ve())},i($){le||(E(e.$$.fragment,$),E(a.$$.fragment,$),E(ge),E(We,$),E(_e),E(Ae),E(Ve),se&&E(se.$$.fragment,$),E(qe),E(Ne.$$.fragment,$),E(Ee),E(K.$$.fragment,$),le=!0)},o($){F(e.$$.fragment,$),F(a.$$.fragment,$),F(ge),F(We,$),F(_e),F(Ae),F(Ve),se&&F(se.$$.fragment,$),F(qe),F(Ne.$$.fragment,$),F(Ee),F(K.$$.fragment,$),le=!1},d($){$&&(v(t),v(r),v(i),v(n),v(u),v(x),v(q),v(H),v(Y),v(oe),v(ke),v(Se),v(j)),ee(e,$),ee(a,$),ge&&ge.d(),We&&We.d($),_e&&_e.d(),Ae&&Ae.d($),Ve&&Ve.d($),se&&ee(se,$),qe&&qe.d($),ze&&ze.d($),ee(Ne,$),Ee&&Ee.d($),ee(K,$),Ze=!1,be(tt)}}}function vm(s,e,t){let a,r,i,o,l,n,u,p,w,h,m,y,T,C;de(s,Yt,z=>t(6,r=z)),de(s,Mp,z=>t(7,i=z)),de(s,ju,z=>t(10,n=z)),de(s,Jp,z=>t(11,u=z)),de(s,Br,z=>t(12,p=z)),de(s,mp,z=>t(13,w=z)),de(s,fp,z=>t(14,h=z)),de(s,Qp,z=>t(16,y=z)),de(s,Gu,z=>t(17,T=z));let{$$slots:d={},$$scope:g}=e;const I=xe.isSaving;de(s,I,z=>t(15,m=z));let N=!1,O=!1,X,x,q="",H="NONE";const se={SAVING:"hourglass_empty",SAVED:"check",ERROR:"error"};let Y=!1;const oe=Ot.keyphrase;de(s,oe,z=>t(5,a=z));let ke=zt(ju,(z,Ye)=>Ye(z?6:3)),Ne=zt(ke,(z,Ye)=>Ye(120/((z-1)*2)));de(s,Ne,z=>t(8,o=z));let Se=zt(ke,(z,Ye)=>Ye((4.725*(z-1)+1.5)/Math.PI));de(s,Se,z=>t(9,l=z));let j=zt(Gu,(z,Ye)=>{let st,It=0;const xr=()=>{let Bt=z-++It;if(Bt<=0){clearInterval(st);return}Ye(Bt)};return Ye(z),st=window.setInterval(()=>xr(),1e3),()=>clearInterval(st)});de(s,j,z=>t(18,C=z)),Su(()=>{document.addEventListener("dragover",K),document.addEventListener("drop",Ze),x=xe.isSaving.subscribe(z=>{if(!z){setTimeout(()=>t(1,O=!1),1e3);return}X&&clearTimeout(X),X=setTimeout(()=>t(1,O=!0),1e3)})}),Au(()=>{document.removeEventListener("dragover",K),document.removeEventListener("drop",Ze),x&&x()});const K=z=>{var Ye,st;!((Ye=z==null?void 0:z.dataTransfer)!=null&&Ye.types)||!(z.dataTransfer.types.length>0&&((st=z.dataTransfer)==null?void 0:st.types[0])=="Files")||(z.dataTransfer.dropEffect="copy",z.stopPropagation(),z.preventDefault(),t(0,N=!0))},le=()=>{setTimeout(()=>t(0,N=!1),50)},Ze=z=>{var Ye;if(!(!((Ye=z==null?void 0:z.dataTransfer)!=null&&Ye.files)||z.dataTransfer.files.length==0)){t(0,N=!1);for(let st=0;st<z.dataTransfer.files.length;st++){const It=z.dataTransfer.files[st];It.name.indexOf(".yml")!=-1&&tp(It)}z.stopPropagation(),z.preventDefault()}},tt=()=>{var z;xe.skills.set([...Ke(xe.skills)]),(z=Ke(Yt))==null||z.save()},ge=()=>{const z=Ke(Br);z&&(z.acknowledged=!0),Br.set(void 0)},dt=async()=>{if(H==="SAVING")return;t(2,q="save"),t(3,H="SAVING"),await eh()?t(3,H="SAVED"):t(3,H="ERROR"),setTimeout(()=>t(3,H="NONE"),2e3)},We=async()=>{if(H==="SAVING")return;t(2,q="export"),t(3,H="SAVING"),await th()?t(3,H="SAVED"):t(3,H="ERROR"),setTimeout(()=>t(3,H="NONE"),2e3)},_e=async()=>{if(H==="SAVING")return;t(2,q="reload"),t(3,H="SAVING"),await Ot.reloadSapi()?t(3,H="SAVED"):t(3,H="ERROR"),setTimeout(()=>t(3,H="NONE"),2e3)},Ae=()=>{navigator.clipboard.writeText("/synth trust "+a),t(4,Y=!0),setTimeout(()=>t(4,Y=!1),2e3)},Ve=z=>z.key==="Enter"&&sp(),nt=()=>Mu(),_t=z=>{z.key==="Enter"&&Mu()},qe=()=>dt(),ze=z=>{z.key==="Enter"&&dt()},Ee=()=>We(),$=z=>{z.key==="Enter"&&We()},te=()=>_e(),ct=z=>{z.key==="Enter"&&_e()},Ue=()=>Ou(Fc),$r=z=>z.key==="Enter"&&Ou(Fc),Fr=()=>{ge()},Or=z=>{z.key==="Enter"&&ge()},Rr=z=>{z.key==="Enter"&&Ae()},Nr=()=>Ot.ping(),Lr=z=>{z.key==="Enter"&&Ot.ping()};return s.$$set=z=>{"$$scope"in z&&t(49,g=z.$$scope)},[N,O,q,H,Y,a,r,i,o,l,n,u,p,w,h,m,y,T,C,I,se,oe,Ne,Se,j,le,tt,ge,dt,We,_e,Ae,d,Ve,nt,_t,qe,ze,Ee,$,te,ct,Ue,$r,Fr,Or,Rr,Nr,Lr,g]}class Om extends Fe{constructor(e){super(),Oe(this,e,vm,Tm,$e,{},null,[-1,-1])}}export{Om as component,Fm as universal};
